var React = require('react');
'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _extends = require('@babel/runtime/helpers/extends');
var _objectWithoutPropertiesLoose = require('@babel/runtime/helpers/objectWithoutPropertiesLoose');
var react = require('react');
var fiber = require('@react-three/fiber');
var three = require('three');
var three$1 = require('@react-spring/three');
var culori = require('culori');
var drei = require('@react-three/drei');
var cannon = require('@react-three/cannon');
var WebGLExtensions = require('three/src/renderers/webgl/WebGLExtensions');
var KTX2Loader = require('three/examples/jsm/loaders/KTX2Loader');
var suspendReact = require('suspend-react');
var BufferGeometryUtils = require('three/examples/jsm/utils/BufferGeometryUtils');
var threeMeshBvh = require('three-mesh-bvh');
var _taggedTemplateLiteralLoose = require('@babel/runtime/helpers/taggedTemplateLiteralLoose');
var react$1 = require('@emotion/react');
var nipplejs = require('nipplejs');
var styled = require('@emotion/styled');
var reactDeviceDetect = require('react-device-detect');
var _asyncToGenerator = require('@babel/runtime/helpers/asyncToGenerator');
var xr = require('@react-three/xr');
var threeStdlib = require('three-stdlib');
var reactErrorBoundary = require('react-error-boundary');
var reactDom = require('react-dom');
var RoundedBoxGeometry = require('three/examples/jsm/geometries/RoundedBoxGeometry');
var troikaThreeText = require('troika-three-text');
var snapshotInterpolation = require('@geckos.io/snapshot-interpolation');
var peerjs = require('peerjs');
var core = require('@react-spring/core');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

function _interopNamespace(e) {
    if (e && e.__esModule) return e;
    var n = Object.create(null);
    if (e) {
        Object.keys(e).forEach(function (k) {
            if (k !== 'default') {
                var d = Object.getOwnPropertyDescriptor(e, k);
                Object.defineProperty(n, k, d.get ? d : {
                    enumerable: true,
                    get: function () { return e[k]; }
                });
            }
        });
    }
    n["default"] = e;
    return Object.freeze(n);
}

var _extends__default = /*#__PURE__*/_interopDefaultLegacy(_extends);
var _objectWithoutPropertiesLoose__default = /*#__PURE__*/_interopDefaultLegacy(_objectWithoutPropertiesLoose);
var culori__namespace = /*#__PURE__*/_interopNamespace(culori);
var _taggedTemplateLiteralLoose__default = /*#__PURE__*/_interopDefaultLegacy(_taggedTemplateLiteralLoose);
var nipplejs__default = /*#__PURE__*/_interopDefaultLegacy(nipplejs);
var styled__default = /*#__PURE__*/_interopDefaultLegacy(styled);
var _asyncToGenerator__default = /*#__PURE__*/_interopDefaultLegacy(_asyncToGenerator);

var vertHead$3 = "\n    // Description : Array and textureless GLSL 2D/3D/4D simplex\n    //               noise functions.\n    //      Author : Ian McEwan, Ashima Arts.\n    //  Maintainer : ijm\n    //     Lastmod : 20110822 (ijm)\n    //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n    //               Distributed under the MIT License. See LICENSE file.\n    //               https://github.com/ashima/webgl-noise\n    //\n    \n    vec3 mod289(vec3 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 mod289(vec4 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 permute(vec4 x) {\n         return mod289(((x*34.0)+1.0)*x);\n    }\n    \n    vec4 taylorInvSqrt(vec4 r)\n    {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n    \n    float snoise(vec3 v)\n      {\n      const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n      const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n    \n    // First corner\n      vec3 i  = floor(v + dot(v, C.yyy) );\n      vec3 x0 =   v - i + dot(i, C.xxx) ;\n    \n    // Other corners\n      vec3 g = step(x0.yzx, x0.xyz);\n      vec3 l = 1.0 - g;\n      vec3 i1 = min( g.xyz, l.zxy );\n      vec3 i2 = max( g.xyz, l.zxy );\n    \n      //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n      //   x1 = x0 - i1  + 1.0 * C.xxx;\n      //   x2 = x0 - i2  + 2.0 * C.xxx;\n      //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n      vec3 x1 = x0 - i1 + C.xxx;\n      vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n      vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n    \n    // Permutations\n      i = mod289(i);\n      vec4 p = permute( permute( permute(\n                 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n               + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n               + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    \n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n      float n_ = 0.142857142857; // 1.0/7.0\n      vec3  ns = n_ * D.wyz - D.xzx;\n    \n      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n    \n      vec4 x_ = floor(j * ns.z);\n      vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n    \n      vec4 x = x_ *ns.x + ns.yyyy;\n      vec4 y = y_ *ns.x + ns.yyyy;\n      vec4 h = 1.0 - abs(x) - abs(y);\n    \n      vec4 b0 = vec4( x.xy, y.xy );\n      vec4 b1 = vec4( x.zw, y.zw );\n    \n      //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n      //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n      vec4 s0 = floor(b0)*2.0 + 1.0;\n      vec4 s1 = floor(b1)*2.0 + 1.0;\n      vec4 sh = -step(h, vec4(0.0));\n    \n      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n    \n      vec3 p0 = vec3(a0.xy,h.x);\n      vec3 p1 = vec3(a0.zw,h.y);\n      vec3 p2 = vec3(a1.xy,h.z);\n      vec3 p3 = vec3(a1.zw,h.w);\n    \n    //Normalise gradients\n      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n      p0 *= norm.x;\n      p1 *= norm.y;\n      p2 *= norm.z;\n      p3 *= norm.w;\n    \n    // Mix final noise value\n      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n      m = m * m;\n      return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                    dot(p2,x2), dot(p3,x3) ) );\n      }\n              \n    \n    float fsnoise(float val1, float val2, float val3){\n      return snoise(vec3(val1,val2,val3));\n    }\n    \n    vec3 distortFunct(vec3 transformed, float factor) {\n      float radiusVariation = -fsnoise(\n        transformed.x * radiusNoiseFrequency + time,\n        transformed.y * radiusNoiseFrequency + time,\n        transformed.z * radiusNoiseFrequency + time \n      ) * radiusVariationAmplitude * factor;\n      return normalize(transformed) * (radiusVariation + radius);\n    }\n    \n    vec3 orthogonal(vec3 v) {\n      return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)\n      : vec3(0.0, -v.z, v.y));\n    }\n    \n    vec3 distortNormal(vec3 position, vec3 distortedPosition, vec3 normal){\n      vec3 tangent1 = orthogonal(normal);\n      vec3 tangent2 = normalize(cross(normal, tangent1));\n      vec3 nearby1 = position + tangent1 * 0.1;\n      vec3 nearby2 = position + tangent2 * 0.1;\n      vec3 distorted1 = distortFunct(nearby1, 1.0);\n      vec3 distorted2 = distortFunct(nearby2, 1.0);\n      return normalize(cross(distorted1 - distortedPosition, distorted2 - distortedPosition));\n    }\n";
var vert$3 = "\n    #include <begin_vertex>\n    float updateTime = time / 10.0;\n    transformed = distortFunct(transformed, 1.0);\n    vec3 distortedNormal = distortNormal(position, transformed, normal);\n    vNormal = normal + distortedNormal;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed,1.);\n";
var frag$3 = "\n    #include <dithering_fragment>\n    float angle = clamp(dot(normalize(vNormal), vec3(0., -1., 0.)), 0., 1.);\n    gl_FragColor = vec4(gl_FragColor.rgb * color, gl_FragColor.a);  \n    gl_FragColor.rgb = mix(gl_FragColor.rgb, mix(color, vec3(0.), 0.5), angle);\n";

/**
 * Returns a function that, when used every frame, will mark itself
 * as ready maximum {frequency} times per second.
 *
 * @param frequency How many times per second to be marked as ready
 */
var useLimiter = function useLimiter(frequency) {
  var lastCall = react.useRef(0);
  return {
    isReady: function isReady(clock) {
      var time = clock.elapsedTime;
      var ready = time - lastCall.current > 1 / frequency;

      if (ready) {
        lastCall.current = time;
      }

      return ready;
    }
  };
};
/**
 * A 1:1 copy of useFrame, but adds a limiter
 *
 * Callback will only run {frequency} times per second
 */

var useLimitedFrame = function useLimitedFrame(frequency, callback, renderPriority) {
  var limiter = useLimiter(frequency);
  fiber.useFrame(function (state, delta) {
    if (!limiter.isReady(state.clock)) return;
    callback(state, delta);
  }, renderPriority);
};

var _excluded$p = ["idea"];
function VisualIdea(props) {
  var idea = props.idea,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$p);

  var hex = react.useMemo(function () {
    return (idea == null ? void 0 : idea.getHex()) || "#808080";
  }, [idea]);
  var seed = react.useMemo(function () {
    return Math.random();
  }, []);
  var color = react.useMemo(function () {
    return new three.Color(hex);
  }, [hex]);
  var RADIUS = 4;
  var NOISE_AMPLITUDE = 0.82;
  var NOISE_FREQ = 0.154;

  var _useSpring = three$1.useSpring({
    col: hex
  }),
      col = _useSpring.col;

  var mat = react.useMemo(function () {
    var material = new three.MeshStandardMaterial({
      metalness: 0.18,
      roughness: 0.49,
      envMapIntensity: 0.66,
      side: three.DoubleSide
    });

    material.onBeforeCompile = function (shader) {
      shader.uniforms.radius = new three.Uniform(RADIUS);
      shader.uniforms.time = new three.Uniform(0);
      shader.uniforms.color = new three.Uniform(color);
      shader.uniforms.radiusVariationAmplitude = new three.Uniform(NOISE_AMPLITUDE);
      shader.uniforms.radiusNoiseFrequency = new three.Uniform(NOISE_FREQ);
      var uniforms = "\n        uniform float radius;\n        uniform float time;\n        uniform vec3 color;\n        uniform float radiusVariationAmplitude;\n        uniform float radiusNoiseFrequency;\n      ";
      shader.vertexShader = uniforms + vertHead$3 + shader.vertexShader.replace("#include <begin_vertex>", vert$3);
      shader.fragmentShader = uniforms + shader.fragmentShader.replace("#include <dithering_fragment>", frag$3);
      material.userData.shader = shader;
    };

    return material;
  }, [RADIUS, color, NOISE_AMPLITUDE, NOISE_FREQ, frag$3, vert$3]);
  var limiter = useLimiter(50);
  fiber.useFrame(function (_ref) {
    var _mat$userData;

    var clock = _ref.clock;
    if (!(mat != null && (_mat$userData = mat.userData) != null && _mat$userData.shader) || !limiter.isReady(clock)) return;
    mat.userData.shader.uniforms.time.value = clock.elapsedTime / 6 + seed * 1000;
    mat.userData.shader.uniforms.color.value.set(col.get());
  });
  return /*#__PURE__*/React.createElement("group", _extends__default["default"]({
    name: "spacesvr-basis-idea"
  }, rest), /*#__PURE__*/React.createElement("mesh", {
    material: mat,
    scale: 0.2
  }, /*#__PURE__*/React.createElement("sphereGeometry", {
    args: [RADIUS, 48, 32]
  })));
}

var rgb_helper = "\n    vec3 rgb2hsv(vec3 c)\n    {\n        vec4 K = vec4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);\n        vec4 p = mix(vec4(c.bg, K.wz), vec4(c.gb, K.xy), step(c.b, c.g));\n        vec4 q = mix(vec4(p.xyw, c.r), vec4(c.r, p.yzx), step(p.x, c.r));\n    \n        float d = q.x - min(q.w, q.y);\n        float e = 1.0e-10;\n        return vec3(abs(q.z + (q.w - q.y) / (6.0 * d + e)), d / (q.x + e), q.x);\n    }\n    \n    vec3 hsv2rgb(vec3 c)\n    {\n        vec4 K = vec4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);\n        vec3 p = abs(fract(c.xxx + K.xyz) * 6.0 - K.www);\n        return c.z * mix(K.xxx, clamp(p - K.xxx, 0.0, 1.0), c.y);\n    }\n";
var noise4D = "\n    vec4 permute(vec4 x){return mod(((x*34.0)+1.0)*x, 289.0);}\nfloat permute(float x){return floor(mod(((x*34.0)+1.0)*x, 289.0));}\nvec4 taylorInvSqrt(vec4 r){return 1.79284291400159 - 0.85373472095314 * r;}\nfloat taylorInvSqrt(float r){return 1.79284291400159 - 0.85373472095314 * r;}\n\nvec4 grad4(float j, vec4 ip){\n  const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);\n  vec4 p,s;\n\n  p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;\n  p.w = 1.5 - dot(abs(p.xyz), ones.xyz);\n  s = vec4(lessThan(p, vec4(0.0)));\n  p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www; \n\n  return p;\n}\n\nfloat snoise(vec4 v){\n  const vec2  C = vec2( 0.138196601125010504,  // (5 - sqrt(5))/20  G4\n                        0.309016994374947451); // (sqrt(5) - 1)/4   F4\n// First corner\n  vec4 i  = floor(v + dot(v, C.yyyy) );\n  vec4 x0 = v -   i + dot(i, C.xxxx);\n\n// Other corners\n\n// Rank sorting originally contributed by Bill Licea-Kane, AMD (formerly ATI)\n  vec4 i0;\n\n  vec3 isX = step( x0.yzw, x0.xxx );\n  vec3 isYZ = step( x0.zww, x0.yyz );\n//  i0.x = dot( isX, vec3( 1.0 ) );\n  i0.x = isX.x + isX.y + isX.z;\n  i0.yzw = 1.0 - isX;\n\n//  i0.y += dot( isYZ.xy, vec2( 1.0 ) );\n  i0.y += isYZ.x + isYZ.y;\n  i0.zw += 1.0 - isYZ.xy;\n\n  i0.z += isYZ.z;\n  i0.w += 1.0 - isYZ.z;\n\n  // i0 now contains the unique values 0,1,2,3 in each channel\n  vec4 i3 = clamp( i0, 0.0, 1.0 );\n  vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );\n  vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );\n\n  //  x0 = x0 - 0.0 + 0.0 * C \n  vec4 x1 = x0 - i1 + 1.0 * C.xxxx;\n  vec4 x2 = x0 - i2 + 2.0 * C.xxxx;\n  vec4 x3 = x0 - i3 + 3.0 * C.xxxx;\n  vec4 x4 = x0 - 1.0 + 4.0 * C.xxxx;\n\n// Permutations\n  i = mod(i, 289.0); \n  float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);\n  vec4 j1 = permute( permute( permute( permute (\n             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))\n           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))\n           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))\n           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));\n// Gradients\n// ( 7*7*6 points uniformly over a cube, mapped onto a 4-octahedron.)\n// 7*7*6 = 294, which is close to the ring size 17*17 = 289.\n\n  vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;\n\n  vec4 p0 = grad4(j0,   ip);\n  vec4 p1 = grad4(j1.x, ip);\n  vec4 p2 = grad4(j1.y, ip);\n  vec4 p3 = grad4(j1.z, ip);\n  vec4 p4 = grad4(j1.w, ip);\n\n// Normalise gradients\n  vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n  p4 *= taylorInvSqrt(dot(p4,p4));\n\n// Mix contributions from the five corners\n  vec3 m0 = max(0.6 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0);\n  vec2 m1 = max(0.6 - vec2(dot(x3,x3), dot(x4,x4)            ), 0.0);\n  m0 = m0 * m0;\n  m1 = m1 * m1;\n  float final = 49.0 * ( dot(m0*m0, vec3( dot( p0, x0 ), dot( p1, x1 ), dot( p2, x2 )))\n               + dot(m1*m1, vec2( dot( p3, x3 ), dot( p4, x4 ) ) ) ) ;\n    return (final + 1.) / 2.;\n}\n";
var oklab$1 = "\nfloat fixedpow(float a, float x)\n{\n    return pow(abs(a), x) * sign(a);\n}\n\nfloat cbrt(float a)\n{\n    return fixedpow(a, 0.3333333333);\n}\n\nvec3 lsrgb2oklab(vec3 c)\n{\n    float l = 0.4122214708 * c.r + 0.5363325363 * c.g + 0.0514459929 * c.b;\n    float m = 0.2119034982 * c.r + 0.6806995451 * c.g + 0.1073969566 * c.b;\n    float s = 0.0883024619 * c.r + 0.2817188376 * c.g + 0.6299787005 * c.b;\n\n    float l_ = cbrt(l);\n    float m_ = cbrt(m);\n    float s_ = cbrt(s);\n\n    return vec3(\n        0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_,\n        1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_,\n        0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_\n    );\n}\n\nvec3 oklab2lsrgb(vec3 c)\n{\n    float l_ = c.r + 0.3963377774 * c.g + 0.2158037573 * c.b;\n    float m_ = c.r - 0.1055613458 * c.g - 0.0638541728 * c.b;\n    float s_ = c.r - 0.0894841775 * c.g - 1.2914855480 * c.b;\n\n    float l = l_ * l_ * l_;\n    float m = m_ * m_ * m_;\n    float s = s_ * s_ * s_;\n\n    return vec3(\n        4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s,\n        -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s,\n        -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s\n    );\n}\n";
var vertHead$2 = "\n    precision highp float;\n    varying vec2 vUv;\n    varying float terrain;\n    varying float terrain_perc;\n    varying vec3 vfNormal;\n\n    uniform float radius;\n    uniform float time;\n    uniform vec3 color;\n\n    " + noise4D + "\n";
var vert$2 = "\n    vec3 pos = position;\n    \n    terrain = 0.;\n    float u_time = time * 0.25;\n    \n    terrain += 1. * pow(snoise(vec4(pos.xyz * 0.15, u_time + 100.)), 1.);\n    terrain += 0.8 * pow(snoise(vec4(pos.xyz * 0.2, u_time + 200.)), 1.5);\n    terrain += 0.4 * pow(snoise(vec4(pos.xyz * 0.8, u_time + 300.)), 2.);\n    terrain += 0.2 * pow(snoise(vec4(pos.xyz * 1.6, u_time + 400.)), 8.);\n    terrain_perc = terrain / (1. + 0.8 + 0.4 + 0.2);\n    terrain_perc = terrain_perc;\n    \n    pos = pos + normal * 2. * 2. * (terrain_perc - 0.5);\n    vfNormal = normal;\n    \n    gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.);\n";
var fragHead$1 = "\n    precision highp float;\n    varying vec2 vUv;\n    varying vec3 vfNormal;\n    varying float terrain;\n    varying float terrain_perc;\n\n    uniform float time;\n    uniform vec3 axiom;\n    uniform float range;\n    uniform vec3 up_norm;\n    \n    \n    " + rgb_helper + "\n    " + oklab$1 + "\n";
var frag$2 = "\n    vec3 hsv_col = rgb2hsv(gl_FragColor.rgb);\n    \n    // todo: offset vfNormal by up_norm\n    vec3 oklab_axiom = lsrgb2oklab(axiom);\n    vec3 oklab_range_idea = lsrgb2oklab(axiom + 0.35 * range * vfNormal);\n    vec3 col = oklab2lsrgb(mix(oklab_axiom, oklab_range_idea, 1. - terrain_perc));\n    \n    gl_FragColor.rgb = col * pow(hsv_col.z, 1.3);\n    \n    \n    gl_FragColor.rgb *= 0.15 + 1.85 * pow((1. - terrain_perc), 1.5);\n";

// @ts-ignore

/**
 * an idea is the fundamental substrate of reality.
 */
var Idea = /*#__PURE__*/function () {
  // identifiers
  // mediation
  // [0, 1)
  // [0, 1]
  // [0, 1]
  function Idea(m, s, u) {
    if (m === void 0) {
      m = 0;
    }

    if (s === void 0) {
      s = 0;
    }

    if (u === void 0) {
      u = 0.5;
    }

    this.setFromCreation(m, s, u);
    return this;
  }

  var _proto = Idea.prototype;

  _proto.setFromCreation = function setFromCreation(m, s, u) {
    if (m === void 0) {
      m = 0;
    }

    if (s === void 0) {
      s = 0;
    }

    if (u === void 0) {
      u = 0.5;
    }

    this.mediation = m;
    this.specificity = s;
    this.utility = u;
    return this;
  };

  _proto.setFromHex = function setFromHex(hex) {
    var color = culori__namespace.oklch(culori__namespace.rgb(hex));

    if (!color) {
      console.warn("idea :: setFromHex - invalid hex color");
      return this;
    }

    this.mediation = color.h / 360;
    this.specificity = color.c / 0.322;
    this.utility = color.l;
    return this;
  };

  _proto.updateFromText = function updateFromText(text) {
    var len = text.length;
    this.mediation = hashStringToRange$1(text);
    this.specificity = (1 - (len == 0 ? 1 : 1 / len)) * 0.5;
    return this;
  };

  _proto.setUtility = function setUtility(utility) {
    this.utility = utility;
    return this;
  };

  _proto.getHex = function getHex() {
    var fixedColor = culori__namespace.rgb({
      mode: "oklch",
      l: this.utility,
      c: this.specificity * 0.322,
      h: this.mediation * 360
    });
    return culori__namespace.formatHex(fixedColor);
  };

  _proto.getOpposite = function getOpposite() {
    var newM = this.mediation + 0.5 > 1 ? this.mediation - 0.5 : this.mediation + 0.5;
    var newS = this.specificity;
    var newU = 0.5 - (this.utility - 0.5);
    return new Idea().setFromCreation(newM, newS, newU);
  };

  _proto.clone = function clone() {
    return new Idea(this.mediation, this.specificity, this.utility);
  };

  return Idea;
}();
var AVG_CHAR_VAL$1 = 100; // each char is roughly 100, so loop every ~50 chars

var hashStringToRange$1 = function hashStringToRange(str, loop) {
  if (loop === void 0) {
    loop = 20;
  }

  var count = 0;

  for (var i = 0; i < str.length; i++) {
    count += str.substr(i, 1).charCodeAt(0);
  }

  var scaledLoop = loop * AVG_CHAR_VAL$1;
  return count % scaledLoop / scaledLoop;
};

var _excluded$o = ["world"];
function VisualWorld(props) {
  var world = props.world,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$o);

  var RADIUS = 4;
  var SEED = react.useMemo(function () {
    return Math.random();
  }, []);
  var mat = react.useMemo(function () {
    var material = new three.MeshStandardMaterial({
      metalness: 0.18,
      roughness: 0.49,
      side: three.DoubleSide
    });

    material.onBeforeCompile = function (shader) {
      var uniforms = {
        time: new three.Uniform(0),
        axiom: new three.Uniform(new three.Color("#888888")),
        up_norm: new three.Uniform(new three.Vector3(0, 1, 0)),
        range: new three.Uniform(0)
      };
      shader.uniforms = _extends__default["default"]({}, shader.uniforms, uniforms);
      shader.vertexShader = vertHead$2 + shader.vertexShader.replace("#include <worldpos_vertex>", "#include <worldpos_vertex>\n" + vert$2);
      shader.fragmentShader = fragHead$1 + shader.fragmentShader.replace("#include <dithering_fragment>", "#include <dithering_fragment>\n" + frag$2);
      material.userData.shader = shader;
    };

    material.needsUpdate = true;
    return material;
  }, []);
  react.useEffect(function () {
    if (!mat || !mat.userData.shader || !world) return;
    var unifs = mat.userData.shader.uniforms;
    var axiom = world ? world.getAxiom() : new Idea();
    unifs.axiom.value.set(new three.Color(axiom.getHex()));
    unifs.up_norm.value = world == null ? void 0 : world.getUpNorm();
    unifs.range.value = world == null ? void 0 : world.getRange();
  }, [world, mat]);
  useLimitedFrame(50, function (_ref) {
    var clock = _ref.clock;
    if (!mat || !mat.userData.shader) return;
    mat.userData.shader.uniforms.time.value = clock.elapsedTime + SEED * 500;
  });
  return /*#__PURE__*/React.createElement("group", _extends__default["default"]({
    name: "spacesvr-basis-world"
  }, rest), /*#__PURE__*/React.createElement("mesh", {
    material: mat,
    scale: 0.2
  }, /*#__PURE__*/React.createElement("sphereGeometry", {
    args: [RADIUS, 48, 32]
  })));
}

var DOWN_AXIS = new three.Vector3(0, -1, 0);
/**
 * Will smoothly rotate its children to face the camera along the Y axis, regardless of the parent's rotation.
 */

function LookAtPlayer(props) {
  var _props$enabled = props.enabled,
      enabled = _props$enabled === void 0 ? true : _props$enabled,
      children = props.children;
  var group = react.useRef(null);
  var flatDelta = react.useMemo(function () {
    return new three.Vector2();
  }, []);
  var worldPos = react.useMemo(function () {
    return new three.Vector3();
  }, []);
  var worldQuat = react.useMemo(function () {
    return new three.Quaternion();
  }, []);
  var targetQuat = react.useMemo(function () {
    return new three.Quaternion();
  }, []);
  var parentQuat = react.useMemo(function () {
    return new three.Quaternion();
  }, []);
  var offsetRot = react.useMemo(function () {
    return new three.Euler();
  }, []);
  useLimitedFrame(50, function (_ref, delta) {
    var _group$current$parent;

    var camera = _ref.camera;
    if (!group.current) return;
    (_group$current$parent = group.current.parent) == null ? void 0 : _group$current$parent.getWorldQuaternion(parentQuat);
    offsetRot.setFromQuaternion(parentQuat, "YXZ");
    targetQuat.set(0, 0, 0, 1);

    if (enabled) {
      group.current.getWorldPosition(worldPos);
      group.current.getWorldQuaternion(worldQuat);
      flatDelta.x = camera.position.x - worldPos.x;
      flatDelta.y = camera.position.z - worldPos.z;
      var angle = flatDelta.angle() - Math.PI / 2 + offsetRot.y;
      targetQuat.setFromAxisAngle(DOWN_AXIS, angle);
    }

    group.current.quaternion.slerp(targetQuat, 0.11);
  });
  return /*#__PURE__*/React.createElement("group", {
    name: "look-at-player",
    ref: group
  }, children);
}

function Background$1(props) {
  var color = props.color;
  var scene = fiber.useThree(function (state) {
    return state.scene;
  });
  react.useLayoutEffect(function () {
    var oldBackground = scene.background;
    var col = color instanceof three.Color ? color : new three.Color(color);
    scene.background = col;
    return function () {
      scene.background = oldBackground;
    };
  }, [color]);
  return null;
}

function Fog(props) {
  var _props$color = props.color,
      color = _props$color === void 0 ? "white" : _props$color,
      _props$near = props.near,
      near = _props$near === void 0 ? 10 : _props$near,
      _props$far = props.far,
      far = _props$far === void 0 ? 80 : _props$far;
  var scene = fiber.useThree(function (state) {
    return state.scene;
  });
  react.useEffect(function () {
    var col = color instanceof three.Color ? color : new three.Color(color);
    scene.fog = new three.Fog(col, near, far);
    return function () {
      scene.fog = null;
    };
  }, [scene, color, near, far]);
  return null;
}

function InfinitePlane(props) {
  var _props$height = props.height,
      height = _props$height === void 0 ? -0.0001 : _props$height,
      _props$size = props.size,
      size = _props$size === void 0 ? [100, 100] : _props$size,
      visible = props.visible;

  var _usePlane = cannon.usePlane(function () {
    return {
      rotation: [-Math.PI / 2, 0, 0],
      position: [0, height, 0],
      args: size,
      type: "Static"
    };
  }),
      ref = _usePlane[0];

  if (!visible) return null;
  return /*#__PURE__*/React.createElement("mesh", {
    name: "spacesvr-infinite-plane",
    ref: ref
  }, /*#__PURE__*/React.createElement("planeGeometry", {
    args: size
  }), /*#__PURE__*/React.createElement("meshPhongMaterial", {
    color: "#660000"
  }));
}

var _excluded$n = ["url", "dCone", "rollOff", "volume", "setAudioAnalyser", "fftSize"];
function Audio$1(props) {
  var url = props.url,
      _props$dCone = props.dCone,
      dCone = _props$dCone === void 0 ? new three.Vector3(180, 230, 0.1) : _props$dCone,
      _props$rollOff = props.rollOff,
      rollOff = _props$rollOff === void 0 ? 1 : _props$rollOff,
      _props$volume = props.volume,
      volume = _props$volume === void 0 ? 1 : _props$volume,
      setAudioAnalyser = props.setAudioAnalyser,
      _props$fftSize = props.fftSize,
      fftSize = _props$fftSize === void 0 ? 128 : _props$fftSize,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$n);

  var _useState = react.useState(),
      speaker = _useState[0],
      setSpeaker = _useState[1];

  var camera = fiber.useThree(function (state) {
    return state.camera;
  });
  var audio = react.useMemo(function () {
    var a = document.createElement("audio");
    a.src = url;
    a.autoplay = false;
    a.preload = "auto";
    a.crossOrigin = "Anonymous";
    a.loop = true;
    return a;
  }, []);
  react.useEffect(function () {
    var setupAudio = function setupAudio() {
      if (!audio.paused && !speaker) {
        var listener = new three.AudioListener();
        camera.add(listener);
        var speak = new three.PositionalAudio(listener);
        speak.setMediaElementSource(audio);
        speak.setRefDistance(0.75);
        speak.setRolloffFactor(rollOff);
        speak.setVolume(volume);
        speak.setDirectionalCone(dCone.x, dCone.y, dCone.z);

        if (setAudioAnalyser) {
          setAudioAnalyser(new three.AudioAnalyser(speak, fftSize));
        }

        setSpeaker(speak);
      }
    };

    var playAudio = function playAudio() {
      return audio.play().then(function () {
        return setupAudio();
      });
    };

    if (audio) {
      audio.setAttribute("src", url);
      audio.play().then(function () {
        return setupAudio();
      });
      document.addEventListener("click", playAudio);
      return function () {
        document.removeEventListener("click", playAudio);
      };
    }
  }, [speaker, audio, url]);
  react.useEffect(function () {
    if (!speaker) return;
    speaker.setRolloffFactor(rollOff);
    speaker.setVolume(volume);
    speaker.setDirectionalCone(dCone.x, dCone.y, dCone.z);
  }, [dCone, rollOff, volume]);
  return /*#__PURE__*/React.createElement("group", _extends__default["default"]({
    name: "spacesvr-audio"
  }, rest), speaker && /*#__PURE__*/React.createElement("primitive", {
    object: speaker
  }));
}

function HDRI(props) {
  var src = props.src,
      disableBackground = props.disableBackground,
      disableEnvironment = props.disableEnvironment;
  return /*#__PURE__*/React.createElement(react.Suspense, {
    fallback: null
  }, /*#__PURE__*/React.createElement(drei.Environment, {
    files: src,
    background: !disableBackground && !disableEnvironment ? true : disableEnvironment && !disableBackground ? "only" : false
  }));
}

var fallbackTexture;
var SIZE = 128;
var SIZE_2 = SIZE / 2;
var RAD = 12;
var LINE_W = 1;
/**
 * Provides a default texture that is created locally
 */

function getFallbackTexture() {
  if (fallbackTexture) return fallbackTexture;
  var canvas = document.createElement("canvas");
  canvas.height = SIZE;
  canvas.width = SIZE;
  var context = canvas.getContext("2d");
  context.fillStyle = "#FFFFFF";
  context.fillRect(0, 0, SIZE, SIZE); // main circle

  context.fillStyle = "#000000";
  context.beginPath();
  context.arc(SIZE_2, SIZE_2, RAD, 0, 2 * Math.PI);
  context.fill(); // draw a white line down the middle of the circle

  context.strokeStyle = "#FFFFFF";
  context.lineWidth = Math.ceil(LINE_W);
  context.beginPath();
  context.moveTo(SIZE_2, SIZE_2 - RAD);
  context.lineTo(SIZE_2, SIZE_2 + RAD);
  context.stroke(); // draw a horizontal line across the middle of the circle

  context.beginPath();
  context.moveTo(SIZE_2 - RAD, SIZE_2);
  context.lineTo(SIZE_2 + RAD, SIZE_2);
  context.stroke();
  fallbackTexture = new three.CanvasTexture(canvas);
  return fallbackTexture;
}

var KTX_CDN = "https://cdn.jsdelivr.net/gh/pmndrs/drei-assets@master/basis/";
var textureLoader = new three.TextureLoader();
var ktx2loader; // it's inconvenient to have to produce a gl object to check for ktx2 support, especially when it comes to the cache keys
// solution is to create a skeleton object that provides the minimum requirements to check for ktx support, defined below
// https://github.com/mrdoob/three.js/blob/master/examples/jsm/loaders/KTX2Loader.js#L113-L135

var setupKtx2 = function setupKtx2() {
  if (ktx2loader) return;
  ktx2loader = new KTX2Loader.KTX2Loader();
  ktx2loader.setTranscoderPath(KTX_CDN);
  var supportsWebgl2;
  var el = document.createElement("canvas");
  var gl = el.getContext("webgl2");

  if (gl) {
    supportsWebgl2 = true;
  } else {
    gl = el.getContext("webgl");
    supportsWebgl2 = false;
  }

  if (!gl) {
    throw new Error("No WebGL support");
  }

  el.remove();
  var minimumGL = {
    extensions: new WebGLExtensions.WebGLExtensions(gl),
    capabilities: {
      isWebGL2: supportsWebgl2
    }
  }; // @ts-ignore

  ktx2loader.detectSupport(minimumGL);
};

function loadimage() {
  return function (url) {
    var IS_KTX2 = url.toLowerCase().endsWith("ktx2");
    setupKtx2();
    var loader = IS_KTX2 ? ktx2loader : textureLoader;
    return new Promise(function (res) {
      return loader.load(url, res, undefined, function (error) {
        console.error(error);
        res(getFallbackTexture());
      });
    });
  };
}
/**
 * A single hook akin to useTexture but with ktx support
 *
 * KTX_CDN is from drei so that we don't download two separate transcoders when using the useKtx2 hook elsewhere
 * https://github.com/pmndrs/drei/blob/a2daf02853f624ef6062c70ba0b218bc03e5b626/src/core/useKTX2.tsx#L7
 * @param url
 */


function useImage(url) {
  return suspendReact.suspend(loadimage(), [url]);
}

useImage.preload = function (url) {
  return suspendReact.preload(loadimage(), [url]);
};

useImage.clear = function (url) {
  return suspendReact.clear([url]);
};
/**
 * A hook to load gltf models with draco, meshopt, and ktx2 support out of the box
 *
 * For all cases, functionality is to only download decoder files if needed by the file
 * @param url
 */


function useModel(url) {
  return drei.useGLTF(url, true, true, function (loader) {
    setupKtx2();
    loader.setKTX2Loader(ktx2loader);
  });
}

useModel.preload = function (url) {
  return drei.useGLTF.preload(url, true, true, function (loader) {
    setupKtx2();
    loader.setKTX2Loader(ktx2loader);
  });
};

useModel.clear = function (url) {
  return drei.useGLTF.clear([url]);
};

/**
 *
 * Builds a frame for a mesh with a texture (image, video, etc.)
 *
 * In the code, the frame is the back panel and the border is the
 * four meshes that make up the top, left, right, and bottom sides
 * of the border.
 *
 * @param props
 * @constructor
 */
function Frame(props) {
  var width = props.width,
      height = props.height,
      _props$thickness = props.thickness,
      thickness = _props$thickness === void 0 ? 1 : _props$thickness,
      passedMaterial = props.material,
      innerFrameMaterial = props.innerFrameMaterial;
  var material = react.useMemo(function () {
    return passedMaterial || new three.MeshStandardMaterial({
      color: 0x333333,
      roughness: 0.8,
      metalness: 0.05
    });
  }, [passedMaterial]);
  var frameDepth = 0.075;
  var frameWidth = 0.06;
  var borderDepth = 0.08;
  var borderThickness = 0.05 * thickness;
  var meshOffset = 0.0005;
  var geometry = react.useMemo(function () {
    var backPanel = new three.BoxGeometry(width + frameWidth, height + frameWidth, frameDepth);
    backPanel.translate(0, 0, -frameDepth - meshOffset);
    var topFrame = new three.BoxGeometry(width + frameWidth, borderThickness, borderDepth);
    topFrame.translate(0, height / 2 + frameWidth / 2 - borderThickness / 2, 0);
    var bottomFrame = new three.BoxGeometry(width + frameWidth, borderThickness, borderDepth);
    bottomFrame.translate(0, -height / 2 - frameWidth / 2 + borderThickness / 2, 0);
    var leftFrame = new three.BoxGeometry(borderThickness, height + frameWidth, borderDepth);
    leftFrame.translate(-width / 2 - frameWidth / 2 + borderThickness / 2, 0, 0);
    var rightFrame = new three.BoxGeometry(borderThickness, height + frameWidth, borderDepth);
    rightFrame.translate(width / 2 + frameWidth / 2 - borderThickness / 2, 0, 0);
    var geos = [backPanel, topFrame, bottomFrame, leftFrame, rightFrame];
    var geo = BufferGeometryUtils.mergeBufferGeometries(geos);
    backPanel.dispose();
    topFrame.dispose();
    bottomFrame.dispose();
    leftFrame.dispose();
    rightFrame.dispose();
    return geo;
  }, [innerFrameMaterial, borderThickness, width, height]);
  var backFrameGeometry = react.useMemo(function () {
    if (!innerFrameMaterial) return undefined;
    var backPanel = new three.BoxGeometry(width + frameWidth, height + frameWidth, frameDepth);
    backPanel.translate(0, 0, -frameDepth - meshOffset);
    return backPanel;
  }, [innerFrameMaterial, width, height]);
  return /*#__PURE__*/React.createElement("group", {
    name: "spacesvr-frame"
  }, /*#__PURE__*/React.createElement("mesh", {
    geometry: geometry,
    material: material
  }), backFrameGeometry && innerFrameMaterial && /*#__PURE__*/React.createElement("mesh", {
    geometry: backFrameGeometry,
    material: innerFrameMaterial
  }));
}

var _excluded$m = ["src", "size", "framed", "frameMaterial", "frameWidth", "innerFrameMaterial"];

function UnsuspensedImage(props) {
  var src = props.src,
      _props$size = props.size,
      size = _props$size === void 0 ? 1 : _props$size,
      framed = props.framed,
      frameMaterial = props.frameMaterial,
      _props$frameWidth = props.frameWidth,
      frameWidth = _props$frameWidth === void 0 ? 1 : _props$frameWidth,
      innerFrameMaterial = props.innerFrameMaterial,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$m);

  var tex = useImage(src);
  var _tex$image = tex.image,
      width = _tex$image.width,
      height = _tex$image.height;
  var max = Math.max(width, height);
  var WIDTH = width / max * size;
  var HEIGHT = height / max * size;
  var IS_COMPRESSED = tex.isCompressedTexture;
  return /*#__PURE__*/React.createElement("group", _extends__default["default"]({
    name: "spacesvr-image"
  }, rest), /*#__PURE__*/React.createElement("mesh", {
    rotation: IS_COMPRESSED ? [0, Math.PI, Math.PI] : [0, 0, 0]
  }, /*#__PURE__*/React.createElement("planeGeometry", {
    args: [WIDTH, HEIGHT]
  }), /*#__PURE__*/React.createElement("meshBasicMaterial", {
    map: tex,
    side: three.DoubleSide,
    transparent: true
  })), framed && /*#__PURE__*/React.createElement(Frame, {
    width: WIDTH,
    height: HEIGHT,
    thickness: frameWidth,
    material: frameMaterial,
    innerFrameMaterial: innerFrameMaterial
  }));
}

function Image$1(props) {
  return /*#__PURE__*/React.createElement(react.Suspense, {
    fallback: null
  }, /*#__PURE__*/React.createElement(UnsuspensedImage, props));
}

/**
 * a world is a set of ideas
 */
var World = /*#__PURE__*/function () {
  function World() {
    return this;
  }

  var _proto = World.prototype;

  _proto.getIdea = function getIdea() {
    return new Idea().setFromCreation(hashStringToRange(JSON.stringify(this.tree || this.id), 3), 0.3 + 0.7 * hashStringToRange(this.id), 0.8);
  };

  _proto.getAxiom = function getAxiom() {
    var str = JSON.stringify(this.tree || this.id);
    var strHash = new Array(10).fill(1).map(function () {
      return str;
    }).join("");
    return new Idea().setFromCreation(hashStringToRange(strHash, 15), 0.3 + 0.7 * hashStringToRange(strHash, 10), 0.8);
  };

  _proto.getUpNorm = function getUpNorm() {
    // 4 digit long hex values
    var x = parseInt(this.id.split("-")[1], 16) / Math.pow(16, 4);
    var y = parseInt(this.id.split("-")[2], 16) / Math.pow(16, 4);
    var z = parseInt(this.id.split("-")[3], 16) / Math.pow(16, 4);
    return new three.Vector3(x, y, z).normalize();
  };

  _proto.getRange = function getRange() {
    var r = parseInt(this.id.split("-")[0], 16) / Math.pow(16, 8);
    return 0.3 + 0.7 * r;
  };

  _proto.getHex = function getHex() {
    return this.getIdea().getHex();
  };

  return World;
}();
var AVG_CHAR_VAL = 100; // each char is roughly 100, so loop every ~50 chars

var hashStringToRange = function hashStringToRange(str, loop) {
  if (loop === void 0) {
    loop = 8;
  }

  var count = 0;

  for (var i = 0; i < str.length; i++) {
    count += str.substr(i, 1).charCodeAt(0);
  }

  var scaledLoop = loop * AVG_CHAR_VAL;
  return count % scaledLoop / scaledLoop;
};

/**
 * A site is a delivery method of a world.
 */
var Site = function Site() {
  return this;
};

/**
 * Gets the number of triangles in a geometry
 */

var getGeometryTriCount$1 = function getGeometryTriCount(geometry) {
  return geometry.index ? geometry.index.count / 3 : geometry.attributes.position.count / 3;
};
/**
 * For a given mesh, set up bvh raycasting for it if it meets the threshold for
 * amount of triangles to use
 *
 * @param mesh
 * @param threshold
 */


var enableBVHRaycast = function enableBVHRaycast(mesh, threshold) {
  if (threshold === void 0) {
    threshold = 0;
  }

  if (!mesh.geometry || !mesh.geometry.isBufferGeometry) {
    return;
  }

  var geometry = mesh.geometry;
  var triCount = getGeometryTriCount$1(geometry);
  if (geometry.boundsTree || triCount < threshold) return;
  mesh.raycast = threeMeshBvh.acceleratedRaycast;
  geometry.computeBoundsTree = threeMeshBvh.computeBoundsTree;
  geometry.disposeBoundsTree = threeMeshBvh.disposeBoundsTree;
  geometry.computeBoundsTree({
    verbose: true
  });
};

var universe_cache = new Map();

function getResource(key, constructor, opts) {
  var resource = universe_cache.get(key);

  if (!resource) {
    if (opts != null && opts.verbose) console.log("[CACHE] " + key + " not found, creating new");
    resource = constructor();
    universe_cache.set(key, resource);
  } else {
    if (opts != null && opts.verbose) console.log("[CACHE] " + key + " found, returning");
  }

  return resource;
}

var cache = {
  getResource: getResource,
  useResource: function useResource(key, constructor, opts) {
    var _useState = react.useState(getResource(key, constructor, opts)),
        resource = _useState[0],
        setResource = _useState[1];

    react.useEffect(function () {
      setResource(getResource(key, constructor, opts));
    }, [key]);
    return resource;
  },

  get mat_standard_white() {
    return getResource("mat_standard_white", function () {
      return new three.MeshStandardMaterial({
        color: "white"
      });
    });
  },

  get mat_standard_cream_double() {
    return getResource("mat_standard_cream_double", function () {
      return new three.MeshStandardMaterial({
        color: "#aaa",
        side: three.DoubleSide
      });
    });
  },

  get mat_standard_black() {
    return getResource("mat_standard_black", function () {
      return new three.MeshStandardMaterial({
        color: "black"
      });
    });
  },

  get mat_standard_rose() {
    return getResource("mat_standard_rose", function () {
      return new three.MeshStandardMaterial({
        color: "#ff007f"
      });
    });
  },

  get mat_standard_red() {
    return getResource("mat_standard_red", function () {
      return new three.MeshStandardMaterial({
        color: "#ff0000"
      });
    });
  },

  get mat_basic_white() {
    return getResource("mat_basic_white", function () {
      return new three.MeshBasicMaterial({
        color: "white"
      });
    });
  },

  get mat_basic_black() {
    return getResource("mat_basic_black", function () {
      return new three.MeshBasicMaterial({
        color: "black"
      });
    });
  },

  get mat_basic_gray() {
    return getResource("mat_basic_gray", function () {
      return new three.MeshBasicMaterial({
        color: "#828282"
      });
    });
  },

  get mat_basic_red() {
    return getResource("mat_basic_red", function () {
      return new three.MeshBasicMaterial({
        color: "red"
      });
    });
  },

  get mat_basic_black_wireframe() {
    return getResource("mat_basic_black_wireframe", function () {
      return new three.MeshBasicMaterial({
        color: "black",
        wireframe: true
      });
    });
  }

};

var useTrimeshCollision$1 = function useTrimeshCollision(geometry) {
  var indices = geometry.index.array;
  var isInterleaved = // @ts-ignore
  geometry.attributes.position.isInterleavedBufferAttribute;
  var vertices = [];

  if (isInterleaved) {
    var attr = geometry.attributes.position;
    var data = attr.data;

    for (var i = attr.offset; i < data.array.length; i += data.stride) {
      for (var x = 0; x < attr.itemSize; x++) {
        vertices.push(data.array[i + x]);
      }
    }
  } else {
    vertices = geometry.attributes.position.array;
  }

  var _useTrimesh = cannon.useTrimesh(function () {
    return {
      type: "Static",
      args: [vertices, indices]
    };
  }),
      hitbox = _useTrimesh[0];

  return hitbox;
};

// check whether the user is currently typing
var isTyping = function isTyping() {
  var _document, _document$activeEleme, _document2;

  return ((_document = document) == null ? void 0 : (_document$activeEleme = _document.activeElement) == null ? void 0 : _document$activeEleme.tagName) === "INPUT" && ((_document2 = document) == null ? void 0 : _document2.hasFocus());
};

var useDrag = function useDrag(callback, domElem, deps) {
  if (deps === void 0) {
    deps = [];
  }

  var _useThree = fiber.useThree(),
      clock = _useThree.clock,
      size = _useThree.size,
      viewport = _useThree.viewport;

  var aspect = size.width / viewport.width;

  var _useState = react.useState(new three.Vector2()),
      downPoint = _useState[0];

  var _useState2 = react.useState(new three.Vector2()),
      dragPoint = _useState2[0];

  var _useState3 = react.useState(new three.Vector2()),
      velocity = _useState3[0];

  var _useState4 = react.useState(new three.Vector2()),
      delta = _useState4[0];

  var lastTouchRead = react.useRef(0);
  var onStart = react.useCallback(function (p) {
    if (callback.onStart) callback.onStart(p);
  }, [].concat(deps));
  var onMove = react.useCallback(function (p) {
    if (callback.onMove) callback.onMove(p);
  }, [].concat(deps));
  var onEnd = react.useCallback(function (p) {
    if (callback.onEnd) callback.onEnd(p);
  }, [].concat(deps));
  var startDrag = react.useCallback(function (e) {
    e.preventDefault();
    var touch = e.changedTouches[0];
    downPoint.set(touch.clientX, touch.clientY);
    onStart({
      e: e,
      touch: touch,
      downPoint: downPoint,
      dragPoint: downPoint,
      velocity: velocity
    });
  }, [onStart, downPoint, velocity]);
  var moveDrag = react.useCallback(function (e) {
    var touch = e.touches[0];
    dragPoint.set(touch.clientX, touch.clientY);
    var delta = dragPoint.sub(downPoint);
    var time = clock.elapsedTime;
    var elapsed = time - lastTouchRead.current;
    velocity.set(delta.x / elapsed / aspect, delta.y / elapsed / aspect);
    lastTouchRead.current = time;
    onMove({
      e: e,
      touch: touch,
      downPoint: downPoint,
      dragPoint: dragPoint,
      velocity: velocity,
      delta: delta
    });
  }, [aspect, onMove, clock, downPoint, dragPoint, velocity]);
  var endDrag = react.useCallback(function (e) {
    var touch = e.changedTouches[0];
    dragPoint.set(touch.clientX, touch.clientY);
    delta.copy(dragPoint).sub(downPoint);
    onEnd({
      e: e,
      touch: touch,
      downPoint: downPoint,
      dragPoint: dragPoint,
      velocity: velocity,
      delta: delta
    });
  }, [onEnd, delta, downPoint, dragPoint, velocity]);
  react.useEffect(function () {
    var elem = domElem || document;
    elem.addEventListener("touchstart", startDrag);
    elem.addEventListener("touchmove", moveDrag);
    elem.addEventListener("touchend", endDrag);
    return function () {
      elem.removeEventListener("touchstart", startDrag);
      elem.removeEventListener("touchmove", moveDrag);
      elem.removeEventListener("touchend", endDrag);
    };
  }, [domElem, endDrag, moveDrag, startDrag]);
  return {
    startDrag: startDrag,
    moveDrag: moveDrag,
    endDrag: endDrag
  };
};

var PADDING_X = 0.125;
var PADDING_X_2 = PADDING_X * 2;
var PADDING_Y = 0.125;
var PADDING_Y_2 = PADDING_Y * 2;
var RAD_PER_DEG_2 = Math.PI / 180 / 2;
var getHudPos = function getHudPos(pos, camera, distance, target) {
  var vFOV = camera.fov * RAD_PER_DEG_2;
  var height = 2 * Math.tan(vFOV) * Math.abs(distance);
  var width = height * camera.aspect;
  var px = pos.x || pos[0];
  var py = pos.y || pos[1];
  var x = px * (width - PADDING_X_2) * 0.5;
  var y = py * (height - PADDING_Y_2) * 0.5;

  if (target) {
    target.x = x;
    target.y = y;
    return target;
  }

  return new three.Vector2(x, y);
};
var getHudDims = function getHudDims(camera, distance) {
  var vFOV = camera.fov * RAD_PER_DEG_2;
  var height = 2 * Math.tan(vFOV) * Math.abs(distance);
  var width = height * camera.aspect;
  return {
    width: width,
    height: height
  };
};
var useHudDims = function useHudDims(distance) {
  if (distance === void 0) {
    distance = 1;
  }

  var camera = fiber.useThree(function (state) {
    return state.camera;
  });
  return react.useMemo(function () {
    return getHudDims(camera, distance); // make sure aspect is there
  }, [camera, distance, camera.aspect]);
};

var _templateObject$7;
var Container$3 = styled__default["default"].div(_templateObject$7 || (_templateObject$7 = _taggedTemplateLiteralLoose__default["default"](["\n  position: absolute;\n  width: 100%;\n  height: 100%;\n  overflow: hidden;\n  z-index: 0;\n\n  canvas {\n    position: absolute;\n    top: 0;\n    right: 0;\n    bottom: 0;\n    left: 0;\n    outline: 0;\n  }\n"])));

var _templateObject$6;
var globalStyles = react$1.css(_templateObject$6 || (_templateObject$6 = _taggedTemplateLiteralLoose__default["default"](["\n  @font-face {\n    font-family: \"Quicksand\";\n    src: url(\"https://d27rt3a60hh1lx.cloudfront.net/fonts/Quicksand_Bold.otf\");\n  }\n\n  html {\n    position: fixed;\n    height: 100%;\n    overflow: hidden;\n  }\n\n  body {\n    margin: 0;\n    width: 100vw;\n    height: 100vh;\n    user-select: none;\n    overflow: hidden;\n    touch-action: none;\n    -webkit-overflow-scrolling: touch;\n  }\n"])));
function GlobalStyles() {
  react.useEffect(function () {
    var view = document.createElement("meta");
    view.name = "viewport";
    view.content = "initial-scale=1, viewport-fit=cover";
    document.head.append(view);
    return function () {
      document.head.removeChild(view);
    };
  }, []);
  return /*#__PURE__*/React.createElement(react$1.Global, {
    styles: globalStyles
  });
}

/**
 * A modified version of the controlled progress hooks that adds
 * - a minimum wait time, in case it takes a second to register an asset
 * - a delay after it reaches 100 in case it goes back down
 * - a timeout when it reaches > 50%, marked as stuck
 */

var useControlledProgress = function useControlledProgress() {
  var MIN_TIME = 2000; // minimum time to wait before moving to 100

  var AFTER_TIME = 300; // extra time to prevent bouncing at reaching 100

  var _useProgress = drei.useProgress(),
      progress = _useProgress.progress,
      total = _useProgress.total;

  var startTime = react.useRef(new Date());
  var controlledProgress = react.useRef(0);
  var finished = react.useRef(false);

  var _useState = react.useState(0),
      setForceRender = _useState[1];

  react.useEffect(function () {
    var newTime = new Date();
    var timeElapsed = newTime.getTime() - startTime.current.getTime();
    var diff = Math.min(progress - controlledProgress.current, timeElapsed < MIN_TIME ? 99 : 100);

    if (diff > 0) {
      if (progress === 100) {
        finished.current = true; // if progress 100, check in AFTER_TIME ms to make sure it hasn't
        // bounced back down

        setTimeout(function () {
          if (finished.current) {
            controlledProgress.current = progress; // set state to force re render

            setForceRender(Math.random());
          }
        }, AFTER_TIME);
      } else {
        finished.current = false;
        controlledProgress.current = progress;
      }
    }

    if (progress !== 100) {
      finished.current = false;
    }
  }, [progress]); // wait TIMEOUT (ms) to check if any objects are waiting to be loaded

  var _useState2 = react.useState(0),
      counter = _useState2[0],
      setCounter = _useState2[1];

  var _useState3 = react.useState(false),
      skip = _useState3[0],
      setSkip = _useState3[1];

  react.useEffect(function () {
    if (total > 0) {
      return;
    } else if (counter > 0) {
      setSkip(true);
    } else {
      setTimeout(function () {
        return setCounter(counter + 1);
      }, MIN_TIME);
    }
  }, [counter]);
  return skip ? 100 : Math.floor(controlledProgress.current);
};

var _templateObject$5, _templateObject2$3, _templateObject3$3, _templateObject4$3, _templateObject5$3;

var _float = react$1.keyframes(_templateObject$5 || (_templateObject$5 = _taggedTemplateLiteralLoose__default["default"](["\n  0% {\n    transform: translatey(0px);\n  }\n\n  50% {\n    transform: translatey(-15px);\n  }\n\n  100% {\n    transform: translatey(0px);\n  }\n"])));

var grow = react$1.keyframes(_templateObject2$3 || (_templateObject2$3 = _taggedTemplateLiteralLoose__default["default"](["\n  0% {\n    opacity: 0.8;\n  }\n\n  50% {\n    opacity: 0.2;\n  }\n\n  100% {\n    opacity: 0.8;\n  }\n"])));
var Container$2 = styled__default["default"].div(_templateObject3$3 || (_templateObject3$3 = _taggedTemplateLiteralLoose__default["default"](["\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 11;\n  background: white;\n  transition: opacity 0.75s ease-in;\n  transition-delay: 0.5s;\n  opacity: ", ";\n  pointer-events: ", ";\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  flex-direction: column;\n  font-family: \"Quicksand\", sans-serif;\n  font-size: 27px;\n  @media screen and (max-width: 500px) {\n    font-size: 24px;\n  }\n"])), function (props) {
  return props.finished ? "0" : "1";
}, function (props) {
  return props.finished ? "none" : "all";
});
var Text$1 = styled__default["default"].div(_templateObject4$3 || (_templateObject4$3 = _taggedTemplateLiteralLoose__default["default"](["\n  animation: ", " 7s ease-in-out infinite;\n"])), _float);
var Wrapper$1 = styled__default["default"].div(_templateObject5$3 || (_templateObject5$3 = _taggedTemplateLiteralLoose__default["default"](["\n  position: relative;\n\n  &:before {\n    pointer-events: none;\n    position: absolute;\n    content: \"\";\n    top: 100%;\n    left: 5%;\n    height: 10px;\n    width: 90%;\n    background: -webkit-radial-gradient(\n      center,\n      ellipse,\n      rgba(0, 0, 0, 0.35) 0%,\n      transparent 80%\n    );\n    background: radial-gradient(\n      ellipse at center,\n      rgba(0, 0, 0, 0.35) 0%,\n      transparent 80%\n    );\n    -webkit-transition-duration: 0.3s;\n    transition-duration: 0.3s;\n    -webkit-transition-property: transform, opacity;\n    transition-property: transform, opacity;\n    animation: ", " 7s ease-in-out infinite;\n  }\n"])), grow);
function LoadingScreen() {
  var progress = useControlledProgress();
  return /*#__PURE__*/React.createElement(Container$2, {
    finished: progress === 100
  }, /*#__PURE__*/React.createElement(Wrapper$1, null, /*#__PURE__*/React.createElement(Text$1, null, Math.round(progress), "%")));
}

var _templateObject$4, _templateObject2$2, _templateObject3$2, _templateObject4$2, _templateObject5$2, _templateObject6, _templateObject7, _templateObject8, _templateObject9;
var Container$1 = styled__default["default"].div(_templateObject$4 || (_templateObject$4 = _taggedTemplateLiteralLoose__default["default"](["\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: 10;\n  transition: opacity 0.25s ease;\n  background: rgba(0, 0, 0, ", ");\n  display: flex;\n  justify-content: center;\n  flex-direction: column;\n  align-items: center;\n  opacity: ", ";\n  pointer-events: ", ";\n  font-family: \"Quicksand\", sans-serif;\n  font-size: 27px;\n  @media screen and (max-width: 500px) {\n    font-size: 24px;\n  }\n"])), function (props) {
  return props.dev ? 0 : 0.25;
}, function (props) {
  return props.paused ? 1 : 0;
}, function (props) {
  return props.paused ? "all" : "none";
});
var ClickContainer = styled__default["default"].div(_templateObject2$2 || (_templateObject2$2 = _taggedTemplateLiteralLoose__default["default"](["\n  width: 100%;\n  height: 100%;\n  position: absolute;\n  top: 0;\n  left: 0;\n  z-index: -1;\n"])));
var Window = styled__default["default"].div(_templateObject3$2 || (_templateObject3$2 = _taggedTemplateLiteralLoose__default["default"](["\n  width: 90%;\n  max-width: 400px;\n  padding: 20px 20px;\n  color: black;\n  display: flex;\n  flex-direction: column;\n  align-items: center;\n  justify-content: center;\n  position: relative;\n  border-radius: 10px;\n  background-color: white;\n  background-position: center;\n  background-size: cover;\n  box-sizing: border-box;\n\n  box-shadow: 12px 12px 16px 0 rgba(0, 0, 0, 0.25),\n    -8px -8px 12px 0 rgba(255, 255, 255, 0.3);\n"])));
var Continue = styled__default["default"].div(_templateObject4$2 || (_templateObject4$2 = _taggedTemplateLiteralLoose__default["default"](["\n  width: 90%;\n  max-width: 400px;\n  height: auto;\n  cursor: pointer;\n  text-align: center;\n  font-size: 1.3em;\n  font-family: \"Quicksand\", sans-serif;\n  transition: opacity 0.15s linear;\n  margin-top: 20px;\n  background: ", ";\n  color: white;\n  //border: 2px solid black;\n  line-height: 1em;\n  padding: 12px 0;\n  border-radius: 10px;\n  :hover {\n    opacity: 0.5;\n  }\n\n  box-shadow: 12px 12px 16px 0 rgba(0, 0, 0, 0.25),\n    -8px -8px 12px 0 rgba(255, 255, 255, 0.3);\n"])), function (props) {
  return props.color;
});
var Instructions = styled__default["default"].div(_templateObject5$2 || (_templateObject5$2 = _taggedTemplateLiteralLoose__default["default"](["\n  width: 100%;\n  height: auto;\n  margin: 30px 0;\n  font-size: 0.7em;\n  text-align: center;\n  display: flex;\n  flex-direction: column;\n  justify-content: center;\n\n  & > p {\n    margin: 0.2em;\n  }\n"])));
var MenuButton = styled__default["default"].div(_templateObject6 || (_templateObject6 = _taggedTemplateLiteralLoose__default["default"](["\n  border: 1px solid black;\n  border-radius: 10px;\n  background: rgba(255, 255, 255, 0);\n  padding: 5px 10px;\n  margin: 8px 4px;\n  transition: background 0.15s linear;\n  font-size: 0.5em;\n  cursor: pointer;\n\n  &:hover {\n    background: rgba(0, 0, 0, 0.15);\n  }\n"])));
var MenuLink = styled__default["default"].a(_templateObject7 || (_templateObject7 = _taggedTemplateLiteralLoose__default["default"](["\n  border: 1px solid black;\n  border-radius: 10px;\n  background: rgba(255, 255, 255, 0);\n  padding: 5px 10px;\n  margin: 8px 4px;\n  transition: background 0.15s linear;\n  font-size: 0.5em;\n  cursor: pointer;\n  text-decoration: none;\n  color: black !important;\n\n  &:hover {\n    background: rgba(0, 0, 0, 0.15);\n  }\n"])));
var Title = styled__default["default"].h1(_templateObject8 || (_templateObject8 = _taggedTemplateLiteralLoose__default["default"](["\n  margin: 0;\n"])));
var Actions = styled__default["default"].div(_templateObject9 || (_templateObject9 = _taggedTemplateLiteralLoose__default["default"](["\n  width: 100%;\n  display: flex;\n  justify-content: space-evenly;\n  flex-wrap: wrap;\n"])));

/**
 * Check validity of browser to run 3d experiences,
 * Automatically blacklists Facebook & Instagram in-app
 * browsers
 */
var useKeyboardLayout = function useKeyboardLayout() {
  var _useState = react.useState("W/A/S/D"),
      layout = _useState[0],
      setLayout = _useState[1];

  react.useEffect(function () {
    var IS_IN_IFRAME = window.self !== window.top;
    if (!navigator.keyboard || IS_IN_IFRAME) return;
    var keyboard = navigator.keyboard;
    keyboard.getLayoutMap().then(function (keyboardLayoutMap) {
      var upKey = keyboardLayoutMap.get("KeyW");
      if (upKey === "z") setLayout("Z/Q/S/D");
    });
  }, []);
  return layout;
};

var useDevice = function useDevice() {
  var _useState = react.useState(reactDeviceDetect.isMobile ? "mobile" : "desktop"),
      device = _useState[0],
      setDevice = _useState[1];

  return {
    device: {
      mobile: device === "mobile",
      desktop: device === "desktop",
      xr: device === "xr"
    },
    setDevice: setDevice
  };
};

var EnvironmentContext = /*#__PURE__*/react.createContext({});
var useEnvironment = function useEnvironment() {
  return react.useContext(EnvironmentContext);
};
var useEnvironmentState = function useEnvironmentState(name) {
  var _useState = react.useState([]),
      menuItems = _useState[0],
      setMenuItems = _useState[1];

  var container = react.useRef(null);

  var _useState2 = react.useState(true),
      paused = _useState2[0],
      setPausedValue = _useState2[1];

  var events = react.useMemo(function () {
    return [];
  }, []);

  var _useState3 = react.useState(false),
      played = _useState3[0],
      setPlayed = _useState3[1];

  var setPaused = react.useCallback(function (p) {
    setPausedValue(p); // hook into paused click event to make sure global context is running.
    // https://github.com/mrdoob/three.js/blob/342946c8392639028da439b6dc0597e58209c696/src/audio/AudioContext.js#L9
    // local state to only do once so we don't interfere with MuteOnHide

    if (!played) {
      var context = three.AudioContext.getContext();
      if (context.state !== "running") context.resume();
      setPlayed(true);
    } // call all pause events


    events.map(function (ev) {
      return ev.apply(null, [p]);
    });
  }, [events, played]);
  var device = useDevice();
  return _extends__default["default"]({}, device, {
    name: name,
    paused: paused,
    setPaused: setPaused,
    events: events,
    containerRef: container,
    menuItems: menuItems,
    setMenuItems: setMenuItems
  });
};

function PauseMenu(props) {
  var _props$title = props.title,
      title = _props$title === void 0 ? "spacesvr" : _props$title,
      _props$pauseMenuItems = props.pauseMenuItems,
      pauseMenuItems = _props$pauseMenuItems === void 0 ? [] : _props$pauseMenuItems,
      _props$dev = props.dev,
      dev = _props$dev === void 0 ? false : _props$dev;

  var _useEnvironment = useEnvironment(),
      paused = _useEnvironment.paused,
      setPaused = _useEnvironment.setPaused,
      menuItems = _useEnvironment.menuItems,
      device = _useEnvironment.device;

  var layout = useKeyboardLayout();
  var closeOverlay = react.useCallback(function () {
    var item = menuItems.find(function (item) {
      return item.text === "Enter VR";
    });
    if (item && item.action) item.action();else setPaused(false);
  }, [menuItems, setPaused]);
  var hex = react.useMemo(function () {
    return new Idea().setFromCreation(Math.random(), 0.8, 0.95).getHex();
  }, []);
  var PAUSE_ITEMS = [].concat(pauseMenuItems, [{
    text: "v2.12.2",
    link: "https://www.npmjs.com/package/spacesvr"
  }], menuItems);
  return /*#__PURE__*/React.createElement(Container$1, {
    paused: paused,
    dev: dev
  }, /*#__PURE__*/React.createElement(ClickContainer, {
    onClick: closeOverlay
  }), !dev && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Window, null, /*#__PURE__*/React.createElement(Title, null, title), /*#__PURE__*/React.createElement(Instructions, null, /*#__PURE__*/React.createElement("p", null, "Move \u2013 ", device.mobile ? "Joystick" : layout), /*#__PURE__*/React.createElement("p", null, "Look \u2013 ", device.mobile ? "Drag" : "Mouse"), /*#__PURE__*/React.createElement("p", null, "Pause \u2013 ", device.mobile ? "Menu Button" : "Esc"), /*#__PURE__*/React.createElement("p", null, "Cycle Tool \u2013 ", device.mobile ? "Edge Swipe" : "Tab")), /*#__PURE__*/React.createElement(Actions, null, PAUSE_ITEMS.map(function (item) {
    return item.link ? /*#__PURE__*/React.createElement(MenuLink, {
      key: item.text,
      href: item.link,
      target: "_blank"
    }, item.text) : /*#__PURE__*/React.createElement(MenuButton, {
      key: item.text,
      onClick: item.action
    }, item.text);
  }))), /*#__PURE__*/React.createElement(Continue, {
    onClick: closeOverlay,
    color: hex
  }, "continue")));
}

var _templateObject$3;
var Element = styled__default["default"].div(_templateObject$3 || (_templateObject$3 = _taggedTemplateLiteralLoose__default["default"](["\n  position: fixed;\n  top: 50%;\n  left: 50%;\n  z-index: 1;\n  mix-blend-mode: difference;\n\n  &::before {\n    content: \"\";\n    position: absolute;\n    height: 16px;\n    width: 1.5px;\n    transform: translate(-50%, -50%);\n    border-radius: 6px;\n    background: #ffffff;\n  }\n\n  &::after {\n    content: \"\";\n    position: absolute;\n    width: 16px;\n    height: 1.5px;\n    transform: translate(-50%, -50%);\n    border-radius: 6px;\n    background: #ffffff;\n  }\n"])));

var Crosshair = function Crosshair() {
  if (reactDeviceDetect.isMobile) {
    return null;
  }

  return /*#__PURE__*/React.createElement(Element, null);
};

// thank you a-frame https://github.com/aframevr/aframe/blob/042a3d6b7087a632c5165227b14bc37573375cde/src/utils/device.js
function isOculusBrowser() {
  return /(OculusBrowser)/i.test(window.navigator.userAgent);
}

function isFirefoxReality() {
  return /(Mobile VR)/i.test(window.navigator.userAgent);
}

function isStandaloneVR() {
  return isOculusBrowser() || isFirefoxReality();
}

/**
 * Component to register menu items to the environment.
 * Needs to be a component because it needs access to the three context to run
 * but ideas outside of the three context need to access it, so it uses
 * the environment as a mediator
 */

function RegisterMenuItems() {
  var _useEnvironment = useEnvironment(),
      setMenuItems = _useEnvironment.setMenuItems;

  var vrMenu = useVRMenuItem();
  var fsMenu = useFsMenuItem();
  var oqMenu = useOculusMenuItem();
  react.useEffect(function () {
    var arr = [];
    if (vrMenu) arr.push(vrMenu);
    if (fsMenu) arr.push(fsMenu);
    if (oqMenu) arr.push(oqMenu);
    setMenuItems(arr);
  }, [vrMenu == null ? void 0 : vrMenu.text, fsMenu == null ? void 0 : fsMenu.text, oqMenu == null ? void 0 : oqMenu.text, setMenuItems]);
  return null;
}
var useVRMenuItem = function useVRMenuItem() {
  var gl = fiber.useThree(function (state) {
    return state.gl;
  });

  var _useEnvironment2 = useEnvironment(),
      setDevice = _useEnvironment2.setDevice,
      setPaused = _useEnvironment2.setPaused;

  var session = react.useRef();

  var _useState = react.useState("Enter VR"),
      text = _useState[0],
      setText = _useState[1];

  var action = react.useCallback(function () {
    function onSessionStarted(_x) {
      return _onSessionStarted.apply(this, arguments);
    }

    function _onSessionStarted() {
      _onSessionStarted = _asyncToGenerator__default["default"]( /*#__PURE__*/regeneratorRuntime.mark(function _callee(sesh) {
        return regeneratorRuntime.wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                sesh.addEventListener("end", onSessionEnded);
                _context.next = 3;
                return gl.xr.setSession(sesh);

              case 3:
                setText("Exit VR");
                setDevice("xr");
                setPaused(false);
                session.current = sesh;

              case 7:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      }));
      return _onSessionStarted.apply(this, arguments);
    }

    function onSessionEnded() {
      var _session$current;

      (_session$current = session.current) == null ? void 0 : _session$current.removeEventListener("end", onSessionEnded);
      setDevice(reactDeviceDetect.isMobile ? "mobile" : "desktop");
      setText("Enter VR");
      setPaused(true);
      session.current = undefined;
    }

    if (session.current === undefined) {
      var sessionInit = {
        optionalFeatures: ["local-floor", "bounded-floor", "hand-tracking", "layers"]
      }; // @ts-ignore

      var xr = navigator.xr;
      xr.requestSession("immersive-vr", sessionInit).then(onSessionStarted);
    } else {
      var _session$current2;

      (_session$current2 = session.current) == null ? void 0 : _session$current2.end();
    }
  }, [gl.xr, setDevice, setPaused]);

  if (!isStandaloneVR()) {
    return undefined;
  }

  return {
    text: text,
    action: action
  };
};
var useOculusMenuItem = function useOculusMenuItem() {
  if (isStandaloneVR()) return;
  return {
    text: "Open in Meta Quest",
    link: "https://www.oculus.com/open_url/?url=" + window.location.href
  };
};
var useFsMenuItem = function useFsMenuItem() {
  var domElement = document.body;
  var rfs = domElement.requestFullscreen || // @ts-ignore
  domElement.webkitRequestFullScreen || // @ts-ignore
  domElement.mozRequestFullScreen || // @ts-ignore
  domElement.msRequestFullscreen || undefined;

  var _useState2 = react.useState(false),
      isFullscreen = _useState2[0],
      setIsFullscreen = _useState2[1];

  var _useState3 = react.useState(rfs !== undefined),
      fullscreenAvailable = _useState3[0];

  react.useEffect(function () {
    var handleFullscreenChange = function handleFullscreenChange() {
      return setIsFullscreen(document.fullscreenElement !== null);
    };

    document.addEventListener("fullscreenchange", handleFullscreenChange);
    return function () {
      document.removeEventListener("fullscreenchange", handleFullscreenChange);
    };
  }, []);
  var action = react.useCallback(function () {
    if (!rfs) return;

    if (!document.fullscreenElement) {
      rfs.apply(domElement, [{
        navigationUI: "hide"
      }]);
    } else {
      if (document.exitFullscreen) {
        document.exitFullscreen();
      }
    }
  }, [domElement, rfs]);

  if (!fullscreenAvailable || isStandaloneVR()) {
    return undefined;
  }

  return {
    text: (isFullscreen ? "Exit" : "Enter") + " Fullscreen",
    action: action
  };
};

var defaultCanvasProps = {
  gl: {
    powerPreference: "high-performance",
    antialias: true,
    depth: true,
    alpha: false,
    stencil: false,
    useLegacyLights: false,
    toneMapping: three.NoToneMapping
  },
  shadows: false,
  camera: {
    position: [0, 2, 0],
    near: 0.01,
    far: 300
  },
  dpr: 1,
  raycaster: {
    far: 3
  },
  events: undefined
};

function MuteOnHide() {
  react.useEffect(function () {
    function handleChange() {
      var context = three.AudioContext.getContext();
      if (document.hidden) context.suspend();else context.resume();
    }

    document.addEventListener("visibilitychange", handleChange);
    return function () {
      return document.removeEventListener("visibilitychange", handleChange);
    };
  }, []);
  return null;
}

function Environment(props) {
  var loadingScreen = props.loadingScreen,
      pauseMenu = props.pauseMenu,
      dev = props.dev,
      canvasProps = props.canvasProps,
      _props$name = props.name,
      name = _props$name === void 0 ? "spacesvr" : _props$name,
      children = props.children;
  var state = useEnvironmentState(name);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(GlobalStyles, null), /*#__PURE__*/React.createElement(MuteOnHide, null), /*#__PURE__*/React.createElement(Container$3, {
    id: "__spacesvr",
    ref: state.containerRef
  }, /*#__PURE__*/React.createElement(EnvironmentContext.Provider, {
    value: state
  }, loadingScreen || /*#__PURE__*/React.createElement(LoadingScreen, null), pauseMenu || /*#__PURE__*/React.createElement(PauseMenu, {
    dev: dev,
    title: name
  }), /*#__PURE__*/React.createElement(Crosshair, null)), /*#__PURE__*/React.createElement(fiber.Canvas, _extends__default["default"]({}, defaultCanvasProps, canvasProps), /*#__PURE__*/React.createElement(xr.XR, null, /*#__PURE__*/React.createElement(EnvironmentContext.Provider, {
    value: state
  }, /*#__PURE__*/React.createElement(RegisterMenuItems, null), children)))));
}

var _templateObject$2;

/**
 * NippleMovement gives the player a direction to move by taking
 * input from a nipple (joystick).
 *
 * Direction is stored as a Vector3 with the following format
 *    x: left/right movement, + for right
 *    y: forward/back movement, + for forwards
 *    z: up/down movement, + for up
 *
 * @param props
 * @constructor
 */
var NippleMovement = function NippleMovement(props) {
  var direction = props.direction;
  var nipple = react.useRef();
  var nippleContainer = react.useRef();

  var _useEnvironment = useEnvironment(),
      containerRef = _useEnvironment.containerRef;

  react.useEffect(function () {
    if (containerRef.current) {
      nippleContainer.current = document.createElement("div");
      nippleContainer.current.style.position = "fixed";
      nippleContainer.current.style.left = "0";
      nippleContainer.current.style.bottom = "0";
      nippleContainer.current.style.width = "40%";
      nippleContainer.current.style.maxWidth = "160px";
      nippleContainer.current.style.height = "25%";
      nippleContainer.current.style.height = "160px";
      nippleContainer.current.style.zIndex = "5"; // add class identifier to nippleContainer to identify touchEvents

      nippleContainer.current.classList.add("nipple-container");
      containerRef.current.appendChild(nippleContainer.current);
      nipple.current = nipplejs__default["default"].create({
        zone: nippleContainer.current,
        mode: "static",
        position: {
          left: "50%",
          top: "50%"
        },
        color: "#fff",
        size: 120,
        restOpacity: 0.75
      });
      nipple.current.on("move", function (evt, data) {
        // i kinda pulled 60 out of my ass tbh
        var x = data.distance / 60 * Math.cos(data.angle.radian);
        var z = -data.distance / 60 * Math.sin(data.angle.radian);
        direction.current.set(x, 0, z);
      });
      nipple.current.on("end", function () {
        direction.current.set(0, 0, 0);
      });
      nippleContainer.current.addEventListener("touchstart", function (ev) {
        ev.preventDefault();
      });
      return function () {
        if (nipple.current) nipple.current.destroy();
      };
    }
  }, []);
  var nippleStyles = react$1.css(_templateObject$2 || (_templateObject$2 = _taggedTemplateLiteralLoose__default["default"](["\n    .nipple-container > * > .front,\n    .nipple-container > * > .back {\n      background: radial-gradient(white, white 64%, black 86%) !important;\n    }\n  "])));
  return /*#__PURE__*/React.createElement(react$1.Global, {
    styles: nippleStyles
  });
};

/**
 * KeyboardMovement gives the player a direction to move by taking
 * input from any source (currently keyboard) and calculating
 * relative direction.
 *
 * Direction is stored as a Vector3 with the following format
 *    x: left/right movement, + for right
 *    y: forward/back movement, + for forwards
 *    z: up/down movement, + for up
 *
 * @param props
 * @constructor
 */
var KeyboardMovement = function KeyboardMovement(props) {
  var direction = props.direction,
      flying = props.flying;

  var _useEnvironment = useEnvironment(),
      paused = _useEnvironment.paused;

  var pressedKeys = react.useRef([false, false, false, false, false]); // key events

  var calcDirection = react.useCallback(function () {
    var press = pressedKeys.current; // [w, a, s, d]

    var yAxis = -1 * Number(press[0]) + Number(press[2]);
    var xAxis = -1 * Number(press[1]) + Number(press[3]);
    return [xAxis, flying && press[4] ? 1 : 0, yAxis];
  }, [flying]);
  var updatePressedKeys = react.useCallback(function (ev, pressedState) {
    // We try to use `code` first because that's the layout-independent property.
    // Then we use `key` because some browsers, notably Internet Explorer and
    // Edge, support it but not `code`. Then we use `keyCode` to support older
    // browsers like Safari, older Internet Explorer and older Chrome.
    switch (ev.code || ev.key || ev.keyCode) {
      case "KeyW":
      case "KeyI":
      case "ArrowUp":
      case "Numpad8":
      case 38:
        // keyCode for arrow up
        pressedKeys.current[0] = pressedState;
        break;

      case "KeyA":
      case "KeyJ":
      case "ArrowLeft":
      case "Numpad4":
      case 37:
        // keyCode for arrow left
        pressedKeys.current[1] = pressedState;
        break;

      case "KeyS":
      case "KeyK":
      case "ArrowDown":
      case "Numpad5":
      case "Numpad2":
      case 40:
        // keyCode for arrow down
        pressedKeys.current[2] = pressedState;
        break;

      case "KeyD":
      case "KeyL":
      case "ArrowRight":
      case "Numpad6":
      case 39:
        // keyCode for arrow right
        pressedKeys.current[3] = pressedState;
        break;

      case "Space":
        pressedKeys.current[4] = pressedState;
        break;

      default:
        return;
    }
  }, []);
  var onKeyDown = react.useCallback(function (ev) {
    if (ev.defaultPrevented) {
      return;
    } // We don't want to mess with the browser's shortcuts


    if (ev.ctrlKey || ev.altKey || ev.metaKey) {
      return;
    }

    updatePressedKeys(ev, true);

    var _calcDirection = calcDirection(),
        x = _calcDirection[0],
        y = _calcDirection[1],
        z = _calcDirection[2];

    direction.current.set(x, y, z);
  }, [calcDirection, direction, updatePressedKeys]);
  var onKeyUp = react.useCallback(function (ev) {
    updatePressedKeys(ev, false);

    var _calcDirection2 = calcDirection(),
        x = _calcDirection2[0],
        y = _calcDirection2[1],
        z = _calcDirection2[2];

    direction.current.set(x, y, z);
  }, [calcDirection, direction, updatePressedKeys]);
  react.useEffect(function () {
    if (paused) {
      direction.current.set(0, 0, 0);
      pressedKeys.current = [false, false, false, false, false];
      return;
    }

    document.addEventListener("keydown", onKeyDown);
    document.addEventListener("keyup", onKeyUp);
    return function () {
      document.removeEventListener("keydown", onKeyDown);
      document.removeEventListener("keyup", onKeyUp);
    };
  }, [paused, onKeyDown, onKeyUp, direction]);
  return null;
};

var EPS = 0.0001;
var MIN_POLAR_ANGLE = EPS; // radians

var MAX_POLAR_ANGLE = Math.PI - EPS; // radians

var SENSITIVITY = 0.8;
var PI_2 = Math.PI / 2;
/**
 * PointerLockCamera is a react port of PointerLockControls.js from THREE,
 * with some changes. Some parameters are listed above
 *
 * https://github.com/mrdoob/three.js/blob/master/examples/jsm/controls/PointerLockControls.js
 *
 * @constructor
 */

function PointerLockCamera() {
  var camera = fiber.useThree(function (state) {
    return state.camera;
  });
  var gl = fiber.useThree(function (state) {
    return state.gl;
  });
  var domElement = gl.domElement;

  var _useEnvironment = useEnvironment(),
      paused = _useEnvironment.paused,
      setPaused = _useEnvironment.setPaused,
      events = _useEnvironment.events;

  var isLocked = react.useRef(false);

  var _useState = react.useState(new three.Euler(0, 0, 0, "YXZ")),
      euler = _useState[0];

  var isCurrentlyLocked = react.useCallback(function () {
    return domElement.ownerDocument.pointerLockElement === domElement;
  }, [domElement]);
  var leaveTime = react.useRef(0);
  react.useEffect(function () {
    // update camera while controls are locked
    var onMouseMove = function onMouseMove(ev) {
      if (!isLocked.current) return; // @ts-ignore

      var dx = ev.movementX || ev.mozMovementX || ev.webkitMovementX || 0; // @ts-ignore

      var dy = ev.movementY || ev.mozMovementY || ev.webkitMovementY || 0;
      euler.setFromQuaternion(camera.quaternion);
      euler.y -= dx * SENSITIVITY * 0.002;
      euler.x -= dy * SENSITIVITY * 0.002;
      euler.x = Math.max(PI_2 - MAX_POLAR_ANGLE, Math.min(PI_2 - MIN_POLAR_ANGLE, euler.x));
      camera.quaternion.setFromEuler(euler);
    }; // automatically unlock on pointer lock error


    function onError() {
      isLocked.current = false;
      setPaused(true);
    } // handle pointer lock change


    function onChange() {
      if (isCurrentlyLocked()) {
        isLocked.current = true;

        if (paused) {
          setPaused(false);
        }
      } else {
        leaveTime.current = performance.now();
        isLocked.current = false;

        if (!paused) {
          setPaused(true);
        }
      }
    }

    var ownerDocument = domElement.ownerDocument;
    ownerDocument.addEventListener("mousemove", onMouseMove);
    ownerDocument.addEventListener("pointerlockchange", onChange);
    ownerDocument.addEventListener("pointerlockerror", onError);
    return function () {
      ownerDocument.removeEventListener("mousemove", onMouseMove);
      ownerDocument.removeEventListener("pointerlockchange", onChange);
      ownerDocument.removeEventListener("pointerlockerror", onError);
    };
  }, [paused, domElement, setPaused, euler, camera.quaternion, isCurrentlyLocked]); // detect failed, uncaught pointer lock errors

  react.useEffect(function () {
    setTimeout(function () {
      if (!isLocked.current && !paused) {
        setPaused(true);
      }
    }, 250);
  }, [paused, setPaused]);
  react.useEffect(function () {
    var ev = function ev(paused) {
      if (paused) {
        domElement.ownerDocument.exitPointerLock();
      } else {
        // leaving pointer lock makes you wait for 1.25s to relock, trying will throw error
        if (performance.now() - leaveTime.current > 1250) {
          domElement.requestPointerLock();
        }
      }
    };

    events.push(ev);
    return function () {
      var ind = events.indexOf(ev);
      if (ind >= 0) events.splice(ind, 1);
    };
  }, [domElement, events, isCurrentlyLocked]);
  return null;
}

var DefaultTouch = {
  pos: new three.Vector2(0, 0),
  id: -1
}; // get the current touch from touch array

var getCurrentTouch = function getCurrentTouch(curTouchId, touches) {
  var len = touches.length;

  for (var i = 0; i < len; i++) {
    if (curTouchId === touches[i].identifier) {
      return touches[i];
    }
  }

  return undefined;
}; // check whether given touch tapped nipple

var tappedNipple = function tappedNipple(ev) {
  // get the relevant touched element (casted as an Element)
  var ele = ev.touches[ev.touches.length - 1].target;
  return ele.classList.contains("nipple-container") || ele.classList.contains("front") || ele.classList.contains("back");
};

var DRAG_SENSITIVITY = new three.Vector2(0.7, 0.7);
/**
 * TouchFPSCamera controls the camera rotation by detecting
 * touch drag on the screen. Unlike MouseFPSCamera, this component
 * does not have a way to pause, that must be done externally.
 *
 * @param props
 * @constructor
 */

function TouchFPSCamera() {
  var touchStartPos = react.useRef(DefaultTouch);
  var originEuler = react.useRef(new three.Euler(0, 0, 0, "YXZ"));
  var camera = fiber.useThree(function (state) {
    return state.camera;
  });

  var getNewEuler = function getNewEuler(dragX, dragY) {
    var newEuler = originEuler.current.clone();
    var moveX = dragX - touchStartPos.current.pos.x;
    var moveY = dragY - touchStartPos.current.pos.y;
    newEuler.setFromQuaternion(camera.quaternion);
    newEuler.y = originEuler.current.y - moveX * DRAG_SENSITIVITY.x / 100;
    newEuler.x = originEuler.current.x - moveY * DRAG_SENSITIVITY.y / 100;
    newEuler.x = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, newEuler.x));
    return newEuler;
  }; // touch move scripts


  var onTouchStart = function onTouchStart(ev) {
    if (touchStartPos.current.id !== -1) {
      return;
    }

    if (tappedNipple(ev)) {
      touchStartPos.current = DefaultTouch;
      return;
    } // get last in list (most recent touch) to not confuse with movement


    var touchIndex = ev.touches.length - 1;
    var _ev$touches$touchInde = ev.touches[touchIndex],
        clientX = _ev$touches$touchInde.clientX,
        clientY = _ev$touches$touchInde.clientY,
        id = _ev$touches$touchInde.identifier;
    touchStartPos.current = {
      pos: new three.Vector2(clientX, clientY),
      id: id
    };
    originEuler.current.setFromQuaternion(camera.quaternion);
  };

  var onTouchMove = function onTouchMove(ev) {
    var touch = getCurrentTouch(touchStartPos.current.id, ev.touches);
    if (!touch) return;
    var clientX = touch.clientX,
        clientY = touch.clientY;
    var newEuler = getNewEuler(clientX, clientY);
    camera.quaternion.setFromEuler(newEuler);
  };

  var onTouchEnd = function onTouchEnd(ev) {
    var touch = getCurrentTouch(touchStartPos.current.id, ev.changedTouches);
    if (!touch) return;
    var clientX = touch.clientX,
        clientY = touch.clientY;
    originEuler.current = getNewEuler(clientX, clientY);
    touchStartPos.current.id = -1;
  };

  react.useEffect(function () {
    document.addEventListener("touchstart", onTouchStart);
    document.addEventListener("touchmove", onTouchMove);
    document.addEventListener("touchend", onTouchEnd);
    return function () {
      document.removeEventListener("touchstart", onTouchStart);
      document.removeEventListener("touchmove", onTouchMove);
      document.removeEventListener("touchend", onTouchEnd);
    };
  }, [onTouchEnd, onTouchMove, onTouchStart]);
  return null;
}

// height of 0.9 (eye level) for a perceived height of 1
var HEIGHT = 0.9;
var RADIUS = 0.225;
var SEGMENTS = 8;
var SPHERE_SHAPE = "Sphere";
var sphereProps = {
  type: SPHERE_SHAPE,
  args: [RADIUS, SEGMENTS, SEGMENTS]
};

var topSphere = _extends__default["default"]({}, sphereProps, {
  position: [0, -RADIUS, 0]
});

var middleSphere = _extends__default["default"]({}, sphereProps, {
  position: [0, -(HEIGHT / 2), 0]
});

var bottomSphere = _extends__default["default"]({}, sphereProps, {
  position: [0, -(HEIGHT - RADIUS), 0]
});

var useCapsuleCollider = function useCapsuleCollider(initPos) {
  var _useEnvironment = useEnvironment(),
      paused = _useEnvironment.paused;

  var compoundBody = cannon.useCompoundBody(function () {
    return {
      mass: 0,
      position: initPos.current.toArray(),
      segments: SEGMENTS,
      fixedRotation: true,
      type: "Dynamic",
      shapes: [topSphere, middleSphere, bottomSphere]
    };
  });
  react.useEffect(function () {
    if (!paused) compoundBody[1].mass.set(62);
  }, [paused, compoundBody]);
  return compoundBody;
};

var ALPHA_SENSITIVITY = 0.008;

/**
 *
 * Gyro controls uses device orientation controls from three js, if applicable.
 * A required fallback component will be used in the place of the gyroscope
 * controls until they are accepted and in use.
 *
 * Some code sampled from TouchFPSCamera.ts
 *
 * @param props
 * @constructor
 */
var GyroControls = function GyroControls(props) {
  var fallback = props.fallback;
  var camera = fiber.useThree(function (state) {
    return state.camera;
  });

  var _useState = react.useState(),
      controls = _useState[0],
      setControls = _useState[1];

  var _useState2 = react.useState(false),
      enableGyro = _useState2[0],
      setEnableGyro = _useState2[1];

  var _useState3 = react.useState(0),
      alphaVal = _useState3[0],
      setAlphaVal = _useState3[1]; // dragging for y axis offset


  var touchStartPos = react.useRef(DefaultTouch);
  var currentOffset = react.useRef(0);

  var _useSpring = three$1.useSpring({
    alpha: alphaVal,
    config: _extends__default["default"]({}, three$1.config["default"], {
      precision: 0.001
    })
  }),
      alpha = _useSpring.alpha; // try to prompt user for device controls


  react.useEffect(function () {
    if (!controls) {
      var func = function func() {
        var cont = new threeStdlib.DeviceOrientationControls(camera);
        cont.enabled = false; // set to disabled in case they're not working yet

        setControls(cont);
      };

      window.addEventListener("click", func);
      return function () {
        window.removeEventListener("click", func);
      };
    }
  }, [controls]);
  fiber.useFrame(function () {
    if (controls && !enableGyro) {
      // check if an event has been received yet
      if (Object.keys(controls.deviceOrientation).length !== 0) {
        setEnableGyro(true);
        controls.enabled = true;
      }
    }

    if (controls) {
      controls.alphaOffset = -alpha.get() * ALPHA_SENSITIVITY;
      controls.update();
    }
  }); // touch move scripts

  var onTouchStart = function onTouchStart(ev) {
    if (touchStartPos.current.id !== -1) {
      return;
    }

    if (tappedNipple(ev)) {
      touchStartPos.current = DefaultTouch;
      return;
    } // get last in list (most recent touch) to not confuse with movement


    var touchIndex = ev.touches.length - 1;
    var _ev$touches$touchInde = ev.touches[touchIndex],
        clientX = _ev$touches$touchInde.clientX,
        clientY = _ev$touches$touchInde.clientY,
        id = _ev$touches$touchInde.identifier;
    touchStartPos.current = {
      pos: new three.Vector2(clientX, clientY),
      id: id
    };
  };

  var onTouchMove = function onTouchMove(ev) {
    var touch = getCurrentTouch(touchStartPos.current.id, ev.touches);

    if (!touch) {
      return;
    }

    var extraOffset = touch.clientX - touchStartPos.current.pos.x;
    setAlphaVal(currentOffset.current + extraOffset);
  };

  var onTouchEnd = function onTouchEnd(ev) {
    var touch = getCurrentTouch(touchStartPos.current.id, ev.changedTouches);

    if (!touch) {
      return;
    }

    var finalOffset = touch.clientX - touchStartPos.current.pos.x;
    setAlphaVal(currentOffset.current + finalOffset);
    currentOffset.current += finalOffset;
    touchStartPos.current.id = -1;
  }; // register touch events


  react.useEffect(function () {
    document.addEventListener("touchstart", onTouchStart);
    document.addEventListener("touchmove", onTouchMove);
    document.addEventListener("touchend", onTouchEnd);
    return function () {
      document.removeEventListener("touchstart", onTouchStart);
      document.removeEventListener("touchmove", onTouchMove);
      document.removeEventListener("touchend", onTouchEnd);
    };
  }, []);

  if (!enableGyro) {
    return /*#__PURE__*/React.createElement(React.Fragment, null, fallback);
  }

  return null;
};

var useSpringVelocity = function useSpringVelocity(bodyApi, speed) {
  var direction = react.useRef(new three.Vector3());

  var _useEnvironment = useEnvironment(),
      device = _useEnvironment.device;

  var dummy = react.useMemo(function () {
    return new three.Vector3();
  }, []);

  var _useState = react.useState(new three.Quaternion()),
      quat = _useState[0];

  var targetYVel = react.useRef(0);
  var clock = fiber.useThree(function (state) {
    return state.clock;
  });
  var lastvelocity = react.useRef(new three.Vector3());
  var lastTime = react.useRef(0);
  var y_accel = react.useRef(0);

  var _useState2 = react.useState(new three.Vector3()),
      dumdum = _useState2[0];

  var updateVelocity = function updateVelocity(cam, velocity) {
    dumdum.x = velocity.x || 0;
    dumdum.y = 0;
    dumdum.z = velocity.z || 0;
    var vel = dumdum.length() / speed;
    var y_change = (velocity.y || 0) - lastvelocity.current.y;
    var elapsedTime = clock.getElapsedTime();
    var delta = Math.abs(elapsedTime - lastTime.current);
    y_accel.current = three.MathUtils.lerp(y_accel.current, y_change / delta || 0, // i think this is the bad one!!! (for all the || 0's)
    0.1); // get forward/back movement and left/right movement velocities

    dummy.x = (direction.current.x || 0) * 0.75;
    dummy.z = direction.current.z || 0; // forward/back

    dummy.y = 0;
    dummy.multiplyScalar(speed + Math.abs(y_accel.current) * 0.085);
    quat.copy(cam.quaternion);
    quat.x = 0;
    quat.z = 0;
    dummy.applyQuaternion(quat); // calc y velocity

    targetYVel.current = three.MathUtils.lerp(targetYVel.current, (direction.current.y || 0) * 0.6, 0.05 + vel * 0.075);
    dummy.y = Math.min((velocity.y || 0) + targetYVel.current, 4 + vel); // keep y velocity intact and update velocity

    if (!device.desktop) {
      bodyApi.velocity.set(dummy.x, dummy.y, dummy.z);
      lastvelocity.current.set(dummy.x, dummy.y, dummy.z);
    } else {
      var newX = three.MathUtils.lerp(velocity.x || 0, dummy.x, 0.25);
      var newZ = three.MathUtils.lerp(velocity.z || 0, dummy.z, 0.25);
      bodyApi.velocity.set(newX, dummy.y, newZ);
      lastvelocity.current.set(newX, dummy.y, newZ);
    }

    lastTime.current = elapsedTime;
  };

  return {
    direction: direction,
    updateVelocity: updateVelocity
  };
};

/**
 * VRControllerMovement gives the player a direction to move by taking
 * input from the Oculus Quest Gamepad.
 *
 *
 * @param props
 * @constructor
 */
var SnapTurn = function SnapTurn(props) {
  var _props$hand = props.hand,
      hand = _props$hand === void 0 ? "right" : _props$hand,
      _props$increment = props.increment,
      increment = _props$increment === void 0 ? Math.PI / 6 : _props$increment,
      _props$threshold = props.threshold,
      threshold = _props$threshold === void 0 ? 0.8 : _props$threshold;
  var controller = xr.useController(hand);

  var _useXR = xr.useXR(),
      player = _useXR.player;

  var isSnapping = react.useRef(false);
  fiber.useFrame(function () {
    if (controller && controller.inputSource.gamepad) {
      var _controller$inputSour = controller.inputSource.gamepad.axes,
          x = _controller$inputSour[2];

      if (Math.abs(x) > threshold) {
        if (!isSnapping.current) {
          player.rotateY(-increment * Math.sign(x));
        }

        isSnapping.current = true;
      } else {
        isSnapping.current = false;
      }
    }
  });
  return null;
};

var SmoothLocomotion = function SmoothLocomotion(props) {
  var _props$hand2 = props.hand,
      hand = _props$hand2 === void 0 ? "left" : _props$hand2,
      direction = props.direction;
  var controller = xr.useController(hand);
  fiber.useFrame(function () {
    if (controller && controller.inputSource.gamepad) {
      var _controller$inputSour2 = controller.inputSource.gamepad.axes,
          x = _controller$inputSour2[2],
          z = _controller$inputSour2[3];
      direction.current.x = x;
      direction.current.z = z;
    }
  });
  return null;
};

var Fly = function Fly(props) {
  var direction = props.direction;
  var controller = xr.useController("left");
  fiber.useFrame(function () {
    if (controller && controller.inputSource.gamepad) {
      var _controller$inputSour3 = controller.inputSource.gamepad.buttons,
          aButton = _controller$inputSour3[0];
      if (!aButton) return;
      direction.current.y = aButton.pressed ? 0.5 : 0;
    }
  });
  return null;
};

function VRControllerMovement(props) {
  var position = props.position,
      direction = props.direction,
      snapTurn = props.snapTurn,
      smoothLocomotion = props.smoothLocomotion;

  var _useXR2 = xr.useXR(),
      player = _useXR2.player;

  fiber.useFrame(function () {
    player.position.copy(position.current); // average human height is ~1.7, player height is 1.
    // somehow subtracting 1 is more correct idk
    // update: now 1.4 seems right? who fukn knows
    // update: definitely a difference between sitting + standing

    player.position.y -= 1.4;
  });
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Fly, {
    direction: direction
  }), /*#__PURE__*/React.createElement(SnapTurn, snapTurn), /*#__PURE__*/React.createElement(SmoothLocomotion, _extends__default["default"]({}, smoothLocomotion, {
    direction: direction
  })), /*#__PURE__*/React.createElement(xr.Controllers, null));
}

var useControlLock = function useControlLock(lockControls) {
  return react.useMemo(function () {
    return {
      lock: function lock() {
        return lockControls.current = true;
      },
      unlock: function unlock() {
        return lockControls.current = false;
      },
      isLocked: function isLocked() {
        return lockControls.current;
      }
    };
  }, [lockControls]);
};

var useBob = function useBob(velocity, direction) {
  var camera = fiber.useThree(function (st) {
    return st.camera;
  });

  var _useSpring = three$1.useSpring({
    bob: 0,
    config: three$1.config["default"]
  }),
      bob = _useSpring.bob;

  var _useState = react.useState(new three.Vector3()),
      offset = _useState[0];

  var update = function update(clock) {
    var IS_MOVING = direction.current.length() > 0.1;
    var IS_GROUNDED = Math.abs(velocity.current.y) < 0.01;
    bob.set(IS_MOVING && IS_GROUNDED ? 1 : 0);
    var amt = bob.get();
    var y = Math.sin(clock.elapsedTime * 20) * 0.0055 * amt;
    var x = Math.cos(clock.elapsedTime * 15 + 0.3) * 0.002 * amt;
    offset.set(x, y, 0);
    offset.applyQuaternion(camera.quaternion);
    camera.position.add(offset);
  };

  return {
    update: update
  };
};

var PlayerContext = /*#__PURE__*/react.createContext({});
var usePlayer = function usePlayer() {
  return react.useContext(PlayerContext);
};
var SPEED = 3.6; // (m/s) 1.4 walking, 2.6 jogging, 4.1 running

var SHOW_PLAYER_HITBOX = false;

/**
 * Player represents a user controlled entity, complete with a
 * control scheme and a physical representation that interacts with other physics-
 * enabled objects.
 *
 * @constructor
 */
function Player(props) {
  var children = props.children,
      _props$pos = props.pos,
      pos = _props$pos === void 0 ? [0, 1, 0] : _props$pos,
      _props$rot = props.rot,
      rot = _props$rot === void 0 ? 0 : _props$rot,
      _props$flying = props.flying,
      flying = _props$flying === void 0 ? false : _props$flying,
      _props$speed = props.speed,
      speed = _props$speed === void 0 ? SPEED : _props$speed,
      _props$controls = props.controls,
      controls = _props$controls === void 0 ? {
    disableGyro: true
  } : _props$controls;
  var camera = fiber.useThree(function (state) {
    return state.camera;
  });
  var defaultRaycaster = fiber.useThree(function (state) {
    return state.raycaster;
  });

  var _useEnvironment = useEnvironment(),
      device = _useEnvironment.device; // local state


  var initPos = react.useRef(new three.Vector3().fromArray(pos));
  var position = react.useRef(new three.Vector3());
  var velocity = react.useRef(new three.Vector3());
  var lockControls = react.useRef(false);
  var raycaster = react.useMemo(function () {
    return new three.Raycaster(new three.Vector3(), new three.Vector3(), 0, 5);
  }, []); // physical body

  var _useCapsuleCollider = useCapsuleCollider(initPos),
      bodyApi = _useCapsuleCollider[1];

  var _useSpringVelocity = useSpringVelocity(bodyApi, speed),
      direction = _useSpringVelocity.direction,
      updateVelocity = _useSpringVelocity.updateVelocity;

  var bob = useBob(velocity, direction); // initial rotation

  react.useEffect(function () {
    // rotation happens before position move
    camera.rotation.setFromQuaternion(new three.Quaternion().setFromAxisAngle(new three.Vector3(0, 1, 0), rot));
  }, []);
  react.useEffect(function () {
    var unsubPos = bodyApi.position.subscribe(function (p) {
      return position.current.fromArray(p);
    });
    var unsubVel = bodyApi.velocity.subscribe(function (v) {
      return velocity.current.fromArray(v);
    });
    return function () {
      unsubPos();
      unsubVel();
    };
  }, [bodyApi, bodyApi.position, bodyApi.velocity]);
  fiber.useFrame(function (_ref) {
    var clock = _ref.clock;

    // update raycaster on desktop (mobile uses default)
    if (device.desktop) {
      raycaster.ray.origin.copy(position.current);
      raycaster.ray.direction.set(0, 0, -1);
      raycaster.ray.direction.applyQuaternion(camera.quaternion);
    }

    camera.position.copy(position.current);

    if (!lockControls.current) {
      updateVelocity(camera, velocity.current);
      bob.update(clock);
    }
  });
  var setPosition = react.useCallback(function (pos) {
    // in case it gets called before bodyapi is initialized
    initPos.current.copy(pos);
    bodyApi.position.set(pos.x, pos.y, pos.z);
    position.current.copy(pos);
  }, [bodyApi.position]);
  var setVelocity = react.useCallback(function (vel) {
    bodyApi.velocity.set(vel.x, vel.y, vel.z);
    velocity.current.copy(vel);
  }, [bodyApi.velocity]);
  var controlLock = useControlLock(lockControls);
  var value = {
    position: {
      get: function get() {
        return position.current.clone();
      },
      set: setPosition
    },
    velocity: {
      get: function get() {
        return velocity.current.clone();
      },
      set: setVelocity
    },
    controls: controlLock,
    raycaster: device.mobile ? defaultRaycaster : raycaster
  };
  return /*#__PURE__*/React.createElement(PlayerContext.Provider, {
    value: value
  }, device.mobile && /*#__PURE__*/React.createElement(React.Fragment, null, (controls == null ? void 0 : controls.disableGyro) && /*#__PURE__*/React.createElement(TouchFPSCamera, null), !(controls != null && controls.disableGyro) && /*#__PURE__*/React.createElement(GyroControls, {
    fallback: /*#__PURE__*/React.createElement(TouchFPSCamera, null)
  }), /*#__PURE__*/React.createElement(NippleMovement, {
    direction: direction
  })), device.desktop && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(KeyboardMovement, {
    direction: direction,
    flying: flying
  }), /*#__PURE__*/React.createElement(PointerLockCamera, null)), device.xr && /*#__PURE__*/React.createElement(VRControllerMovement, {
    position: position,
    direction: direction
  }), SHOW_PLAYER_HITBOX , children);
}

/**
 * A hook that provides a function to re-render the component.
 *
 * You can use the function itself as a dependency.
 */

function useRerender() {
  var _useState = react.useState(0),
      ct = _useState[0],
      setCt = _useState[1];

  return react.useCallback(function () {
    return setCt(Math.random());
  }, [ct]);
}

var useHTMLInput = function useHTMLInput(type) {
  var input = react.useMemo(function () {
    var inp = document.createElement("input");
    document.body.appendChild(inp);
    return inp;
  }, []);
  react.useEffect(function () {
    input.setAttribute("type", type);
    input.style.zIndex = "-99";
    input.style.opacity = "0";
    input.style.fontSize = "16px"; // this disables zoom on mobile

    input.style.position = "absolute";
    input.style.left = "50%";
    input.style.top = "0";
    input.style.transform = "translate(-50%, 0%)";
  }, [input, type]);
  react.useEffect(function () {
    return function () {
      document.body.removeChild(input);
    };
  }, [input]);
  return input;
};
var useTextInput = function useTextInput(type, value, onChange) {
  // number isn't selectable, so we use text
  var input = useHTMLInput(type === "password" ? "password" : "text");

  var _useEnvironment = useEnvironment(),
      paused = _useEnvironment.paused;

  var _usePlayer = usePlayer(),
      controls = _usePlayer.controls,
      velocity = _usePlayer.velocity;

  var rerender = useRerender();

  var _useState = react.useState(false),
      focused = _useState[0],
      setFocused = _useState[1];

  var protectClick = react.useRef(false); // used to click off of the input to blur
  // input setup

  react.useEffect(function () {
    input.addEventListener("focus", function () {
      return setFocused(true);
    });
    input.addEventListener("blur", function () {
      return setFocused(false);
    });
    input.autocomplete = "off";
  }, [input]); // blur on pause

  react.useEffect(function () {
    if (focused && paused) input.blur();
  }, [input, focused, paused]); // stop player from moving while they type (free up wasd)

  react.useEffect(function () {
    if (focused) {
      velocity.set(new three.Vector3());
      controls.lock();
    } else if (!isTyping()) {
      velocity.set(new three.Vector3());
      controls.unlock();
    }
  }, [focused, velocity, controls]); // free up wasd on unmount

  react.useEffect(function () {
    return function () {
      if (!isTyping()) controls.unlock();
    };
  }, [controls]); // set up event listeners

  react.useEffect(function () {
    var formatNumber = function formatNumber(s) {
      var re = /[+-]?([0-9]+([.][0-9]*)?|[.][0-9]+)/;
      var res = s.match(re);
      if (!res) return "";
      if (res.input !== res[0]) return value;else return res[0];
    };

    var onDocClick = function onDocClick() {
      var focused = input === document.activeElement;
      if (!protectClick.current && focused) input.blur();else if (protectClick.current && !focused) input.focus();
      protectClick.current = false;
    };

    var onInput = function onInput() {
      if (input !== document.activeElement) return;
      if (type === "number") input.value = formatNumber(input.value);
      onChange(input.value);
    };

    var onSelectionChange = function onSelectionChange() {
      if (input !== document.activeElement) return;
      rerender();
    };

    document.addEventListener("click", onDocClick);
    input.addEventListener("input", onInput);
    document.addEventListener("selectionchange", onSelectionChange);
    return function () {
      document.removeEventListener("click", onDocClick);
      input.removeEventListener("input", onInput);
      document.removeEventListener("selectionchange", onSelectionChange);
    };
  }, [input, onChange, rerender, type, value]); // keep the input's value in sync with the passed state value

  react.useEffect(function () {
    if (input.value !== value) {
      input.value = value;
      rerender();
    }
  }, [input, value]); // call to focus input and protect the click from blurring the input

  var focusInput = function focusInput() {
    protectClick.current = true;
    input.focus();
  };

  return {
    input: input,
    focused: focused,
    focusInput: focusInput
  };
};

/*
  hook to detect when the meta key (cmd on mac, ctrl on windows) is pressed
  includes a timeout since moving your finger to hold it down can jitter a bit
  returns ref containing the state of the press
 */

var useMetaHold = function useMetaHold() {
  var meta = react.useRef(false);
  var timestamp = react.useRef();
  var TIMEOUT = 75;
  react.useEffect(function () {
    var onKeyChange = function onKeyChange(e) {
      var newMeta = e.ctrlKey || e.metaKey;

      if (meta.current && !newMeta) {
        if (!timestamp.current) {
          timestamp.current = new Date().getTime();
          setTimeout(function () {
            meta.current = false;
            timestamp.current = undefined;
          }, TIMEOUT);
        }
      } else {
        meta.current = newMeta;
      }
    };

    document.addEventListener("keydown", onKeyChange);
    document.addEventListener("keyup", onKeyChange);
    return function () {
      document.removeEventListener("keydown", onKeyChange);
      document.removeEventListener("keyup", onKeyChange);
    };
  }, [TIMEOUT]);
  return meta;
};
/**
 * Same as useMetaHold but for shift
 */

var useShiftHold = function useShiftHold() {
  var shift = react.useRef(false);
  var timestamp = react.useRef();
  var TIMEOUT = 75;
  react.useEffect(function () {
    var onKeyChange = function onKeyChange(e) {
      var newShift = e.shiftKey;

      if (shift.current && !newShift) {
        if (!timestamp.current) {
          timestamp.current = new Date().getTime();
          setTimeout(function () {
            shift.current = false;
            timestamp.current = undefined;
          }, TIMEOUT);
        }
      } else {
        shift.current = newShift;
      }
    };

    document.addEventListener("keydown", onKeyChange);
    document.addEventListener("keyup", onKeyChange);
    return function () {
      document.removeEventListener("keydown", onKeyChange);
      document.removeEventListener("keyup", onKeyChange);
    };
  }, [TIMEOUT]);
  return shift;
};
/**
 * hook to run a callback when a given key is pressed
 * @param keys key or keys to listen for, by .key property
 * @param callback callback to run when key is pressed
 * @param deps any additional dependencies to watch for changes
 */

var useKeypress = function useKeypress(keys, callback, deps) {
  react.useEffect(function () {
    var locKeys = Array.isArray(keys) ? keys : [keys];

    var thisCallback = function thisCallback(e) {
      if (locKeys.includes(e.key)) callback(e);
    };

    document.addEventListener("keypress", thisCallback);
    return function () {
      document.removeEventListener("keypress", thisCallback);
    };
  }, [callback, keys].concat(deps || []));
};

/**
 * Given a spring animated value, return a visible value when the springed value reaches 0.
 * Used for setting the visible prop to false when a component is scaled to 0
 * @param val
 */

var useVisible = function useVisible(val) {
  var _useState = react.useState(false),
      visible = _useState[0],
      setVisible = _useState[1];

  useLimitedFrame(5, function () {
    var v = val.get();
    if (visible && v === 0) setVisible(false);else if (!visible && v > 0) setVisible(true);
  });
  return visible;
};

var _excluded$l = ["src", "center", "normalize"],
    _excluded2 = ["src", "center", "normalize"];

function UnsuspensedModel(props) {
  var src = props.src,
      center = props.center,
      normalize = props.normalize,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$l);

  var gltf = useModel(src);
  var model = react.useMemo(function () {
    return threeStdlib.SkeletonUtils.clone(gltf.scene);
  }, [gltf.scene]);
  var bbox = react.useMemo(function () {
    return new three.Box3().setFromObject(model);
  }, [model]);
  var centerVec = react.useMemo(function () {
    return bbox.getCenter(new three.Vector3()).multiplyScalar(-1);
  }, [bbox]);
  var sizeX = bbox.max.x - bbox.min.x;
  var sizeY = bbox.max.y - bbox.min.y;
  var sizeZ = bbox.max.z - bbox.min.z;
  var maxSide = Math.max(sizeX, sizeY, sizeZ);
  var NORM_SCALE = 1 / maxSide;
  return /*#__PURE__*/React.createElement("group", _extends__default["default"]({
    name: "spacesvr-model"
  }, rest), /*#__PURE__*/React.createElement("group", {
    scale: normalize ? NORM_SCALE : 1
  }, /*#__PURE__*/React.createElement("primitive", {
    object: model,
    position: center ? centerVec : undefined
  })));
}

function FallbackModel(props) {
  props.src;
      props.center;
      props.normalize;
      var rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded2);

  return /*#__PURE__*/React.createElement("group", _extends__default["default"]({
    name: "spacesvr-fallback-model"
  }, rest), /*#__PURE__*/React.createElement("mesh", {
    material: cache.mat_basic_black_wireframe
  }, /*#__PURE__*/React.createElement("boxGeometry", {
    args: [1, 1, 1]
  })));
}

function Model(props) {
  return /*#__PURE__*/React.createElement(reactErrorBoundary.ErrorBoundary, {
    fallbackRender: function fallbackRender() {
      return /*#__PURE__*/React.createElement(FallbackModel, props);
    },
    onError: function onError(err) {
      return console.error(err);
    }
  }, /*#__PURE__*/React.createElement(react.Suspense, {
    fallback: null
  }, /*#__PURE__*/React.createElement(UnsuspensedModel, props)));
}

var _excluded$k = ["src", "size", "framed", "muted", "volume", "frameMaterial", "frameWidth"];
function Video(props) {
  var src = props.src,
      _props$size = props.size,
      size = _props$size === void 0 ? 1 : _props$size,
      framed = props.framed,
      muted = props.muted,
      _props$volume = props.volume,
      volume = _props$volume === void 0 ? 1 : _props$volume,
      frameMaterial = props.frameMaterial,
      _props$frameWidth = props.frameWidth,
      frameWidth = _props$frameWidth === void 0 ? 1 : _props$frameWidth,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$k);

  var camera = fiber.useThree(function (state) {
    return state.camera;
  });
  var listener = react.useRef();

  var _useState = react.useState(),
      speaker = _useState[0],
      setSpeaker = _useState[1];

  var _useState2 = react.useState(),
      dims = _useState2[0],
      setDims = _useState2[1];

  var video = react.useMemo(function () {
    var v = document.createElement("video"); // @ts-ignore

    v.playsInline = true;
    v.crossOrigin = "Anonymous";
    v.loop = true;
    v.src = src;
    v.autoplay = false;
    v.muted = muted ? muted : false;
    return v;
  }, []);
  react.useEffect(function () {
    var setupAudio = function setupAudio() {
      if (!muted && !video.paused && !speaker) {
        var _listener = new three.AudioListener();

        camera.add(_listener);
        var speak = new three.PositionalAudio(_listener);
        speak.setMediaElementSource(video);
        speak.setRefDistance(0.75);
        speak.setRolloffFactor(1);
        speak.setVolume(volume);
        speak.setDirectionalCone(180, 230, 0.1);
        setSpeaker(speak);
      }
    };

    var playVideo = function playVideo() {
      video.play().then(function () {
        return setDims(new three.Vector2(video.videoWidth, video.videoHeight));
      });
      setupAudio();
    };

    if (video) {
      video.play().then(function () {
        setDims(new three.Vector2(video.videoWidth, video.videoHeight));
        setupAudio();
      });
      document.addEventListener("click", playVideo);
      return function () {
        document.removeEventListener("click", playVideo);
      };
    }
  }, [speaker, video, muted]);
  react.useEffect(function () {
    return function () {
      if (listener.current) {
        camera.remove(listener.current);
        listener.current.clear();
        listener.current = undefined;
      }

      if (speaker) {
        speaker.clear();
        speaker.disconnect();
        setSpeaker(undefined);
      }

      if (video) {
        video.pause();
        video.remove();
      }
    };
  }, []);

  if (!dims || !video) {
    return null;
  }

  var max = Math.max(dims.x, dims.y);
  var width = dims.x / max * size;
  var height = dims.y / max * size;
  return /*#__PURE__*/React.createElement("group", _extends__default["default"]({
    name: "spacesvr-video"
  }, rest), /*#__PURE__*/React.createElement("mesh", null, /*#__PURE__*/React.createElement("planeGeometry", {
    args: [width, height]
  }), /*#__PURE__*/React.createElement("meshBasicMaterial", {
    side: three.DoubleSide
  }, /*#__PURE__*/React.createElement("videoTexture", {
    attach: "map",
    args: [video],
    encoding: three.sRGBEncoding
  }))), speaker && /*#__PURE__*/React.createElement("primitive", {
    object: speaker
  }), framed && /*#__PURE__*/React.createElement(Frame, {
    width: width,
    height: height,
    thickness: frameWidth,
    material: frameMaterial
  }));
}

function LostFloor() {
  var mat = react.useMemo(function () {
    var m = new three.MeshLambertMaterial();

    m.onBeforeCompile = function (shader) {
      shader.vertexShader = vertHead$1 + shader.vertexShader.replace("#include <worldpos_vertex>", "#include <worldpos_vertex>\n" + vertBody);
      shader.fragmentShader = fragHead + shader.fragmentShader.replace("#include <color_fragment>", "#include <color_fragment>\n  " + fragColorFragment);
    };

    return m;
  }, []);
  return /*#__PURE__*/React.createElement("group", {
    name: "spacesvr-lost-floor"
  }, /*#__PURE__*/React.createElement("mesh", {
    "rotation-x": -Math.PI / 2,
    material: mat
  }, /*#__PURE__*/React.createElement("planeGeometry", {
    args: [10000, 10000, 1, 1]
  })));
}
var noise = "\n   //\n  // Description : Array and textureless GLSL 2D/3D/4D simplex\n  //               noise functions.\n  //      Author : Ian McEwan, Ashima Arts.\n  //  Maintainer : ijm\n  //     Lastmod : 20110822 (ijm)\n  //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n  //               Distributed under the MIT License. See LICENSE file.\n  //               https://github.com/ashima/webgl-noise\n  //\n  \n  vec3 mod289(vec3 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n  }\n  \n  vec4 mod289(vec4 x) {\n    return x - floor(x * (1.0 / 289.0)) * 289.0;\n  }\n  \n  vec4 permute(vec4 x) {\n       return mod289(((x*34.0)+1.0)*x);\n  }\n  \n  vec4 taylorInvSqrt(vec4 r)\n  {\n    return 1.79284291400159 - 0.85373472095314 * r;\n  }\n  \n  float snoise(vec3 v)\n    {\n    const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n    const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n  \n  // First corner\n    vec3 i  = floor(v + dot(v, C.yyy) );\n    vec3 x0 =   v - i + dot(i, C.xxx) ;\n  \n  // Other corners\n    vec3 g = step(x0.yzx, x0.xyz);\n    vec3 l = 1.0 - g;\n    vec3 i1 = min( g.xyz, l.zxy );\n    vec3 i2 = max( g.xyz, l.zxy );\n  \n    //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n    //   x1 = x0 - i1  + 1.0 * C.xxx;\n    //   x2 = x0 - i2  + 2.0 * C.xxx;\n    //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n    vec3 x1 = x0 - i1 + C.xxx;\n    vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n    vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n  \n  // Permutations\n    i = mod289(i);\n    vec4 p = permute( permute( permute(\n               i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n             + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n             + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n  \n  // Gradients: 7x7 points over a square, mapped onto an octahedron.\n  // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n    float n_ = 0.142857142857; // 1.0/7.0\n    vec3  ns = n_ * D.wyz - D.xzx;\n  \n    vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n  \n    vec4 x_ = floor(j * ns.z);\n    vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n  \n    vec4 x = x_ *ns.x + ns.yyyy;\n    vec4 y = y_ *ns.x + ns.yyyy;\n    vec4 h = 1.0 - abs(x) - abs(y);\n  \n    vec4 b0 = vec4( x.xy, y.xy );\n    vec4 b1 = vec4( x.zw, y.zw );\n  \n    //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n    //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n    vec4 s0 = floor(b0)*2.0 + 1.0;\n    vec4 s1 = floor(b1)*2.0 + 1.0;\n    vec4 sh = -step(h, vec4(0.0));\n  \n    vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n    vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n  \n    vec3 p0 = vec3(a0.xy,h.x);\n    vec3 p1 = vec3(a0.zw,h.y);\n    vec3 p2 = vec3(a1.xy,h.z);\n    vec3 p3 = vec3(a1.zw,h.w);\n  \n  //Normalise gradients\n    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n    p0 *= norm.x;\n    p1 *= norm.y;\n    p2 *= norm.z;\n    p3 *= norm.w;\n  \n  // Mix final noise value\n    vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n    m = m * m;\n    return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                  dot(p2,x2), dot(p3,x3) ) );\n    } \n  \n";
var oklab = "\nfloat fixedpow(float a, float x)\n{\n    return pow(abs(a), x) * sign(a);\n}\n\nfloat cbrt(float a)\n{\n    return fixedpow(a, 0.3333333333);\n}\n\nvec3 lsrgb2oklab(vec3 c)\n{\n    float l = 0.4122214708 * c.r + 0.5363325363 * c.g + 0.0514459929 * c.b;\n    float m = 0.2119034982 * c.r + 0.6806995451 * c.g + 0.1073969566 * c.b;\n    float s = 0.0883024619 * c.r + 0.2817188376 * c.g + 0.6299787005 * c.b;\n\n    float l_ = cbrt(l);\n    float m_ = cbrt(m);\n    float s_ = cbrt(s);\n\n    return vec3(\n        0.2104542553 * l_ + 0.7936177850 * m_ - 0.0040720468 * s_,\n        1.9779984951 * l_ - 2.4285922050 * m_ + 0.4505937099 * s_,\n        0.0259040371 * l_ + 0.7827717662 * m_ - 0.8086757660 * s_\n    );\n}\n\nvec3 oklab2lsrgb(vec3 c)\n{\n    float l_ = c.r + 0.3963377774 * c.g + 0.2158037573 * c.b;\n    float m_ = c.r - 0.1055613458 * c.g - 0.0638541728 * c.b;\n    float s_ = c.r - 0.0894841775 * c.g - 1.2914855480 * c.b;\n\n    float l = l_ * l_ * l_;\n    float m = m_ * m_ * m_;\n    float s = s_ * s_ * s_;\n\n    return vec3(\n        4.0767416621 * l - 3.3077115913 * m + 0.2309699292 * s,\n        -1.2684380046 * l + 2.6097574011 * m - 0.3413193965 * s,\n        -0.0041960863 * l - 0.7034186147 * m + 1.7076147010 * s\n    );\n}\n";
var vertHead$1 = "\n  varying vec3 vPos;\n";
var vertBody = "\n  vPos = position;\n";
var fragHead = "\n  " + noise + "\n  " + oklab + "\n  \n  varying vec3 vPos;\n";
var fragColorFragment = "\n  diffuseColor.rgb -= 0.2 * (snoise(vPos) + 1.) / 2.;\n  diffuseColor.r -= 0.025 * (snoise(-vPos) + 1.) / 2.;\n";

function _createForOfIteratorHelperLoose$9(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray$9(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$9(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$9(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$9(o, minLen); }

function _arrayLikeToArray$9(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * Traverses an object 3d to find any meshes marked collidable by their name
 */

var KEYWORDS = ["collider", "collision"];
var findColliderMeshes = function findColliderMeshes(obj) {
  var result = [];
  obj.traverse(function (node) {
    if (node.isMesh) {
      for (var _iterator = _createForOfIteratorHelperLoose$9(KEYWORDS), _step; !(_step = _iterator()).done;) {
        var keyword = _step.value;

        if (node.name.toLowerCase().includes(keyword)) {
          result.push(node);
        }
      }
    }
  });

  if (result.length > 0) {
    return result;
  }

  return undefined;
};
/**
 * Gets the number of triangles in a geometry
 */

var getGeometryTriCount = function getGeometryTriCount(geometry) {
  return geometry.index ? geometry.index.count / 3 : geometry.attributes.position.count / 3;
};
/**
 * Traverses an object 3d to find and return all meshes
 */

var getMeshes = function getMeshes(obj) {
  var result = [];
  obj.traverse(function (node) {
    if (node.isMesh) {
      result.push(node);
    }
  });
  return result;
};
/**
 * Given a mesh, clone the geo and apply the transformations. pass a parent to cap off transforms
 */

var getTransformedMeshGeo = function getTransformedMeshGeo(mesh, parent) {
  var geo = mesh.geometry.clone();
  mesh.updateWorldMatrix(true, false);
  var pos = new three.Vector3();
  var quat = new three.Quaternion();
  var euler = new three.Euler();
  var scale = new three.Vector3();
  var obj = mesh;

  do {
    obj.matrix.decompose(pos, quat, scale);
    euler.setFromQuaternion(quat);
    geo.scale(scale.x, scale.y, scale.z);
    geo.rotateX(euler.x);
    geo.rotateY(euler.y);
    geo.rotateZ(euler.z);
    geo.translate(pos.x, pos.y, pos.z);
    obj = obj.parent;
  } while (obj && obj !== parent);

  return geo;
};
/**
 * Gets a uuid for an arr of meshes
 */

var getMeshesUUID = function getMeshesUUID(meshes) {
  var uuids = meshes.map(function (mesh) {
    return mesh.uuid;
  });
  uuids.sort();
  return uuids.join("-");
};

var useTrimeshCollision = function useTrimeshCollision(geometry, trans) {
  var indices = geometry.index.array;
  var isInterleaved = // @ts-ignore
  geometry.attributes.position.isInterleavedBufferAttribute;
  var vertices = [];

  if (isInterleaved) {
    var attr = geometry.attributes.position;
    var data = attr.data;

    for (var i = attr.offset; i < data.array.length; i += data.stride) {
      for (var x = 0; x < attr.itemSize; x++) {
        vertices.push(data.array[i + x]);
      }
    }
  } else {
    vertices = geometry.attributes.position.array;
  }

  return cannon.useTrimesh(function () {
    return {
      type: "Static",
      args: [vertices, indices],
      position: trans == null ? void 0 : trans.pos,
      rotation: trans == null ? void 0 : trans.rot
    };
  }, undefined, [geometry.uuid]);
};

function TrimeshCollider(props) {
  var geo = props.geo;
  var group = react.useRef(null);

  var _useState = react.useState(function () {
    return new three.Vector3();
  }),
      pos = _useState[0];

  var _useState2 = react.useState(function () {
    return new three.Quaternion();
  }),
      quat = _useState2[0];

  var _useState3 = react.useState(function () {
    return new three.Vector3();
  }),
      scale = _useState3[0];

  var _useState4 = react.useState(function () {
    return new three.Euler();
  }),
      euler = _useState4[0];

  var _useState5 = react.useState(new three.Vector3(1, 1, 1)),
      curScale = _useState5[0],
      setCurScale = _useState5[1];

  var geometry = react.useMemo(function () {
    var g = geo.clone().scale(curScale.x, curScale.y, curScale.z);
    g.computeVertexNormals();
    return g;
  }, [geo, curScale]);

  var _useTrimeshCollision = useTrimeshCollision(geometry, {
    pos: pos.toArray(),
    rot: [euler.x, euler.y, euler.z]
  }),
      api = _useTrimeshCollision[1];

  var lastUpdatedMatrix = react.useRef(new three.Matrix4());
  useLimitedFrame(8, function () {
    if (!group.current) return; // get global position, rotation, scale

    group.current.updateWorldMatrix(true, false);
    group.current.matrixWorld.decompose(pos, quat, scale); // no need to update if nothing changed

    if (lastUpdatedMatrix.current.equals(group.current.matrixWorld)) {
      return;
    } // update last values


    lastUpdatedMatrix.current.copy(group.current.matrixWorld); // if a change was found, update collider

    api.position.copy(pos);
    api.rotation.copy(euler.setFromQuaternion(quat));
    if (!scale.equals(curScale)) setCurScale(scale.clone());
  });
  return /*#__PURE__*/React.createElement("group", {
    ref: group
  });
}

// manually copied and modified from three-stdlib to fix bug here: https://github.com/mrdoob/three.js/pull/24169
var cb = new three.Vector3(),
    ab = new three.Vector3();

function pushIfUnique(array, object) {
  if (array.indexOf(object) === -1) array.push(object);
}

function removeFromArray(array, object) {
  var k = array.indexOf(object);
  if (k > -1) array.splice(k, 1);
}

var Vertex = /*#__PURE__*/function () {
  function Vertex(v, id) {
    this.minCost = 0;
    this.totalCost = 0;
    this.costCount = 0;
    this.position = v;
    this.id = id; // old index id

    this.faces = []; // faces vertex is connected

    this.neighbors = []; // neighbouring vertices aka "adjacentVertices"
    // these will be computed in computeEdgeCostAtVertex()

    this.collapseCost = 0; // cost of collapsing this vertex, the less the better. aka objdist

    this.collapseNeighbor = null; // best candinate for collapsing
  }

  var _proto = Vertex.prototype;

  _proto.addUniqueNeighbor = function addUniqueNeighbor(vertex) {
    pushIfUnique(this.neighbors, vertex);
  };

  _proto.removeIfNonNeighbor = function removeIfNonNeighbor(n) {
    var neighbors = this.neighbors;
    var faces = this.faces;
    var offset = neighbors.indexOf(n);
    if (offset === -1) return;

    for (var i = 0; i < faces.length; i++) {
      if (faces[i].hasVertex(n)) return;
    }

    neighbors.splice(offset, 1);
  };

  return Vertex;
}(); // we use a triangle class to represent structure of face slightly differently


var Triangle = /*#__PURE__*/function () {
  function Triangle(v1, v2, v3, a, b, c) {
    this.normal = new three.Vector3();
    this.a = a;
    this.b = b;
    this.c = c;
    this.v1 = v1;
    this.v2 = v2;
    this.v3 = v3;
    this.computeNormal();
    v1.faces.push(this);
    v1.addUniqueNeighbor(v2);
    v1.addUniqueNeighbor(v3);
    v2.faces.push(this);
    v2.addUniqueNeighbor(v1);
    v2.addUniqueNeighbor(v3);
    v3.faces.push(this);
    v3.addUniqueNeighbor(v1);
    v3.addUniqueNeighbor(v2);
  }

  var _proto2 = Triangle.prototype;

  _proto2.computeNormal = function computeNormal() {
    var vA = this.v1.position;
    var vB = this.v2.position;
    var vC = this.v3.position;
    cb.subVectors(vC, vB);
    ab.subVectors(vA, vB);
    cb.cross(ab).normalize();
    this.normal.copy(cb);
  };

  _proto2.hasVertex = function hasVertex(v) {
    return v === this.v1 || v === this.v2 || v === this.v3;
  };

  _proto2.replaceVertex = function replaceVertex(oldv, newv) {
    if (oldv === this.v1) this.v1 = newv;else if (oldv === this.v2) this.v2 = newv;else if (oldv === this.v3) this.v3 = newv;
    removeFromArray(oldv.faces, this);
    newv.faces.push(this);
    oldv.removeIfNonNeighbor(this.v1);
    this.v1.removeIfNonNeighbor(oldv);
    oldv.removeIfNonNeighbor(this.v2);
    this.v2.removeIfNonNeighbor(oldv);
    oldv.removeIfNonNeighbor(this.v3);
    this.v3.removeIfNonNeighbor(oldv);
    this.v1.addUniqueNeighbor(this.v2);
    this.v1.addUniqueNeighbor(this.v3);
    this.v2.addUniqueNeighbor(this.v1);
    this.v2.addUniqueNeighbor(this.v3);
    this.v3.addUniqueNeighbor(this.v1);
    this.v3.addUniqueNeighbor(this.v2);
    this.computeNormal();
  };

  return Triangle;
}();
/**
 *	Simplification Geometry Modifier
 *    - based on code and technique
 *	  - by Stan Melax in 1998
 *	  - Progressive Mesh type Polygon Reduction Algorithm
 *    - http://www.melax.com/polychop/
 */


var SimplifyModifier = /*#__PURE__*/function () {
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  function SimplifyModifier() {
    var _this = this;

    this.computeEdgeCollapseCost = function (u, v) {
      // if we collapse edge uv by moving u to v then how
      // much different will the model change, i.e. the "error".
      var edgelength = v.position.distanceTo(u.position);
      var curvature = 0;
      var sideFaces = [];
      var i,
          // eslint-disable-next-line prefer-const
      il = u.faces.length,
          face,
          sideFace; // find the "sides" triangles that are on the edge uv

      for (i = 0; i < il; i++) {
        face = u.faces[i];

        if (face.hasVertex(v)) {
          sideFaces.push(face);
        }
      } // use the triangle facing most away from the sides
      // to determine our curvature term


      for (i = 0; i < il; i++) {
        var minCurvature = 1;
        face = u.faces[i];

        for (var j = 0; j < sideFaces.length; j++) {
          sideFace = sideFaces[j]; // use dot product of face normals.

          var dotProd = face.normal.dot(sideFace.normal);
          minCurvature = Math.min(minCurvature, (1.001 - dotProd) / 2);
        }

        curvature = Math.max(curvature, minCurvature);
      } // crude approach in attempt to preserve borders
      // though it seems not to be totally correct


      var borders = 0;

      if (sideFaces.length < 2) {
        // we add some arbitrary cost for borders,
        // borders += 10;
        curvature = 1;
      }

      var amt = edgelength * curvature + borders;
      return amt;
    };

    this.computeEdgeCostAtVertex = function (v) {
      // compute the edge collapse cost for all edges that start
      // from vertex v.  Since we are only interested in reducing
      // the object by selecting the min cost edge at each step, we
      // only cache the cost of the least cost edge at this vertex
      // (in member variable collapse) as well as the value of the
      // cost (in member variable collapseCost).
      if (v.neighbors.length === 0) {
        // collapse if no neighbors.
        v.collapseNeighbor = null;
        v.collapseCost = -0.01;
        return;
      }

      v.collapseCost = 100000;
      v.collapseNeighbor = null; // search all neighboring edges for "least cost" edge

      for (var i = 0; i < v.neighbors.length; i++) {
        var collapseCost = _this.computeEdgeCollapseCost(v, v.neighbors[i]);

        if (!v.collapseNeighbor) {
          v.collapseNeighbor = v.neighbors[i];
          v.collapseCost = collapseCost;
          v.minCost = collapseCost;
          v.totalCost = 0;
          v.costCount = 0;
        }

        v.costCount++;
        v.totalCost += collapseCost;

        if (collapseCost < v.minCost) {
          v.collapseNeighbor = v.neighbors[i];
          v.minCost = collapseCost;
        }
      } // we average the cost of collapsing at this vertex


      v.collapseCost = v.totalCost / v.costCount; // v.collapseCost = v.minCost;
    };

    this.removeFace = function (f, faces) {
      removeFromArray(faces, f);
      if (f.v1) removeFromArray(f.v1.faces, f);
      if (f.v2) removeFromArray(f.v2.faces, f);
      if (f.v3) removeFromArray(f.v3.faces, f); // TODO optimize this!

      var vs = [f.v1, f.v2, f.v3];
      var v1, v2;

      for (var i = 0; i < 3; i++) {
        v1 = vs[i];
        v2 = vs[(i + 1) % 3];
        if (!v1 || !v2) continue;
        v1.removeIfNonNeighbor(v2);
        v2.removeIfNonNeighbor(v1);
      }
    };

    this.collapse = function (vertices, faces, u, v) {
      // u and v are pointers to vertices of an edge
      // Collapse the edge uv by moving vertex u onto v
      if (!v) {
        // u is a vertex all by itself so just delete it..
        _this.removeVertex(u, vertices);

        return;
      }

      var i;
      var tmpVertices = [];

      for (i = 0; i < u.neighbors.length; i++) {
        tmpVertices.push(u.neighbors[i]);
      } // delete triangles on edge uv:


      for (i = u.faces.length - 1; i >= 0; i--) {
        if (u.faces[i] && u.faces[i].hasVertex(v)) {
          _this.removeFace(u.faces[i], faces);
        }
      } // update remaining triangles to have v instead of u


      for (i = u.faces.length - 1; i >= 0; i--) {
        u.faces[i].replaceVertex(u, v);
      }

      _this.removeVertex(u, vertices); // recompute the edge collapse costs in neighborhood


      for (i = 0; i < tmpVertices.length; i++) {
        _this.computeEdgeCostAtVertex(tmpVertices[i]);
      }
    };

    this.minimumCostEdge = function (vertices) {
      // O(n * n) approach. TODO optimize this
      var least = vertices[0];

      for (var i = 0; i < vertices.length; i++) {
        if (vertices[i].collapseCost < least.collapseCost) {
          least = vertices[i];
        }
      }

      return least;
    };

    this.modify = function (geometry, targetFaces) {
      geometry = geometry.clone();
      var attributes = geometry.attributes; // this modifier can only process indexed and non-indexed geomtries with a position attribute

      for (var name in attributes) {
        if (name !== "position") geometry.deleteAttribute(name);
      }

      geometry = threeStdlib.mergeVertices(geometry); //
      // put data of original geometry in different data structures
      //

      var vertices = [];
      var faces = []; // add vertices

      var positionAttribute = geometry.getAttribute("position");

      for (var i = 0; i < positionAttribute.count; i++) {
        var v = new three.Vector3().fromBufferAttribute(positionAttribute, i);
        var vertex = new Vertex(v, i);
        vertices.push(vertex);
      } // add faces


      var geomIndex = geometry.getIndex();

      if (geomIndex !== null) {
        for (var _i = 0; _i < geomIndex.count; _i += 3) {
          var a = geomIndex.getX(_i);
          var b = geomIndex.getX(_i + 1);
          var c = geomIndex.getX(_i + 2);
          var triangle = new Triangle(vertices[a], vertices[b], vertices[c], a, b, c);
          faces.push(triangle);
        }
      } else {
        for (var _i2 = 0; _i2 < positionAttribute.count; _i2 += 3) {
          var _a = _i2;

          var _b = _i2 + 1;

          var _c = _i2 + 2;

          var _triangle = new Triangle(vertices[_a], vertices[_b], vertices[_c], _a, _b, _c);

          faces.push(_triangle);
        }
      } // compute all edge collapse costs


      for (var _i3 = 0, il = vertices.length; _i3 < il; _i3++) {
        _this.computeEdgeCostAtVertex(vertices[_i3]);
      }

      var nextVertex;
      var z = faces.length - targetFaces;

      while (z--) {
        nextVertex = _this.minimumCostEdge(vertices);

        if (!nextVertex) {
          console.log("THREE.SimplifyModifier: No next vertex");
          break;
        } else if (faces.length <= targetFaces) {
          break;
        } else {
          _this.collapse(vertices, faces, nextVertex, nextVertex.collapseNeighbor);
        }
      } //


      var simplifiedGeometry = new three.BufferGeometry();
      var position = [];
      var index = []; //

      for (var _i4 = 0; _i4 < vertices.length; _i4++) {
        var _vertex = vertices[_i4].position;
        position.push(_vertex.x, _vertex.y, _vertex.z);
      } //


      for (var _i5 = 0; _i5 < faces.length; _i5++) {
        var face = faces[_i5];

        var _a2 = vertices.indexOf(face.v1);

        var _b2 = vertices.indexOf(face.v2);

        var _c2 = vertices.indexOf(face.v3);

        index.push(_a2, _b2, _c2);
      } //


      simplifiedGeometry.setAttribute("position", new three.Float32BufferAttribute(position, 3));
      simplifiedGeometry.setIndex(index);
      return simplifiedGeometry;
    };
  }

  var _proto3 = SimplifyModifier.prototype;

  _proto3.removeVertex = function removeVertex(v, vertices) {
    console.assert(v.faces.length === 0);

    while (v.neighbors.length) {
      var n = v.neighbors.pop();
      removeFromArray(n.neighbors, v);
    }

    removeFromArray(vertices, v);
  };

  return SimplifyModifier;
}();

var generateSimplifiedGeo = function generateSimplifiedGeo(geo, triTarget) {
  var modifier = new SimplifyModifier();
  return modifier.modify(geo, Math.floor(triTarget));
};

function Collidable(props) {
  var children = props.children,
      _props$triLimit = props.triLimit,
      triLimit = _props$triLimit === void 0 ? 1000 : _props$triLimit,
      _props$enabled = props.enabled,
      enabled = _props$enabled === void 0 ? true : _props$enabled,
      _props$hideCollisionM = props.hideCollisionMeshes,
      hideCollisionMeshes = _props$hideCollisionM === void 0 ? false : _props$hideCollisionM;
  var group = react.useRef(null);
  var geoUUID = react.useRef();

  var _useState = react.useState(),
      collisionMeshes = _useState[0],
      setCollisionMeshes = _useState[1];

  var _useState2 = react.useState(),
      collisionGeos = _useState2[0],
      setCollisionGeos = _useState2[1]; // func to create uuid to know when to regenerate


  var createUUID = function createUUID(meshes) {
    return triLimit + "-" + getMeshesUUID(meshes);
  }; // register collision meshes and collision geos


  react.useEffect(function () {
    if (!group.current || !enabled) {
      setCollisionGeos(undefined);
      setCollisionMeshes(undefined);
      geoUUID.current = undefined;
      return;
    } // if the user names the meshes themselves, give them full control


    var colliderMeshes = findColliderMeshes(group.current);

    if (colliderMeshes) {
      if (createUUID(colliderMeshes) === geoUUID.current) return;
      setCollisionMeshes(colliderMeshes);

      var _geos = colliderMeshes.map(function (m) {
        return getTransformedMeshGeo(m, group.current);
      });

      setCollisionGeos(_geos);
      geoUUID.current = createUUID(colliderMeshes);
      return;
    } // otherwise, use all the meshes in the model


    var meshes = getMeshes(group.current);
    if (createUUID(meshes) === geoUUID.current) return;
    setCollisionMeshes(meshes);
    geoUUID.current = createUUID(meshes); // aggregate geos in the model

    var geos = meshes.map(function (m) {
      return getTransformedMeshGeo(m, group.current);
    }); // either use geo directly or bvh version, depending on tri count

    var triCount = geos.reduce(function (c, g) {
      return c + getGeometryTriCount(g);
    }, 0);

    if (triCount < triLimit) {
      setCollisionGeos(geos);
    } else {
      var perc = triLimit / triCount;
      var simpGeos = geos.map(function (g) {
        return generateSimplifiedGeo(g, getGeometryTriCount(g) * perc);
      }).filter(function (g) {
        return g;
      });
      setCollisionGeos(simpGeos);
    }
  }, [children, triLimit, enabled]); // hide or show collision meshes

  react.useEffect(function () {
    if (!collisionMeshes) return;
    collisionMeshes.map(function (collider) {
      return collider.visible = !hideCollisionMeshes;
    });
    return function () {
      collisionMeshes.map(function (collider) {
        return collider.visible = true;
      });
    };
  }, [collisionMeshes, hideCollisionMeshes]);
  return /*#__PURE__*/React.createElement("group", {
    name: "spacesvr-collidable",
    ref: group
  }, children, enabled && collisionGeos && collisionGeos.map(function (geo, i) {
    return /*#__PURE__*/React.createElement(TrimeshCollider, {
      key: geo.uuid,
      geo: geo
    });
  }));
}

function XRInteractable(props) {
  var onClick = props.onClick,
      onHover = props.onHover,
      onUnHover = props.onUnHover,
      children = props.children;
  return /*#__PURE__*/React.createElement("group", {
    name: "spacesvr-interactable"
  }, /*#__PURE__*/React.createElement(xr.Interactive, {
    onHover: onHover,
    onBlur: onUnHover,
    onSelect: onClick ? function (e) {
      return onClick(e.intersection);
    } : undefined
  }, children));
}

var CLICK_TIMEOUT$1 = 0.4; // seconds

var MAX_DRAG = 0.1; // meters

function MobileDesktopInteractable(props) {
  var onClick = props.onClick,
      onHover = props.onHover,
      onUnHover = props.onUnHover,
      passedRaycaster = props.raycaster,
      children = props.children;
  var gl = fiber.useThree(function (state) {
    return state.gl;
  });
  var clock = fiber.useThree(function (state) {
    return state.clock;
  });

  var _useEnvironment = useEnvironment(),
      device = _useEnvironment.device;

  var player = usePlayer();
  var group = react.useRef(null);
  var down = react.useMemo(function () {
    return {
      start: new three.Vector3(),
      time: 0
    };
  }, []);
  var intersection = react.useRef();
  var RAYCASTER = passedRaycaster || player.raycaster;
  var DETECT_HOVER = !!onHover || !!onUnHover; // only detect hover if we have a hover handler

  var getIntersection = react.useCallback(function () {
    if (!group.current) return undefined;
    RAYCASTER.firstHitOnly = true;
    var intersects = RAYCASTER.intersectObject(group.current, true);
    RAYCASTER.firstHitOnly = false;
    return intersects.length > 0 ? intersects[0] : undefined;
  }, [RAYCASTER]); // continuously update the hover state if we have a hover handler

  useLimitedFrame(17, function () {
    if (!group.current || !DETECT_HOVER) return;
    var inter = getIntersection();

    if (inter) {
      if (!intersection.current) {
        if (onHover) onHover();
      }

      intersection.current = inter;
    } else {
      if (intersection.current) {
        intersection.current = undefined;
        if (onUnHover) onUnHover();
      }
    }
  }); // enable bvh raycasting for children

  react.useEffect(function () {
    if (!group.current) return;
    group.current.traverse(function (obj) {
      var mesh = obj;
      if (mesh.isMesh) enableBVHRaycast(mesh, 50);
    });
  }, []);
  react.useEffect(function () {
    var startPress = function startPress() {
      RAYCASTER.ray.at(1, down.start);
      down.time = clock.elapsedTime;
    };

    var endPress = function endPress() {
      if (!onClick || !group.current) return;
      var newPos = RAYCASTER.ray.at(1, new three.Vector3());
      var dist = down.start.distanceTo(newPos);
      var timeDiff = clock.elapsedTime - down.time;
      if (dist > MAX_DRAG || timeDiff > CLICK_TIMEOUT$1) return; // either look for hover state or re-do raycast

      if (DETECT_HOVER) {
        if (intersection.current) onClick(intersection.current);
      } else {
        var inter = getIntersection();
        if (inter) onClick(inter);
      }
    };

    var startev = device.mobile ? "touchstart" : "mousedown";
    var endev = device.mobile ? "touchend" : "mouseup";
    gl.domElement.addEventListener(startev, startPress);
    gl.domElement.addEventListener(endev, endPress);
    return function () {
      gl.domElement.removeEventListener(startev, startPress);
      gl.domElement.removeEventListener(endev, endPress);
    };
  }, [DETECT_HOVER, RAYCASTER, clock, device.mobile, down, getIntersection, gl.domElement, onClick]);
  return /*#__PURE__*/React.createElement("group", {
    name: "spacesvr-interactable",
    ref: group
  }, children);
}

/**
 * Interactable adds on click and hover methods to any group of Object3D's.
 */
function Interactable(props) {
  var _useEnvironment = useEnvironment(),
      device = _useEnvironment.device;

  if (device.xr) return /*#__PURE__*/React.createElement(XRInteractable, props);
  return /*#__PURE__*/React.createElement(MobileDesktopInteractable, props);
}

var ToolbeltContext = /*#__PURE__*/react.createContext({});
var useToolbelt = function useToolbelt() {
  return react.useContext(ToolbeltContext);
};
var useToolbeltState = function useToolbeltState(showOnSpawn) {
  var _useState = react.useState(function () {
    return new three.Scene();
  }),
      hudScene = _useState[0];

  var rerender = useRerender();
  var tools = react.useMemo(function () {
    return [];
  }, []);

  var _useState2 = react.useState(showOnSpawn ? 0 : undefined),
      activeIndex = _useState2[0],
      setActiveIndex = _useState2[1];

  var lastActiveIndex = react.useRef(0);

  var _useState3 = react.useState("right"),
      direction = _useState3[0],
      setDirection = _useState3[1];

  var grant = react.useCallback(function (name, icon, orderIndex) {
    // make sure no tool with same name or key exists
    if (tools.find(function (tool) {
      return tool.name === name;
    })) {
      console.error("Toolbelt: Tool with same name already exists: " + name);
      return;
    }

    if (tools.length === 0) rerender();
    var tool = {
      name: name,
      icon: icon,
      orderIndex: orderIndex || 0
    };
    tools.push(tool); // sort tools by orderIndex, then by name

    tools.sort(function (a, b) {
      return a.orderIndex !== b.orderIndex ? a.orderIndex - b.orderIndex : a.name.localeCompare(b.name);
    });
  }, [tools]);
  var revoke = react.useCallback(function (name) {
    var tool = tools.find(function (tool) {
      return tool.name === name;
    });

    if (tool) {
      tools.splice(tools.indexOf(tool), 1);
    }
  }, [tools]);
  react.useEffect(function () {
    if (activeIndex !== undefined) lastActiveIndex.current = activeIndex;
  }, [activeIndex]);
  var next = react.useCallback(function () {
    setDirection("right");

    if (tools.length === 1) {
      setActiveIndex(function (actInd) {
        return actInd === undefined ? 0 : undefined;
      });
    } else {
      setActiveIndex(function (actInd) {
        return actInd !== undefined ? (actInd + 1) % tools.length : 0;
      });
    }
  }, [tools]);
  var prev = react.useCallback(function () {
    setDirection("left");

    if (tools.length === 1) {
      setActiveIndex(function (actInd) {
        return actInd === undefined ? 0 : undefined;
      });
    } else {
      setActiveIndex(function (actInd) {
        return actInd !== undefined ? (actInd - 1 + tools.length) % tools.length : 0;
      });
    }
  }, [tools]);
  var hide = react.useCallback(function () {
    setActiveIndex(undefined);
  }, []);
  var show = react.useCallback(function () {
    setActiveIndex(function (oldInd) {
      return oldInd === undefined ? lastActiveIndex.current : oldInd;
    });
  }, []);
  var setActiveTool = react.useCallback(function (name) {
    var index = tools.findIndex(function (tool) {
      return tool.name === name;
    });
    if (index !== -1) setActiveIndex(index);
  }, [tools]);
  return {
    tools: tools,
    activeTool: activeIndex !== undefined ? tools[activeIndex] : undefined,
    grant: grant,
    revoke: revoke,
    hide: hide,
    next: next,
    prev: prev,
    show: show,
    activeIndex: activeIndex,
    setActiveIndex: setActiveIndex,
    setActiveTool: setActiveTool,
    hudScene: hudScene,
    direction: direction,
    setDirection: setDirection
  };
};

/**
 * A hook that allows you to toggle a boolean value.
 * @param delay time in ms
 */

var useDelayedToggle = function useDelayedToggle(delay) {
  if (delay === void 0) {
    delay = 1000;
  }

  var timeoutId = react.useRef(null);

  var _useState = react.useState(false),
      active = _useState[0],
      setActiveState = _useState[1];

  var setActive = react.useCallback(function () {
    if (timeoutId.current !== null) {
      clearTimeout(timeoutId.current);
    }

    setActiveState(true);
    timeoutId.current = setTimeout(function () {
      setActiveState(false);
    }, delay);
  }, [delay]);
  react.useEffect(function () {
    return function () {
      if (timeoutId.current !== null) {
        clearTimeout(timeoutId.current);
      }
    };
  }, []);
  return {
    active: active,
    setActive: setActive
  };
};

var _templateObject$1, _templateObject2$1, _templateObject3$1, _templateObject4$1, _templateObject5$1;
var OUTER_PADDING = 40;
var INNER_PADDING = 10;
var FIXED_PADDING = OUTER_PADDING - INNER_PADDING;
var OUTER_BORDER_RADIUS = 25;
var Container = styled__default["default"].div(_templateObject$1 || (_templateObject$1 = _taggedTemplateLiteralLoose__default["default"](["\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  z-index: 2;\n  padding: ", "px ", "px 0 ", "px;\n  border-radius: ", "px;\n  pointer-events: ", ";\n\n  display: flex;\n  max-width: calc(100% - 80px);\n  flex-basis: calc(100% - 80px);\n  flex-wrap: wrap;\n  box-sizing: border-box;\n  justify-content: center;\n  width: max-content;\n  max-height: 100%;\n  overflow-y: auto;\n\n  opacity: ", ";\n  ", ";\n\n  @media screen and (max-width: 600px) {\n    padding: ", "px 10px ", "px 10px;\n  }\n\n  &:after {\n    content: \"\";\n    position: absolute;\n    top: 0;\n    left: 0;\n    right: 0;\n    bottom: 0;\n    background-color: hsl(0deg 0% 90% / 50%);\n    border-radius: ", "px;\n    backdrop-filter: blur(15px);\n    z-index: -1;\n  }\n"])), FIXED_PADDING, FIXED_PADDING, FIXED_PADDING, OUTER_BORDER_RADIUS, function (props) {
  return props.open ? "all" : "none";
}, function (props) {
  return props.open ? 1 : 0;
}, function (props) {
  return props.open ? "transition: opacity 0.075s ease-in-out;" : "transition: opacity 0.4s ease-in-out;";
}, FIXED_PADDING, FIXED_PADDING, OUTER_BORDER_RADIUS);
var ToolItem = styled__default["default"].div(_templateObject2$1 || (_templateObject2$1 = _taggedTemplateLiteralLoose__default["default"](["\n  position: relative;\n  width: 125px;\n  height: 125px;\n  border-radius: 10px;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  z-index: 1;\n  margin: 10px 10px ", "px 10px;\n  \n  @media screen and (max-width: 600px) {\n    width: 90px;\n    height: 90px;\n  }\n  \n  &:before {\n    ", "\n    content: \"\";\n    position: absolute;\n    box-sizing: content-box;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n    width: 100%;\n    height: 100%;\n    padding: ", "px;\n    background: hsl(0deg 0% 50% / 50%);\n    border-radius: 10px;\n    z-index: -2;\n  }\n  \n  // place text directly below the main box\n  &:after {\n    ", "\n    content: \"", "\";\n    position: absolute;\n    bottom: -", "px;\n    left: 50%;\n    transform: translateX(-50%);\n    font-size: 1.1rem;\n    font-family: sans-serif;\n    padding: 4px 10px;\n    white-space: nowrap;\n    text-overflow: ellipsis;\n    overflow: hidden;\n    width: 100%;\n    text-align: center;\n    color: #222;\n    \n\n    @media screen and (max-width: 600px) {\n      font-size: 0.9rem;\n    }\n  }\n"])), OUTER_PADDING, function (props) {
  return !props.active && "display: none;";
}, INNER_PADDING, function (props) {
  return !props.active && "display: none;";
}, function (props) {
  return props.title;
}, OUTER_PADDING);
var LetterContent = styled__default["default"].div(_templateObject3$1 || (_templateObject3$1 = _taggedTemplateLiteralLoose__default["default"](["\n  width: 100%;\n  height: 100%;\n  background: oklch(75% 0.132 ", ");\n  font-size: 4rem;\n  display: flex;\n  justify-content: center;\n  align-items: center;\n  font-family: sans-serif;\n  border-radius: 10px;\n  color: #444;\n\n  @media screen and (max-width: 600px) {\n    font-size: 3rem;\n  }\n"])), function (props) {
  return props.perc * 360;
});
var ImageContent = styled__default["default"].img(_templateObject4$1 || (_templateObject4$1 = _taggedTemplateLiteralLoose__default["default"](["\n  width: 100%;\n  height: 100%;\n  object-fit: contain;\n"])));
var NoneItem = styled__default["default"].div(_templateObject5$1 || (_templateObject5$1 = _taggedTemplateLiteralLoose__default["default"](["\n  display: inline-block;\n  position: relative;\n  border: 6px solid #444;\n  border-radius: 50%;\n  width: 80px;\n  height: 80px;\n  box-sizing: content-box;\n\n  &::after {\n    content: \"\";\n    width: 84px;\n    height: 6px;\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    background-color: #444;\n    transform: translate(-50%, -50%) rotate(45deg);\n  }\n"])));
function ToolSwitcher() {
  var _useEnvironment = useEnvironment(),
      paused = _useEnvironment.paused,
      containerRef = _useEnvironment.containerRef;

  var _useToolbelt = useToolbelt(),
      next = _useToolbelt.next,
      prev = _useToolbelt.prev,
      activeIndex = _useToolbelt.activeIndex,
      setActiveIndex = _useToolbelt.setActiveIndex,
      tools = _useToolbelt.tools,
      setDirection = _useToolbelt.setDirection;

  var _useThree = fiber.useThree(),
      size = _useThree.size,
      gl = _useThree.gl;

  var _useDelayedToggle = useDelayedToggle(850),
      showing = _useDelayedToggle.active,
      setShowing = _useDelayedToggle.setActive;

  var registered = react.useRef(false);
  var DETECT_RANGE_X = screen.width * 0.05;
  var DRAG_RANGE_X = screen.width * 0.08;
  var DETECT_RANGE_Y = screen.height * 0.5;
  var valid = react.useRef(false);
  useDrag({
    onStart: function onStart(_ref) {
      var e = _ref.e,
          touch = _ref.touch;
      valid.current = false;
      var inSideEdge = Math.min(touch.clientX, size.width - touch.clientX) < DETECT_RANGE_X;
      var inTopThird = touch.clientY < DETECT_RANGE_Y; // ignore if not in top third or side edge

      if (!inSideEdge || !inTopThird) return;
      valid.current = true;
      registered.current = false;
      e.preventDefault();
      e.stopPropagation();
      e.stopImmediatePropagation();
    },
    onMove: function onMove(_ref2) {
      var delta = _ref2.delta;
      if (!valid.current || registered.current) return;

      if (Math.abs(delta.x) > DRAG_RANGE_X) {
        registered.current = true;

        if (delta.x > 0) {
          setShowing();
          next();
        } else {
          setShowing();
          prev();
        }
      }
    }
  }, gl.domElement, [screen.width, screen.height, next, prev]);
  react.useEffect(function () {
    var handleKeypress = function handleKeypress(e) {
      if (isTyping() || e.metaKey || e.ctrlKey || paused) return;

      if (e.key == "Tab") {
        if (e.shiftKey) {
          setDirection("left");
          setShowing();
          if (activeIndex === undefined) setActiveIndex(tools.length - 1);else if (activeIndex === 0) setActiveIndex(undefined);else setActiveIndex((activeIndex - 1 + tools.length) % tools.length);
        } else {
          setDirection("right");
          setShowing();
          if (activeIndex === undefined) setActiveIndex(0);else if (activeIndex === tools.length - 1) setActiveIndex(undefined);else setActiveIndex((activeIndex + 1) % tools.length);
        }

        e.preventDefault();
      }
    };

    document.addEventListener("keydown", handleKeypress);
    return function () {
      return document.removeEventListener("keydown", handleKeypress);
    };
  }, [activeIndex, paused, setActiveIndex, setDirection, setShowing, tools]);
  var clickItem = react.useCallback(function (index) {
    setShowing();
    setActiveIndex(index);
  }, [setActiveIndex, setShowing]);
  return /*#__PURE__*/React.createElement(drei.Html, null, /*#__PURE__*/reactDom.createPortal( /*#__PURE__*/React.createElement(Container, {
    open: showing
  }, /*#__PURE__*/React.createElement(ToolItem, {
    title: "None",
    active: activeIndex === undefined,
    onClick: function onClick() {
      return clickItem(undefined);
    }
  }, /*#__PURE__*/React.createElement(NoneItem, null)), tools.map(function (tool, i) {
    return /*#__PURE__*/React.createElement(ToolItem, {
      key: tool.name + "-" + i,
      title: tool.name,
      active: activeIndex === i,
      onClick: function onClick() {
        return clickItem(i);
      }
    }, tool.icon ? /*#__PURE__*/React.createElement(ImageContent, {
      src: tool.icon
    }) : /*#__PURE__*/React.createElement(LetterContent, {
      perc: new Idea().updateFromText(tool.name).mediation
    }, tool.name.substring(0, 1)));
  })), containerRef.current));
}

function Lights() {
  return /*#__PURE__*/React.createElement("group", {
    name: "lights"
  }, /*#__PURE__*/React.createElement("ambientLight", {
    intensity: Math.PI * 0.5
  }), /*#__PURE__*/React.createElement("pointLight", {
    intensity: Math.PI * 0.5
  }));
}

function _createForOfIteratorHelperLoose$8(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray$8(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$8(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$8(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$8(o, minLen); }

function _arrayLikeToArray$8(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function WorldLights(props) {
  var _props$enabled = props.enabled,
      enabled = _props$enabled === void 0 ? true : _props$enabled,
      directional = props.directional;

  var _useThree = fiber.useThree(),
      scene = _useThree.scene;

  var group = react.useRef(null);
  var toolbelt = useToolbelt();
  var rerender = useRerender();
  var trackedLights = react.useRef([]);
  var renderedLights = react.useRef([]);
  useLimitedFrame(1 / 2, function () {
    var sceneLights = [];
    scene.traverse(function (obj) {
      if (obj instanceof three.Light && (!directional || obj instanceof three.AmbientLight)) {
        sceneLights.push(obj);
      }
    });
    var changed = false;

    var _loop = function _loop() {
      var light = _sceneLights[_i];

      // if light is not rendered, register it
      if (!renderedLights.current.find(function (obj) {
        return obj.userData.uuid === light.uuid;
      })) {
        var newLight = light.clone();
        newLight.userData.uuid = light.uuid;
        renderedLights.current.push(newLight);
        changed = true;
      }
    };

    for (var _i = 0, _sceneLights = sceneLights; _i < _sceneLights.length; _i++) {
      _loop();
    } // if light is rendered but not in scene, unregister it


    var _loop2 = function _loop2() {
      var light = _step.value;

      if (!sceneLights.find(function (obj) {
        return obj.uuid === light.userData.uuid;
      })) {
        renderedLights.current.splice(renderedLights.current.indexOf(light), 1);
        light.dispose();
        changed = true;
      }
    };

    for (var _iterator = _createForOfIteratorHelperLoose$8(renderedLights.current), _step; !(_step = _iterator()).done;) {
      _loop2();
    }

    if (changed) {
      rerender();
      trackedLights.current = sceneLights;
    }
  });
  useLimitedFrame(30, function (_ref) {
    var camera = _ref.camera;
    if (!enabled || !group.current) return;
    group.current.position.copy(camera.position);
    renderedLights.current.forEach(function (light) {
      var trackedLight = trackedLights.current.find(function (li) {
        return li.uuid === light.userData.uuid;
      });
      if (!trackedLight) return;
      light.matrixWorld.copy(trackedLight.matrixWorld);
    });
  });
  return /*#__PURE__*/React.createElement(React.Fragment, null, fiber.createPortal( /*#__PURE__*/React.createElement("group", {
    name: "world-lights",
    ref: group
  }, renderedLights.current.map(function (light) {
    return /*#__PURE__*/React.createElement("primitive", {
      object: light,
      key: light.uuid
    });
  })), toolbelt.hudScene));
}

function Toolbelt(props) {
  var children = props.children,
      _props$showOnSpawn = props.showOnSpawn,
      showOnSpawn = _props$showOnSpawn === void 0 ? true : _props$showOnSpawn,
      _props$worldLights = props.worldLights,
      worldLights = _props$worldLights === void 0 ? true : _props$worldLights,
      _props$localLights = props.localLights,
      localLights = _props$localLights === void 0 ? true : _props$localLights;

  var _useThree = fiber.useThree(),
      camera = _useThree.camera;

  var value = useToolbeltState(showOnSpawn);
  var hudScene = value.hudScene; // hud render loop, use copied camera to render at 0,0,0

  var _useState = react.useState(function () {
    return camera.clone();
  }),
      camClone = _useState[0];

  fiber.useFrame(function (_ref) {
    var gl = _ref.gl;
    var _cam = camera;
    camClone.position.set(0, 0, 0);
    camClone.quaternion.copy(_cam.quaternion);
    camClone.near = _cam.near;
    camClone.far = _cam.far;
    camClone.aspect = _cam.aspect;
    camClone.fov = _cam.fov;
    camClone.updateProjectionMatrix(); // for all intents and purposes, the hud items are placed in real world coordinates
    // this is very important for raycasting

    hudScene.position.set(0, 0, 0);
    gl.autoClear = false;
    gl.clearDepth();
    gl.render(hudScene, camClone);
    hudScene.position.copy(camera.position);
    hudScene.updateMatrixWorld(true);
  }, 100);
  return /*#__PURE__*/React.createElement(ToolbeltContext.Provider, {
    value: value
  }, /*#__PURE__*/React.createElement(ToolSwitcher, null), localLights && fiber.createPortal( /*#__PURE__*/React.createElement(Lights, null), hudScene), worldLights && /*#__PURE__*/React.createElement(WorldLights, null), children);
}

var dummy$1 = new three.Quaternion(); // taken from https://gist.github.com/sketchpunk/3568150a04b973430dfe8fd29bf470c8

var QuaterionSpring = /*#__PURE__*/function () {
  function QuaterionSpring(damping, stiffness) {
    if (damping === void 0) {
      damping = 5;
    }

    if (stiffness === void 0) {
      stiffness = 30;
    }

    this.velocity = new Float32Array(4);
    this.stiffness = stiffness;
    this.damping = damping;
  }

  var _proto = QuaterionSpring.prototype;

  _proto._velLenSqr = function _velLenSqr() {
    return Math.pow(this.velocity[0], 2) + Math.pow(this.velocity[1], 2) + Math.pow(this.velocity[2], 2) + Math.pow(this.velocity[3], 2);
  } // Harmonic oscillation
  // https://stackoverflow.com/questions/44688112/spring-physics-applied-to-quaternions-using-python
  ;

  _proto.oscillationStep = function oscillationStep(cq, target, dt) {
    // Check when the spring is done.
    var dot = cq.dot(target);

    if (dot >= 0.9999 && this._velLenSqr() < 0.000001) {
      cq.copy(target);
      return;
    }

    var tq = dummy$1;

    if (dot < 0) {
      // Use the closest rotation
      tq.x = -target.x;
      tq.y = -target.y;
      tq.z = -target.z;
      tq.w = -target.w;
    } else {
      tq.copy(target);
    }

    this.velocity[0] += (-this.stiffness * (cq.x - tq.x) - this.damping * this.velocity[0]) * dt;
    this.velocity[1] += (-this.stiffness * (cq.y - tq.y) - this.damping * this.velocity[1]) * dt;
    this.velocity[2] += (-this.stiffness * (cq.z - tq.z) - this.damping * this.velocity[2]) * dt;
    this.velocity[3] += (-this.stiffness * (cq.w - tq.w) - this.damping * this.velocity[3]) * dt;
    cq.x += this.velocity[0] * dt;
    cq.y += this.velocity[1] * dt;
    cq.z += this.velocity[2] * dt;
    cq.w += this.velocity[3] * dt;
    cq.normalize();
  } // Critically Damped Spring
  ;

  _proto.criticallyStep = function criticallyStep(cq, target, dt) {
    // Check when the spring is done.
    var dot = cq.dot(target);

    if (dot >= 0.9999 && this._velLenSqr() < 0.000001) {
      cq.copy(target);
      return;
    }

    var tq = dummy$1;

    if (dot < 0) {
      // Use the closest rotation
      tq.x = -target.x;
      tq.y = -target.y;
      tq.z = -target.z;
      tq.w = -target.w;
    } else {
      tq.copy(target);
    }

    var dSqrDt = this.damping * this.damping * dt,
        n2 = 1 + this.damping * dt,
        n2Sqr = n2 * n2;
    this.velocity[0] = (this.velocity[0] - (cq.x - tq.x) * dSqrDt) / n2Sqr;
    this.velocity[1] = (this.velocity[1] - (cq.y - tq.y) * dSqrDt) / n2Sqr;
    this.velocity[2] = (this.velocity[2] - (cq.z - tq.z) * dSqrDt) / n2Sqr;
    this.velocity[3] = (this.velocity[3] - (cq.w - tq.w) * dSqrDt) / n2Sqr;
    cq.x += this.velocity[0] * dt;
    cq.y += this.velocity[1] * dt;
    cq.z += this.velocity[2] * dt;
    cq.w += this.velocity[3] * dt;
    cq.normalize();
    return cq;
  };

  return QuaterionSpring;
}();

/**
 * Place the children in front of the camera with some sway
 * 1. I tried springing the quaternion, but it's not continuous and causes a jump
 * 2. I found a continuous quaternion spring, but it was not tight enough https://gist.github.com/sketchpunk/3568150a04b973430dfe8fd29bf470c8
 * 3. solution was to move tool in screen spacing by springing pos value offsets based on rotation velocity
 *    springed quat rotation still used for range
 *
 * @param props
 * @constructor
 */
function HUD(props) {
  var children = props.children,
      pos = props.pos,
      _props$pinY = props.pinY,
      pinY = _props$pinY === void 0 ? false : _props$pinY,
      distance = props.distance,
      _props$range = props.range,
      range = _props$range === void 0 ? 0 : _props$range,
      bobStrength = props.bobStrength;

  var _usePlayer = usePlayer(),
      velocity = _usePlayer.velocity;

  var t = 0.0001;
  var group = react.useRef(null);

  var _useState = react.useState(new three.Vector2()),
      targetPos = _useState[0];

  var _useState2 = react.useState(new three.Vector2().fromArray(pos)),
      lerpedPos = _useState2[0];

  var _useState3 = react.useState(new three.Quaternion()),
      lerpedQuat = _useState3[0];

  var _useState4 = react.useState(new three.Quaternion()),
      targetQuat = _useState4[0];

  var _useState5 = react.useState(new three.Quaternion()),
      lastQuat = _useState5[0];

  var _useState6 = react.useState(new three.Euler(0, 0, 0, "YXZ")),
      lastEuler = _useState6[0];

  var _useState7 = react.useState(new three.Euler(0, 0, 0, "YXZ")),
      thisEuler = _useState7[0];

  var _useState8 = react.useState(new three.Quaternion()),
      dummy1 = _useState8[0];

  var _useState9 = react.useState(new three.Quaternion()),
      dummy2 = _useState9[0];

  var _useState10 = react.useState(new three.Vector2()),
      hud = _useState10[0];

  var _useSpring = three$1.useSpring(function () {
    return {
      offset: [0, 0],
      config: three$1.config.stiff
    };
  }),
      spring = _useSpring[0],
      set = _useSpring[1];

  var qs = react.useMemo(function () {
    return new QuaterionSpring(50, 100);
  }, []);
  fiber.useFrame(function (_ref, delta) {
    var camera = _ref.camera,
        clock = _ref.clock;
    if (!group.current) return;
    var alpha = 1 - Math.pow(t, delta); // apply passes pos and offset pos

    var off = spring.offset.get();
    targetPos.fromArray(pos);
    targetPos.x += off[0] || 0;
    targetPos.y += off[1] || 0;
    lerpedPos.lerp(targetPos, alpha); // calculate x position based on camera and screen width

    getHudPos(lerpedPos, camera, distance, hud);
    group.current.position.set(hud.x, hud.y, -distance); // calculate rotation velocities about the respective ROTATION axis (not screen space)

    dummy1.copy(lastQuat);
    dummy2.copy(camera.quaternion);
    thisEuler.setFromQuaternion(camera.quaternion);
    var y_axis_vel = dummy1.multiply(dummy2.invert()).y / (delta || 0.00001);
    var x_axis_vel = (thisEuler.x - lastEuler.x) / (delta || 0.00001); // implement range

    var RANGE_SET = range > 0;

    if (!RANGE_SET) {
      lerpedQuat.copy(camera.quaternion);
    } else {
      // find angle along y axis
      dummy1.copy(lerpedQuat);
      dummy1.x = 0;
      dummy1.z = 0;
      dummy1.normalize();
      dummy2.copy(camera.quaternion);
      dummy2.x = 0;
      dummy2.z = 0;
      dummy2.normalize();
      var angle = dummy1.angleTo(dummy2); // if out of range, move it back

      if (angle > range) {
        var diff = angle - range;
        targetQuat.copy(lerpedQuat);
        targetQuat.rotateTowards(camera.quaternion, diff);

        if (!pinY) {
          targetQuat.x = 0;
          targetQuat.z = 0;
          targetQuat.normalize();
        }
      } else {
        // disable offsets if moving camera within range
        x_axis_vel = 0;
        y_axis_vel = 0;
      }

      qs.criticallyStep(lerpedQuat, targetQuat, delta);
    } // bob a bit based on player velocity


    var vel_len = velocity.get().length() > 1 ? 1 : 0;
    var strength = bobStrength || Math.max(lerpedPos.length(), 0.05);
    x_axis_vel += Math.sin(clock.elapsedTime * 15) * vel_len * 0.2 * strength;
    y_axis_vel += Math.cos(clock.elapsedTime * 20 + 12) * vel_len * 0.1 * strength; // set spring targets based on velocities

    var scale_ang = 0.1;
    var max_ang = 0.3;
    var x_off = three.MathUtils.clamp(-y_axis_vel * scale_ang, -max_ang, max_ang);
    var y_off = three.MathUtils.clamp(-x_axis_vel * scale_ang, -max_ang, max_ang);
    set({
      offset: [x_off, y_off]
    }); // range dependent, move items to camera quat

    group.current.position.applyQuaternion(lerpedQuat); // needed so that children positions are applied in screen space
    // should probably be moved to draggable .. ? idk, maybe the supposition is that children of hud are in screen space

    group.current.quaternion.copy(camera.quaternion); // update last values

    lastQuat.copy(camera.quaternion);
    lastEuler.setFromQuaternion(camera.quaternion);
  });
  return /*#__PURE__*/React.createElement("group", {
    name: "spacesvr-hud",
    ref: group
  }, children);
}

function Draggable(props) {
  var set = props.set,
      distance = props.distance,
      enabled = props.enabled,
      children = props.children;
  var toolbelt = useToolbelt();

  var _useThree = fiber.useThree(),
      size = _useThree.size,
      gl = _useThree.gl;

  var _useEnvironment = useEnvironment(),
      device = _useEnvironment.device;

  var _usePlayer = usePlayer(),
      raycaster = _usePlayer.raycaster;

  var group = react.useRef(null);
  var DOWN_SWIPE_DIST = size.height * 0.28;
  var SIDE_SWIPE_DIST = size.width * 0.3;
  var valid = react.useRef(false);
  useDrag({
    onStart: function onStart(_ref) {
      var e = _ref.e;
      valid.current = false;
      if (!group.current || !device.mobile || !enabled) return;
      var intersections = raycaster.intersectObject(group.current, true);

      if (intersections.length > 0) {
        valid.current = true;
        e.stopPropagation();
      }
    },
    onMove: function onMove(_ref2) {
      var delta = _ref2.delta;
      if (!valid.current) return;
      set({
        pos: [delta.x * 0.003 * distance * 0.7, -delta.y * 0.003 * distance * (delta.y < 0 ? 0.15 : 0.5), 0]
      });
    },
    onEnd: function onEnd(_ref3) {
      var delta = _ref3.delta;
      if (!valid.current) return;

      if (delta.y > DOWN_SWIPE_DIST) {
        toolbelt.hide();
      } else if (Math.abs(delta.x) > SIDE_SWIPE_DIST) {
        if (delta.x > 0) {
          toolbelt.next();
        } else {
          toolbelt.prev();
        }
      }

      set({
        pos: [0, 0, 0]
      });
      valid.current = false;
    }
  }, gl.domElement, [device.mobile, enabled, toolbelt.hide, toolbelt.next, toolbelt.prev]);
  return /*#__PURE__*/React.createElement("group", {
    ref: group
  }, children);
}

/**
 * The logic to show a tool on screen and move it depending on the active tool
 */
function OnScreen(props) {
  var distance = props.distance,
      name = props.name,
      pos = props.pos,
      disableDraggable = props.disableDraggable,
      children = props.children;
  var toolbelt = useToolbelt();
  var camera = fiber.useThree(function (state) {
    return state.camera;
  });
  var TOOL = toolbelt.tools.find(function (t) {
    return t.name == name;
  });
  var TOOL_INDEX = TOOL ? toolbelt.tools.indexOf(TOOL) : undefined;
  var ENABLED = toolbelt.activeIndex === TOOL_INDEX;

  var _useSpring = three$1.useSpring(function () {
    return {
      pos: [0, 0, 0],
      config: {
        mass: 4,
        friction: 90,
        tension: 800
      }
    };
  }),
      spring = _useSpring[0],
      set = _useSpring[1]; // animate position on tool switches


  var lastActiveIndex = react.useRef();
  react.useEffect(function () {
    if (lastActiveIndex.current === toolbelt.activeIndex) return;
    lastActiveIndex.current = toolbelt.activeIndex;
    if (TOOL_INDEX === undefined) return;
    var _cam = camera;
    var AMT = 1.5;

    if (ENABLED) {
      // show it
      if (toolbelt.direction !== "up") {
        // unless the tool was hidden as will fly in bottom to top,
        var _getHudPos = getHudPos([-AMT, 0], _cam, distance),
            leftX = _getHudPos.x;

        var _getHudPos2 = getHudPos([AMT, 0], _cam, distance),
            rightX = _getHudPos2.x;

        var _getHudPos3 = getHudPos(pos, _cam, distance),
            x = _getHudPos3.x;

        var swipeInX = toolbelt.direction === "left" ? rightX - x : leftX + x;
        spring.pos.update({
          immediate: true
        });
        set({
          pos: [swipeInX, 0, distance]
        });
        spring.pos.finish();
        spring.pos.update({
          immediate: false
        });
      }

      set({
        pos: [0, 0, 0]
      });
    } else {
      // swipe it away
      var _getHudPos4 = getHudPos([-AMT, 0], _cam, distance * 2),
          _leftX = _getHudPos4.x;

      var _getHudPos5 = getHudPos([AMT, 0], _cam, distance * 2),
          _rightX = _getHudPos5.x;

      var _getHudPos6 = getHudPos(pos, _cam, distance),
          _x = _getHudPos6.x;

      var swipeOutX = (toolbelt.direction === "left" ? _leftX : _rightX) - _x;
      set({
        pos: [swipeOutX, 0, 0]
      });
    }
  }, [ENABLED, TOOL_INDEX, camera, distance, pos, set, spring.pos, toolbelt.activeIndex, toolbelt.activeTool, toolbelt.direction]);
  return /*#__PURE__*/React.createElement(three$1.animated.group, {
    position: spring.pos,
    name: "onscreen"
  }, /*#__PURE__*/React.createElement(Draggable, {
    set: set,
    distance: distance,
    enabled: ENABLED && !disableDraggable
  }, children));
}

function FacePlayer(props) {
  var children = props.children,
      _props$enabled = props.enabled,
      enabled = _props$enabled === void 0 ? true : _props$enabled,
      _props$lockX = props.lockX,
      lockX = _props$lockX === void 0 ? false : _props$lockX,
      _props$lockY = props.lockY,
      lockY = _props$lockY === void 0 ? false : _props$lockY,
      _props$lockZ = props.lockZ,
      lockZ = _props$lockZ === void 0 ? false : _props$lockZ;
  var group = react.useRef(null);

  var _useState = react.useState(new three.Euler()),
      prev = _useState[0];

  useLimitedFrame(50, function (_ref) {
    var camera = _ref.camera;
    if (!group.current) return;

    if (!enabled) {
      group.current.rotation.set(0, 0, 0);
    } else {
      prev.copy(group.current.rotation);
      group.current.lookAt(camera.position);
      if (lockX) group.current.rotation.x = prev.x;
      if (lockY) group.current.rotation.y = prev.y;
      if (lockZ) group.current.rotation.z = prev.z;
    }
  });
  return /*#__PURE__*/React.createElement("group", {
    name: "spacesvr-faceplayer",
    ref: group
  }, children);
}

// if the children suspense, this will call set done once suspense is resolved
function LifecycleDetector(props) {
  var didMount = props.didMount,
      setMounted = props.setMounted;
  didMount.current = true;
  react.useEffect(function () {
    return function () {
      setMounted(true);
    };
  }, []);
  return null;
}

// adapted from https://github.com/pmndrs/drei/blob/master/src/core/Preload.tsx
function ToolPreload(props) {
  var setPreloadDone = props.setPreloadDone,
      children = props.children;
  var gl = fiber.useThree(function (_ref) {
    var gl = _ref.gl;
    return gl;
  });
  var camera = fiber.useThree(function (_ref2) {
    var camera = _ref2.camera;
    return camera;
  });

  var _useToolbelt = useToolbelt(),
      hudScene = _useToolbelt.hudScene;

  var didMount = react.useRef(false);

  var _useState = react.useState(true),
      firstRender = _useState[0],
      setFirstRender = _useState[1];

  var _useState2 = react.useState(false),
      mounted = _useState2[0],
      setMounted = _useState2[1]; // if the children don't suspense, the second render will detect that and mark it as finished


  react.useEffect(function () {
    if (firstRender) {
      setFirstRender(false);
      return;
    }

    if (!didMount.current) {
      // mounted with no suspense trigger, so UnloadComponent will never be called
      setMounted(true);
    }
  }, [firstRender]); // Layout effect because it must run before React commits

  react.useLayoutEffect(function () {
    if (!mounted) return; // compile the scene, then hit it with a cube camera

    gl.compile(hudScene, camera);
    var cubeRenderTarget = new three.WebGLCubeRenderTarget(128);
    var cubeCamera = new three.CubeCamera(0.01, 100000, cubeRenderTarget);
    cubeCamera.update(gl, hudScene);
    cubeRenderTarget.dispose();
    setPreloadDone(true);
  }, [camera, gl, hudScene, mounted, setPreloadDone]);
  return fiber.createPortal( /*#__PURE__*/React.createElement("group", {
    name: "tool-preload"
  }, /*#__PURE__*/React.createElement(react.Suspense, {
    fallback: /*#__PURE__*/React.createElement(LifecycleDetector, {
      didMount: didMount,
      setMounted: setMounted
    })
  }, children)), hudScene);
}

/**
 * Tool modifier will place its children in constant view of the camera
 *
 * pos will determine relative placement on [x, y] axis
 * face will make item face the player (defaults to true)
 *
 * @param props
 * @constructor
 */
function Tool(props) {
  var children = props.children,
      name = props.name,
      icon = props.icon,
      _props$pos = props.pos,
      pos = _props$pos === void 0 ? [0, 0] : _props$pos,
      _props$face = props.face,
      face = _props$face === void 0 ? true : _props$face,
      _props$pinY = props.pinY,
      pinY = _props$pinY === void 0 ? false : _props$pinY,
      range = props.range,
      bobStrength = props.bobStrength,
      orderIndex = props.orderIndex,
      _props$disableDraggab = props.disableDraggable,
      disableDraggable = _props$disableDraggab === void 0 ? false : _props$disableDraggab,
      onSwitch = props.onSwitch;

  var _useToolbelt = useToolbelt(),
      grant = _useToolbelt.grant,
      revoke = _useToolbelt.revoke,
      activeTool = _useToolbelt.activeTool,
      hudScene = _useToolbelt.hudScene;

  var ENABLED = (activeTool == null ? void 0 : activeTool.name) === name;
  var DISTANCE = 1;

  var _useState = react.useState(false),
      preloadDone = _useState[0],
      setPreloadDone = _useState[1];

  var _useSpring = three$1.useSpring({
    prog: ENABLED ? 1 : 0,
    config: {
      mass: 4,
      friction: 90,
      tension: 800
    }
  }),
      prog = _useSpring.prog;

  var visible = useVisible(prog);
  react.useEffect(function () {
    grant(name, icon, orderIndex);
    return function () {
      return revoke(name);
    };
  }, [name, icon, grant, revoke, orderIndex]);
  react.useEffect(function () {
    if (onSwitch) onSwitch((activeTool == null ? void 0 : activeTool.name) === name);
  }, [activeTool, onSwitch, name]);

  if (!preloadDone) {
    return /*#__PURE__*/React.createElement(ToolPreload, {
      setPreloadDone: setPreloadDone
    }, children);
  }

  if (!visible) return null;
  return /*#__PURE__*/React.createElement(React.Fragment, null, fiber.createPortal( /*#__PURE__*/React.createElement("group", {
    name: "tool-" + name
  }, /*#__PURE__*/React.createElement(HUD, {
    pos: pos,
    pinY: pinY,
    distance: DISTANCE,
    range: range,
    bobStrength: bobStrength
  }, /*#__PURE__*/React.createElement(OnScreen, {
    distance: DISTANCE,
    name: name,
    pos: pos,
    disableDraggable: disableDraggable
  }, /*#__PURE__*/React.createElement(FacePlayer, {
    enabled: face
  }, /*#__PURE__*/React.createElement(react.Suspense, {
    fallback: null
  }, visible && children))))), hudScene));
}

var _excluded$j = ["href", "target", "children"];
function Anchor(props) {
  var href = props.href,
      _props$target = props.target,
      target = _props$target === void 0 ? "_self" : _props$target,
      children = props.children,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$j);

  var gl = fiber.useThree(function (st) {
    return st.gl;
  });

  var onClick = function onClick() {
    if (gl.xr.isPresenting) {
      var _gl$xr$getSession;

      (_gl$xr$getSession = gl.xr.getSession()) == null ? void 0 : _gl$xr$getSession.end();
    }

    window.open(href, target);
  };

  return /*#__PURE__*/React.createElement("group", _extends__default["default"]({
    name: "spacesvr-anchor-" + href
  }, rest), /*#__PURE__*/React.createElement(Interactable, {
    onClick: onClick
  }, children));
}

function Floating(props) {
  var children = props.children,
      _props$height = props.height,
      height = _props$height === void 0 ? 0.2 : _props$height,
      _props$speed = props.speed,
      speed = _props$speed === void 0 ? 1 : _props$speed;
  var group = react.useRef(null);
  var seed = react.useRef(Math.random());
  useLimitedFrame(75, function (_ref) {
    var clock = _ref.clock;
    if (!group.current) return;
    group.current.position.y = height * Math.sin(clock.elapsedTime * speed * 0.4 + seed.current * 10000);
  });
  return /*#__PURE__*/React.createElement("group", {
    name: "spacesvr-floating",
    ref: group
  }, children);
}

function Spinning(props) {
  var children = props.children,
      _props$xSpeed = props.xSpeed,
      xSpeed = _props$xSpeed === void 0 ? 0 : _props$xSpeed,
      _props$ySpeed = props.ySpeed,
      ySpeed = _props$ySpeed === void 0 ? 1 : _props$ySpeed,
      _props$zSpeed = props.zSpeed,
      zSpeed = _props$zSpeed === void 0 ? 0 : _props$zSpeed;
  var group = react.useRef(null);

  var _useState = react.useState(Math.random()),
      seed = _useState[0];

  useLimitedFrame(75, function (_ref) {
    var clock = _ref.clock;
    if (!group.current) return;
    group.current.rotation.x = clock.elapsedTime * xSpeed * 0.25 + xSpeed * seed * 100;
    group.current.rotation.y = clock.elapsedTime * ySpeed * (0.25 + seed / 10) + ySpeed * seed * 1000;
    group.current.rotation.z = clock.elapsedTime * zSpeed * 0.25 + zSpeed * seed * 40;
  });
  return /*#__PURE__*/React.createElement("group", {
    name: "spacesvr-spinning",
    ref: group
  }, children);
}

/**
 *  Lots of code copied from https://github.com/pmndrs/drei/blob/master/src/core/Effects.tsx
 */
function Effects(props) {
  var children = props.children;
  react.useMemo(function () {
    return fiber.extend({
      EffectComposer: threeStdlib.EffectComposer,
      RenderPass: threeStdlib.RenderPass,
      ShaderPass: threeStdlib.ShaderPass
    });
  }, []);
  var composer = react.useRef(null);

  var _useThree = fiber.useThree(),
      scene = _useThree.scene,
      camera = _useThree.camera,
      gl = _useThree.gl,
      size = _useThree.size,
      viewport = _useThree.viewport;

  var _useState = react.useState(function () {
    var t = new three.WebGLRenderTarget(size.width, size.height, {
      type: three.UnsignedByteType,
      format: three.RGBAFormat,
      encoding: gl.outputEncoding,
      depthBuffer: true,
      stencilBuffer: true,
      anisotropy: 2
    });
    t.samples = 4;
    return t;
  }),
      target = _useState[0];

  react.useEffect(function () {
    var _composer$current, _composer$current2;

    (_composer$current = composer.current) == null ? void 0 : _composer$current.setSize(size.width, size.height);
    (_composer$current2 = composer.current) == null ? void 0 : _composer$current2.setPixelRatio(viewport.dpr);
  }, [gl, size, viewport.dpr]);
  fiber.useFrame(function () {
    var _composer$current3;

    if (!composer.current) return; // remove undefined passes

    composer.current.passes = composer.current.passes.filter(function (pass) {
      return pass !== undefined;
    });
    (_composer$current3 = composer.current) == null ? void 0 : _composer$current3.render();
  }, 1); // build passes array

  var passes = [];
  passes.push( /*#__PURE__*/React.createElement("renderPass", {
    key: "renderpass",
    attach: "passes-" + passes.length,
    args: [scene, camera]
  }));
  react.Children.forEach(children, function (el) {
    el && passes.push( /*#__PURE__*/react.cloneElement(el, {
      key: passes.length,
      attach: "passes-" + passes.length
    }));
  });
  return /*#__PURE__*/React.createElement("effectComposer", {
    ref: composer,
    args: [gl, target]
  }, passes);
}

var VisualContext = /*#__PURE__*/react.createContext({});
var useVisual = function useVisual() {
  return react.useContext(VisualContext);
};
function Visual(props) {
  var children = props.children;

  var _useThree = fiber.useThree(),
      scene = _useThree.scene,
      camera = _useThree.camera,
      gl = _useThree.gl;

  var _useEnvironment = useEnvironment(),
      device = _useEnvironment.device;

  var childPasses = react.useRef([]);
  var rerender = useRerender();
  var registerPass = react.useCallback(function (p) {
    childPasses.current.push(p);
    childPasses.current.sort(function (a, b) {
      return a.index - b.index;
    });
    rerender();
  }, []);
  var unregisterPass = react.useCallback(function (uuid) {
    childPasses.current = childPasses.current.filter(function (p) {
      return p.uuid !== uuid;
    });
    rerender();
  }, []);
  var USE_EFFECTS = childPasses.current.length > 0 && !device.xr;
  fiber.useFrame(function () {
    if (USE_EFFECTS) return;
    gl.autoClear = true;
    gl.render(scene, camera);
  }, 1);
  return /*#__PURE__*/React.createElement(VisualContext.Provider, {
    value: {
      registerPass: registerPass,
      unregisterPass: unregisterPass
    }
  }, USE_EFFECTS && /*#__PURE__*/React.createElement(Effects, null, childPasses.current.map(function (p) {
    return p.node;
  })), children);
}

function VisualEffect(props) {
  var index = props.index,
      children = props.children;

  var _useState = react.useState(function () {
    return Math.random().toString(36).substring(2);
  }),
      uuid = _useState[0];

  var _useVisual = useVisual(),
      registerPass = _useVisual.registerPass,
      unregisterPass = _useVisual.unregisterPass;

  react.useEffect(function () {
    if (!children) return;

    if (!Array.isArray(children)) {
      registerPass({
        uuid: uuid,
        node: children,
        index: index
      });
    } else {
      children.forEach(function (child, i) {
        registerPass({
          uuid: uuid,
          node: child,
          index: i
        });
      });
    }

    return function () {
      return unregisterPass(uuid);
    };
  }, [children, index, registerPass, unregisterPass, uuid]);
  return null;
}

var _excluded$i = ["args", "visible", "color", "onClick", "onHover", "onUnHover", "raycaster"];
var HitBox = /*#__PURE__*/react.forwardRef(function (props, ref) {
  var args = props.args,
      _props$visible = props.visible,
      visible = _props$visible === void 0 ? false : _props$visible,
      _props$color = props.color,
      color = _props$color === void 0 ? "red" : _props$color,
      onClick = props.onClick,
      onHover = props.onHover,
      onUnHover = props.onUnHover,
      raycaster = props.raycaster,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$i);

  return /*#__PURE__*/React.createElement(Interactable, {
    onClick: onClick,
    onHover: onHover,
    onUnHover: onUnHover,
    raycaster: raycaster
  }, /*#__PURE__*/React.createElement("mesh", _extends__default["default"]({
    visible: visible,
    name: "spacesvr-hitbox",
    ref: ref
  }, rest), /*#__PURE__*/React.createElement("boxGeometry", {
    args: args
  }), visible && /*#__PURE__*/React.createElement("meshBasicMaterial", {
    color: color,
    transparent: true,
    opacity: 0.7
  })));
});

var _excluded$h = ["args", "material", "children"];

function _createForOfIteratorHelperLoose$7(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray$7(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$7(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$7(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$7(o, minLen); }

function _arrayLikeToArray$7(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var local_cache = [];
function RoundedBox(props) {
  var _props$args = props.args;
  _props$args = _props$args === void 0 ? [] : _props$args;

  var _props$args$ = _props$args[0],
      width = _props$args$ === void 0 ? 1 : _props$args$,
      _props$args$2 = _props$args[1],
      height = _props$args$2 === void 0 ? 1 : _props$args$2,
      _props$args$3 = _props$args[2],
      depth = _props$args$3 === void 0 ? 0.25 : _props$args$3,
      material = props.material,
      children = props.children,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$h);

  var _useState = react.useState(new three.Vector3(1, 1, 1)),
      locScale = _useState[0],
      setLocScale = _useState[1];

  var geo = react.useMemo(function () {
    var _closestBox$key, _closestBox, _closestBox$width, _closestBox2, _closestBox$height, _closestBox3, _closestBox$depth, _closestBox4;

    var tolerance = 0.25; // 25% tolerance

    var closestBox = undefined;
    var closestOffset = Infinity;

    for (var _iterator = _createForOfIteratorHelperLoose$7(local_cache), _step; !(_step = _iterator()).done;) {
      var box = _step.value;
      var scale = box.width / width;
      var heightDiff = Math.abs(box.height - height * scale);
      var depthDiff = Math.abs(box.depth - depth * scale);

      if (heightDiff / box.height < tolerance && depthDiff / box.depth < tolerance && heightDiff + depthDiff < closestOffset) {
        closestBox = box;
        closestOffset = heightDiff + depthDiff;
      }
    }

    var key = (_closestBox$key = (_closestBox = closestBox) == null ? void 0 : _closestBox.key) != null ? _closestBox$key : "geo_rounded_box_" + width + "x" + height + "x" + depth;
    var w = (_closestBox$width = (_closestBox2 = closestBox) == null ? void 0 : _closestBox2.width) != null ? _closestBox$width : width;
    var h = (_closestBox$height = (_closestBox3 = closestBox) == null ? void 0 : _closestBox3.height) != null ? _closestBox$height : height;
    var d = (_closestBox$depth = (_closestBox4 = closestBox) == null ? void 0 : _closestBox4.depth) != null ? _closestBox$depth : depth;
    var r = Math.min(w, h, d) / 2;

    var get_geo = function get_geo() {
      return cache.getResource(key, function () {
        return new RoundedBoxGeometry.RoundedBoxGeometry(width, height, depth, 4, r);
      });
    }; // make sure to cache result if it's not already cached


    if (!closestBox) local_cache.push({
      key: key,
      width: width,
      height: height,
      depth: depth
    });
    setLocScale(new three.Vector3(width / w, height / h, depth / d));
    return get_geo();
  }, [width, height, depth]);
  return /*#__PURE__*/React.createElement("group", _extends__default["default"]({
    name: "spacesvr-rounded-box"
  }, rest), /*#__PURE__*/React.createElement("mesh", {
    scale: locScale,
    material: material,
    geometry: geo
  }, children));
}

var useIdeaMaterial = function useIdeaMaterial(idea, radius) {
  var hex = react.useMemo(function () {
    return (idea == null ? void 0 : idea.getHex()) || "#808080";
  }, [idea]);
  var seed = react.useMemo(function () {
    return Math.random();
  }, []);
  var color = react.useMemo(function () {
    return new three.Color(hex);
  }, [hex]);

  var _useSpring = three$1.useSpring({
    col: hex
  }),
      col = _useSpring.col;

  var NOISE_AMPLITUDE = radius * 0.32;
  var NOISE_FREQ = 0.554 / radius;
  var mat = react.useMemo(function () {
    var material = new three.MeshStandardMaterial({
      metalness: 0.18,
      roughness: 0.49,
      envMapIntensity: 0.66,
      side: three.DoubleSide
    });

    material.onBeforeCompile = function (shader) {
      shader.uniforms.radius = new three.Uniform(radius);
      shader.uniforms.time = new three.Uniform(0);
      shader.uniforms.color = new three.Uniform(color);
      shader.uniforms.radiusVariationAmplitude = new three.Uniform(NOISE_AMPLITUDE);
      shader.uniforms.radiusNoiseFrequency = new three.Uniform(NOISE_FREQ);
      var uniforms = "\n        uniform float radius;\n        uniform float time;\n        uniform vec3 color;\n        uniform float radiusVariationAmplitude;\n        uniform float radiusNoiseFrequency;\n      ";
      shader.vertexShader = uniforms + vertHead + shader.vertexShader.replace("#include <begin_vertex>", vert$1);
      shader.fragmentShader = uniforms + shader.fragmentShader.replace("#include <dithering_fragment>", frag$1);
      material.userData.shader = shader;
    };

    return material;
  }, [radius, color, NOISE_AMPLITUDE, NOISE_FREQ, frag$1, vert$1]);
  useLimitedFrame(50, function (_ref) {
    var _mat$userData;

    var clock = _ref.clock;
    if (!(mat != null && (_mat$userData = mat.userData) != null && _mat$userData.shader)) return;
    mat.userData.shader.uniforms.time.value = clock.elapsedTime / 6 + seed * 100;
    mat.userData.shader.uniforms.color.value.set(col.get());
  });
  return mat;
};
var vertHead = "\n    // Description : Array and textureless GLSL 2D/3D/4D simplex\n    //               noise functions.\n    //      Author : Ian McEwan, Ashima Arts.\n    //  Maintainer : ijm\n    //     Lastmod : 20110822 (ijm)\n    //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n    //               Distributed under the MIT License. See LICENSE file.\n    //               https://github.com/ashima/webgl-noise\n    //\n    \n    vec3 mod289(vec3 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 mod289(vec4 x) {\n      return x - floor(x * (1.0 / 289.0)) * 289.0;\n    }\n    \n    vec4 permute(vec4 x) {\n         return mod289(((x*34.0)+1.0)*x);\n    }\n    \n    vec4 taylorInvSqrt(vec4 r)\n    {\n      return 1.79284291400159 - 0.85373472095314 * r;\n    }\n    \n    float snoise(vec3 v)\n      {\n      const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;\n      const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);\n    \n    // First corner\n      vec3 i  = floor(v + dot(v, C.yyy) );\n      vec3 x0 =   v - i + dot(i, C.xxx) ;\n    \n    // Other corners\n      vec3 g = step(x0.yzx, x0.xyz);\n      vec3 l = 1.0 - g;\n      vec3 i1 = min( g.xyz, l.zxy );\n      vec3 i2 = max( g.xyz, l.zxy );\n    \n      //   x0 = x0 - 0.0 + 0.0 * C.xxx;\n      //   x1 = x0 - i1  + 1.0 * C.xxx;\n      //   x2 = x0 - i2  + 2.0 * C.xxx;\n      //   x3 = x0 - 1.0 + 3.0 * C.xxx;\n      vec3 x1 = x0 - i1 + C.xxx;\n      vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y\n      vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y\n    \n    // Permutations\n      i = mod289(i);\n      vec4 p = permute( permute( permute(\n                 i.z + vec4(0.0, i1.z, i2.z, 1.0 ))\n               + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))\n               + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));\n    \n    // Gradients: 7x7 points over a square, mapped onto an octahedron.\n    // The ring size 17*17 = 289 is close to a multiple of 49 (49*6 = 294)\n      float n_ = 0.142857142857; // 1.0/7.0\n      vec3  ns = n_ * D.wyz - D.xzx;\n    \n      vec4 j = p - 49.0 * floor(p * ns.z * ns.z);  //  mod(p,7*7)\n    \n      vec4 x_ = floor(j * ns.z);\n      vec4 y_ = floor(j - 7.0 * x_ );    // mod(j,N)\n    \n      vec4 x = x_ *ns.x + ns.yyyy;\n      vec4 y = y_ *ns.x + ns.yyyy;\n      vec4 h = 1.0 - abs(x) - abs(y);\n    \n      vec4 b0 = vec4( x.xy, y.xy );\n      vec4 b1 = vec4( x.zw, y.zw );\n    \n      //vec4 s0 = vec4(lessThan(b0,0.0))*2.0 - 1.0;\n      //vec4 s1 = vec4(lessThan(b1,0.0))*2.0 - 1.0;\n      vec4 s0 = floor(b0)*2.0 + 1.0;\n      vec4 s1 = floor(b1)*2.0 + 1.0;\n      vec4 sh = -step(h, vec4(0.0));\n    \n      vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;\n      vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;\n    \n      vec3 p0 = vec3(a0.xy,h.x);\n      vec3 p1 = vec3(a0.zw,h.y);\n      vec3 p2 = vec3(a1.xy,h.z);\n      vec3 p3 = vec3(a1.zw,h.w);\n    \n    //Normalise gradients\n      vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));\n      p0 *= norm.x;\n      p1 *= norm.y;\n      p2 *= norm.z;\n      p3 *= norm.w;\n    \n    // Mix final noise value\n      vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);\n      m = m * m;\n      return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),\n                                    dot(p2,x2), dot(p3,x3) ) );\n      }\n              \n    \n    float fsnoise(float val1, float val2, float val3){\n      return snoise(vec3(val1,val2,val3));\n    }\n    \n    vec3 distortFunct(vec3 transformed, float factor) {\n      float radiusVariation = -fsnoise(\n        transformed.x * radiusNoiseFrequency + time,\n        transformed.y * radiusNoiseFrequency + time,\n        transformed.z * radiusNoiseFrequency + time \n      ) * radiusVariationAmplitude * factor;\n      return normalize(transformed) * (radiusVariation + radius);\n    }\n    \n    vec3 orthogonal(vec3 v) {\n      return normalize(abs(v.x) > abs(v.z) ? vec3(-v.y, v.x, 0.0)\n      : vec3(0.0, -v.z, v.y));\n    }\n    \n    vec3 distortNormal(vec3 position, vec3 distortedPosition, vec3 normal){\n      vec3 tangent1 = orthogonal(normal);\n      vec3 tangent2 = normalize(cross(normal, tangent1));\n      vec3 nearby1 = position + tangent1 * 0.1;\n      vec3 nearby2 = position + tangent2 * 0.1;\n      vec3 distorted1 = distortFunct(nearby1, 1.0);\n      vec3 distorted2 = distortFunct(nearby2, 1.0);\n      return normalize(cross(distorted1 - distortedPosition, distorted2 - distortedPosition));\n    }\n";
var vert$1 = "\n    #include <begin_vertex>\n    float updateTime = time / 10.0;\n    transformed = distortFunct(transformed, 1.0);\n    vec3 distortedNormal = distortNormal(position, transformed, normal);\n    vNormal = normal + distortedNormal;\n    gl_Position = projectionMatrix * modelViewMatrix * vec4(transformed,1.);\n";
var frag$1 = "\n    #include <dithering_fragment>\n    float angle = clamp(dot(normalize(vNormal), vec3(0., -1., 0.)), 0., 1.);\n    gl_FragColor = vec4(gl_FragColor.rgb * color, gl_FragColor.a);  \n    gl_FragColor.rgb = mix(gl_FragColor.rgb, mix(color, vec3(0.), 0.5), angle);\n";

function Bubbles(props) {
  var numStops = props.numStops,
      enabled = props.enabled,
      offset = props.offset;
  var group = react.useRef(null);
  var mesh = react.useRef(null);
  var clock = fiber.useThree(function (st) {
    return st.clock;
  });

  var _useState = react.useState(new three.Vector3()),
      pos = _useState[0];

  var _useState2 = react.useState(new three.Object3D()),
      obj = _useState2[0];

  var startTime = react.useRef(0);
  react.useEffect(function () {
    startTime.current = clock.elapsedTime;
  }, [enabled]);
  useLimitedFrame(40, function (_ref) {
    var clock = _ref.clock;
    if (!mesh.current || !group.current) return;
    group.current.updateMatrix();
    group.current.matrix.decompose(pos, obj.quaternion, obj.scale);

    for (var i = 0; i < numStops; i++) {
      var perc = i / (numStops - 1);
      obj.position.set(perc * pos.x, perc * pos.y, perc * pos.z);
      var sc = 0.8 + perc * 4;
      var delay = 60 / 1000;
      var time = 400 / 1000;
      var delta = clock.elapsedTime - startTime.current;
      var iter = enabled ? i : numStops - i - 1;
      var x = three.MathUtils.clamp((delta - iter * delay) / time, 0, 1);
      var val = (Math.cos(Math.PI * x) + 1) / 2;
      if (enabled) val = 1 - val;
      obj.scale.setScalar(sc * 0.2 * val);
      obj.updateMatrix();
      mesh.current.setMatrixAt(i, obj.matrix);
    }

    mesh.current.instanceMatrix.needsUpdate = true;
  });
  var geo = react.useMemo(function () {
    return new three.SphereGeometry(0.05, 32, 16);
  }, []);
  var mat = useIdeaMaterial(undefined, 0.05);
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("group", {
    position: offset,
    ref: group
  }), /*#__PURE__*/React.createElement("instancedMesh", {
    args: [geo, mat, numStops],
    ref: mesh
  }));
}

/**
 * helper function to detect when text needs to be synced based on arbitrary values
 *
 * @param text
 * @param property
 * @param val
 */
var syncOnChange = function syncOnChange(text, property, val) {
  if (text._needsSync) return;
  if (!text.userData) text.userData = {};

  if (text.userData[property] !== val) {
    text.userData[property] = val;
    text._needsSync = true;
  }
};

/**
 * Given an input, handle logic for shift clicking to select text
 * @param input
 * @param newIndex
 */
var handleShiftSelect = function handleShiftSelect(input, newIndex) {
  var HAS_SELECTION = input.selectionStart !== input.selectionEnd;

  if (!HAS_SELECTION) {
    if (newIndex < (input.selectionStart || 0)) {
      input.setSelectionRange(newIndex, input.selectionStart || 0, "backward");
    } else {
      input.setSelectionRange(input.selectionStart || 0, newIndex, "forward");
    }

    return;
  } // shift clicking to select text


  var isForward = input.selectionDirection === "forward";
  var start = input.selectionStart || 0;
  var end = input.selectionEnd || 0;

  if (isForward) {
    if (start === newIndex) {
      input.setSelectionRange(start, newIndex, "none");
    } else if (newIndex > start) {
      input.setSelectionRange(start, newIndex, "forward");
    } else {
      input.setSelectionRange(newIndex, start, "backward");
    }
  } else {
    if (end === newIndex) {
      input.setSelectionRange(newIndex, end, "none");
    } else if (newIndex < end) {
      input.setSelectionRange(newIndex, end, "backward");
    } else {
      input.setSelectionRange(end, newIndex, "forward");
    }
  }
};
var dummy = new three.Vector2();

/**
 * Return the caret position of the last click
 * @param text
 * @param raycaster
 */
var getClickedCaret = function getClickedCaret(text, raycaster) {
  var intersections = raycaster.intersectObject(text, true);
  if (intersections.length === 0) return null;
  var inter = intersections[0];
  var textPos = text.worldPositionToTextCoords(inter.point, dummy);
  return troikaThreeText.getCaretAtPoint(text.textRenderInfo, textPos.x, textPos.y);
};
var CLICK_TIMEOUT = 0.2; // seconds

/**
 * Calling this indicates a click. Return whether it was a single, double, or triple click
 * @param clock
 * @param lastClickTime
 * @param lastDoubleClickTime
 */

var getClickType = function getClickType(clock, lastClickTime, lastDoubleClickTime) {
  var time = clock.elapsedTime;
  var clickTime = time - lastClickTime.current;
  var doubleClickTime = time - lastDoubleClickTime.current;

  if (clickTime < CLICK_TIMEOUT) {
    if (doubleClickTime < CLICK_TIMEOUT * 2) {
      lastDoubleClickTime.current = time;
      return 3;
    } else {
      lastClickTime.current = time;
      lastDoubleClickTime.current = time;
      return 2;
    }
  } else {
    lastClickTime.current = time;
    return 1;
  }
};
/**
 * Return the start and end indexes of the word that the caret is in
 * @param text
 * @param caret
 */

var getWordBoundsAtCaret = function getWordBoundsAtCaret(text, caret) {
  var left = caret;
  var right = caret;

  while (left > 0 && text[left - 1] !== " ") {
    left--;
  }

  while (right < text.length && text[right] !== " ") {
    right++;
  }

  return [left, right];
};

var RESET_TIMEOUT = 1; // seconds, amount of time to wait after reset before continuing to blink

/**
 * Manages the blinking of a caret.
 * @param rate
 */
var useCaretBlink = function useCaretBlink(rate) {
  if (rate === void 0) {
    rate = 1;
  }

  var blinkRef = react.useRef(null);
  var clock = fiber.useThree(function (st) {
    return st.clock;
  });
  var startTime = react.useRef(0);
  fiber.useFrame(function (_ref) {
    var clock = _ref.clock;
    if (!blinkRef.current) return;
    var diff = clock.elapsedTime - startTime.current;

    if (diff < RESET_TIMEOUT) {
      blinkRef.current.visible = true;
    } else {
      // formula below makes sure that after exactly RESET_TIMEOUT, blinking starts with "off"
      blinkRef.current.visible = Boolean(Math.round((-Math.sin(rate * Math.PI * 2 * (diff - RESET_TIMEOUT)) + 1) / 2));
    }
  });

  var reset = function reset() {
    startTime.current = clock.elapsedTime;
  };

  return {
    blinkRef: blinkRef,
    reset: reset
  };
};

var useDragSelect = function useDragSelect(input, text, raycaster, focusInput) {
  var gl = fiber.useThree(function (state) {
    return state.gl;
  });
  var mouse = fiber.useThree(function (state) {
    return state.mouse;
  });
  var camera = fiber.useThree(function (state) {
    return state.camera;
  });

  var _useEnvironment = useEnvironment(),
      device = _useEnvironment.device;

  var startCar = react.useRef(0);
  var dragging = react.useRef(false);
  react.useEffect(function () {
    var _text = text.current;
    if (!_text || !_text.textRenderInfo) return;

    var handleMove = function handleMove() {
      var car = getClickedCaret(_text, raycaster);
      if (car == null) return;

      if (!dragging.current) {
        // consider it a drag when mouse moves by at least 1 character
        if (car.charIndex === startCar.current) return;
        dragging.current = true;
        input.setSelectionRange(startCar.current, startCar.current);
      }

      handleShiftSelect(input, car.charIndex);
    };

    var touchMove = function touchMove(e) {
      // because we stop propagation, we need to manually set the mouse position
      mouse.x = e.touches[0].clientX / gl.domElement.clientWidth * 2 - 1;
      mouse.y = -(e.touches[0].clientY / gl.domElement.clientHeight) * 2 + 1;
      raycaster.setFromCamera(mouse, camera);
      handleMove();
    };

    var dragEnd = function dragEnd() {
      if (device.mobile) {
        gl.domElement.removeEventListener("touchmove", touchMove);
        gl.domElement.removeEventListener("touchend", dragEnd);
      } else {
        gl.domElement.removeEventListener("mousemove", handleMove);
        gl.domElement.removeEventListener("mouseup", dragEnd);
      }
    };

    var dragStart = function dragStart(e) {
      dragging.current = false;
      var car = getClickedCaret(_text, raycaster);
      if (car === null) return;
      focusInput();
      e.stopPropagation(); // stop touch controls from running so screen doesn't move while dragging

      startCar.current = car.charIndex;

      if (device.mobile) {
        gl.domElement.addEventListener("touchmove", touchMove);
        gl.domElement.addEventListener("touchend", dragEnd);
      } else {
        gl.domElement.addEventListener("mousemove", handleMove);
        gl.domElement.addEventListener("mouseup", dragEnd);
      }
    };

    if (device.mobile) {
      gl.domElement.addEventListener("touchstart", dragStart);
      return function () {
        return gl.domElement.removeEventListener("touchstart", dragStart);
      };
    } else {
      gl.domElement.addEventListener("mousedown", dragStart);
      return function () {
        return gl.domElement.removeEventListener("mousedown", dragStart);
      };
    }
  }, [gl.domElement, focusInput, input, text, device.mobile, mouse, camera, raycaster]);
};

var _excluded$g = ["value", "onChange", "onSubmit", "onFocus", "onBlur", "type", "font", "fontSize", "width", "placeholder", "raycaster"];
function TextInput(props) {
  var value = props.value,
      onChange = props.onChange,
      onSubmit = props.onSubmit,
      onFocus = props.onFocus,
      onBlur = props.onBlur,
      _props$type = props.type,
      type = _props$type === void 0 ? "text" : _props$type,
      _props$font = props.font,
      font = _props$font === void 0 ? "https://d27rt3a60hh1lx.cloudfront.net/fonts/Quicksand_Bold.otf" : _props$font,
      _props$fontSize = props.fontSize,
      fontSize = _props$fontSize === void 0 ? 0.1 : _props$fontSize,
      _props$width = props.width,
      width = _props$width === void 0 ? 1 : _props$width,
      placeholder = props.placeholder,
      passedRaycaster = props.raycaster,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$g);

  var clock = fiber.useThree(function (st) {
    return st.clock;
  });
  var camera = fiber.useThree(function (st) {
    return st.camera;
  });
  var player = usePlayer();

  var _useEnvironment = useEnvironment(),
      device = _useEnvironment.device;

  var RAYCASTER = passedRaycaster || player.raycaster;
  var group = react.useRef(null);
  var textRef = react.useRef();
  var caret = react.useRef(null);
  var highlight = react.useRef(null);

  var _useState = react.useState(""),
      localValue = _useState[0],
      setLocalValue = _useState[1];

  var val = value != null ? value : localValue;

  var setVal = function setVal(s) {
    if (onChange) onChange(s);
    setLocalValue(s);
  };

  var _useTextInput = useTextInput(type, val, setVal),
      input = _useTextInput.input,
      focused = _useTextInput.focused,
      focusInput = _useTextInput.focusInput; // focus callback


  react.useEffect(function () {
    if (!onFocus) return;
    input.addEventListener("focus", onFocus);
    return function () {
      return input.removeEventListener("focus", onFocus);
    };
  }, [input, onFocus]); // blur callback

  react.useEffect(function () {
    if (!onBlur) return;
    input.addEventListener("blur", onBlur);
    return function () {
      return input.removeEventListener("blur", onBlur);
    };
  }, [input, onBlur]); // look at input when focused, only on mobile

  react.useEffect(function () {
    if (!group.current || !focused || !device.mobile) return;
    var worldpos = group.current.getWorldPosition(new three.Vector3());
    camera.lookAt(worldpos);
  }, [focused, camera, device]);

  var _useSpring = three$1.useSpring({
    color: focused ? "#000" : "#828282"
  }),
      color = _useSpring.color;

  var highlightMat = cache.useResource("spacesvr_textinput_highlight", function () {
    return new three.MeshStandardMaterial({
      color: "blue",
      transparent: true,
      opacity: 0.3,
      depthWrite: false
    });
  });
  var BORDER = fontSize * 0.1;
  var PADDING_X = fontSize * 0.5;
  var INNER_WIDTH = width - PADDING_X * 2;
  var INPUT_HEIGHT = fontSize * 1.75;
  var INPUT_WIDTH = width;
  var OUTER_HEIGHT = INPUT_HEIGHT + BORDER;
  var OUTER_WIDTH = width + BORDER * 2;
  var DEPTH = fontSize * 0.5;
  var shift = useShiftHold();
  var lastClickTime = react.useRef(0);
  var lastDoubleClickTime = react.useRef(0);

  var registerClick = function registerClick() {
    focusInput();
    var _text = textRef.current;
    if (!_text || !_text.textRenderInfo || !input || !focused) return;
    var car = getClickedCaret(_text, RAYCASTER);

    if (car === null) {
      // clicked in empty space in the text box
      input.setSelectionRange(input.value.length, input.value.length);
    } else if (!shift.current) {
      var clickType = getClickType(clock, lastClickTime, lastDoubleClickTime);

      if (clickType === 1) {
        input.setSelectionRange(car.charIndex, car.charIndex);
      } else if (clickType === 2) {
        var wordBounds = getWordBoundsAtCaret(input.value, car.charIndex);
        input.setSelectionRange(wordBounds[0], wordBounds[1]);
      } else {
        input.setSelectionRange(0, input.value.length);
      }
    } else {
      lastClickTime.current = 0;
      lastDoubleClickTime.current = 0;
      handleShiftSelect(input, car.charIndex);
    }
  };

  useDragSelect(input, textRef, RAYCASTER, focusInput);
  useKeypress("Enter", function () {
    if (!focused || !onSubmit) return;
    onSubmit(input.value);
    input.blur();
  }, [input, focused, onSubmit]);
  var updateText = react.useCallback(function (leftOffset, width) {
    var _text = textRef.current;
    if (!_text) return;
    if (!_text.clipRect) _text.clipRect = [0, 0, 0, 0];
    _text.clipRect[0] = leftOffset;
    _text.clipRect[1] = -Infinity;
    _text.clipRect[2] = width + leftOffset;
    _text.clipRect[3] = Infinity;
    _text.minWidth = width;
    _text.position.x = -width / 2 - leftOffset;

    _text.sync();
  }, []);
  var SHOW_PLACEHOLDER = !focused && placeholder && !input.value;
  var VAL = SHOW_PLACEHOLDER ? placeholder : type === "password" ? input.value.replace(/./g, "") : input.value;
  var COL = SHOW_PLACEHOLDER ? "#828282" : "#000";
  var scrollLeft = react.useRef(0);
  var blink = useCaretBlink(0.65);

  if (textRef.current && input && caret.current && highlight.current) {
    var _text = textRef.current;
    var _caret = caret.current;
    var _highlight = highlight.current;
    _text.text = VAL;
    _text.color = COL;
    syncOnChange(_text, "focused", focused);
    syncOnChange(_text, "selectionStart", input.selectionStart);
    syncOnChange(_text, "selectionEnd", input.selectionEnd);
    syncOnChange(_text, "fontSize", fontSize);
    syncOnChange(_text, "scrollLeft", scrollLeft.current);
    syncOnChange(_text, "width", width);

    _text.sync(function () {
      blink.reset();
      var caretPositions = _text.textRenderInfo.caretPositions;
      var TEXT_SELECTED = input.selectionStart !== input.selectionEnd && focused;
      _caret.visible = false;
      _highlight.visible = false; // CASE 1: not focused

      if (!focused) {
        updateText(0, INNER_WIDTH);
      } // CASE 2: focused, maybe selected, get caret in view


      if (focused) {
        _caret.visible = true;
        var activeSel = (TEXT_SELECTED && input.selectionDirection === "forward" ? input.selectionEnd : input.selectionStart) || 0; // get it all the way to the left

        _caret.position.x = -INNER_WIDTH / 2 - scrollLeft.current; // calculate char indexes and x positions

        var lastIndex = caretPositions.length - 2;
        var activeIndex = Math.min(activeSel * 3, input.value.length * 3 - 2);
        var lastCaretX = caretPositions[lastIndex];
        var activeCaretX = activeSel == 0 ? 0 : caretPositions[activeIndex] || lastCaretX; // fallback for fast typing
        // move it to the active character

        if (activeCaretX !== undefined) {
          _caret.position.x += activeCaretX;
        } // scroll to keep caret in view if it goes too far right


        if (_caret.position.x > INNER_WIDTH / 2) {
          if (activeSel === input.value.length) {
            // scroll one char right
            scrollLeft.current += _caret.position.x - INNER_WIDTH / 2;
            _caret.position.x = INNER_WIDTH / 2;
          } else {
            // center caret
            scrollLeft.current += _caret.position.x;
            _caret.position.x -= _caret.position.x;
          }
        } // scroll to keep caret in view if it goes too far left


        if (_caret.position.x < -INNER_WIDTH / 2) {
          scrollLeft.current += _caret.position.x;
          _caret.position.x = 0;
        } // right adjust


        var lastCharOffset = INNER_WIDTH - lastCaretX + scrollLeft.current;

        if (lastCharOffset > 0 && scrollLeft.current > 0) {
          _caret.position.x += lastCharOffset;
          scrollLeft.current -= lastCharOffset;
        } // left adjust


        if (scrollLeft.current < 0) {
          _caret.position.x += scrollLeft.current;
          scrollLeft.current = 0;
        }

        updateText(scrollLeft.current, INNER_WIDTH);
      } // CASE 3: focused and selected, show highlight


      if (TEXT_SELECTED) {
        _highlight.visible = true;
        _caret.visible = false;
        var finalCharIndex = input.value.length * 3 - 2;
        var startIndex = Math.min((input.selectionStart || 0) * 3, finalCharIndex);
        var startX = caretPositions[startIndex];
        var endIndex = Math.min((input.selectionEnd || 0) * 3, finalCharIndex);
        var endX = caretPositions[endIndex];

        if (startX !== undefined && endX !== undefined) {
          var highWidth = endX - startX;
          _highlight.position.x = -INNER_WIDTH / 2 + startX - scrollLeft.current + highWidth / 2;
          _highlight.scale.x = highWidth;
          var leftEdge = _highlight.position.x - _highlight.scale.x / 2;

          if (leftEdge < -INNER_WIDTH / 2) {
            var diff = -INNER_WIDTH / 2 - leftEdge;
            _highlight.position.x += diff / 2;
            _highlight.scale.x -= diff;
          }

          var rightEdge = _highlight.position.x + _highlight.scale.x / 2;

          if (rightEdge > INNER_WIDTH / 2) {
            var _diff = rightEdge - INNER_WIDTH / 2;

            _highlight.position.x -= _diff / 2;
            _highlight.scale.x -= _diff;
          }
        }
      }
    });
  } // scroll the input if user is dragging a selection to the left or right


  var SCROLL_BUFFER = fontSize;
  var MOVE_SPEED = fontSize * 0.25;
  useLimitedFrame(1, function () {
    var _text = textRef.current;
    var _caret = caret.current;
    var TEXT_SELECTED = input.selectionStart !== input.selectionEnd && focused;
    if (!_text || !_caret || !TEXT_SELECTED) return; // scroll to the right

    if (_caret.position.x > INNER_WIDTH / 2 - SCROLL_BUFFER) {
      scrollLeft.current += MOVE_SPEED;
    } // scroll to the left


    if (_caret.position.x < -INNER_WIDTH / 2 + SCROLL_BUFFER) {
      scrollLeft.current -= MOVE_SPEED;
    }
  });
  return /*#__PURE__*/React.createElement("group", _extends__default["default"]({
    name: "spacesvr-text-input"
  }, rest, {
    ref: group
  }), /*#__PURE__*/React.createElement("group", {
    name: "content",
    "position-z": DEPTH / 2 + 0.001
  }, /*#__PURE__*/React.createElement(react.Suspense, {
    fallback: null
  }, /*#__PURE__*/React.createElement(drei.Text, {
    name: "text",
    ref: textRef,
    color: COL,
    anchorX: "left",
    fontSize: fontSize,
    font: font,
    maxWidth: INNER_WIDTH,
    "position-x": -INNER_WIDTH / 2 // @ts-ignore
    ,
    whiteSpace: "nowrap",
    renderOrder: 2
  }, VAL)), /*#__PURE__*/React.createElement("group", {
    name: "blink",
    ref: blink.blinkRef
  }, /*#__PURE__*/React.createElement("mesh", {
    name: "caret",
    ref: caret,
    visible: false,
    material: cache.mat_basic_black
  }, /*#__PURE__*/React.createElement("planeGeometry", {
    args: [0.075 * fontSize, fontSize]
  }))), /*#__PURE__*/React.createElement("mesh", {
    name: "highlight",
    ref: highlight,
    visible: false,
    material: highlightMat
  }, /*#__PURE__*/React.createElement("boxGeometry", {
    args: [1, fontSize, DEPTH * 0.45]
  }))), /*#__PURE__*/React.createElement(HitBox, {
    args: [INPUT_WIDTH, INPUT_HEIGHT, DEPTH],
    raycaster: RAYCASTER,
    onClick: registerClick
  }), /*#__PURE__*/React.createElement(RoundedBox, {
    args: [INPUT_WIDTH, INPUT_HEIGHT, DEPTH],
    material: cache.mat_standard_white
  }), /*#__PURE__*/React.createElement(RoundedBox, {
    args: [OUTER_WIDTH, OUTER_HEIGHT, DEPTH],
    "position-z": -0.001
  }, /*#__PURE__*/React.createElement(three$1.animated.meshStandardMaterial, {
    color: color
  })));
}

var _excluded$f = ["children", "onClick", "font", "fontSize", "width", "maxWidth", "textColor", "color", "outline", "outlineColor", "idea", "raycaster"];
function Button$1(props) {
  var children = props.children,
      onClick = props.onClick,
      _props$font = props.font,
      font = _props$font === void 0 ? "https://d27rt3a60hh1lx.cloudfront.net/fonts/Quicksand_Bold.otf" : _props$font,
      _props$fontSize = props.fontSize,
      fontSize = _props$fontSize === void 0 ? 0.05 : _props$fontSize,
      width = props.width,
      maxWidth = props.maxWidth,
      _props$textColor = props.textColor,
      textColor = _props$textColor === void 0 ? "black" : _props$textColor,
      _props$color = props.color,
      color = _props$color === void 0 ? "#fff" : _props$color,
      _props$outline = props.outline,
      outline = _props$outline === void 0 ? true : _props$outline,
      _props$outlineColor = props.outlineColor,
      outlineColor = _props$outlineColor === void 0 ? "white" : _props$outlineColor,
      idea = props.idea,
      raycaster = props.raycaster,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$f);

  var textRef = react.useRef();

  var _useState = react.useState([0, 0]),
      dims = _useState[0],
      setDims = _useState[1];

  var _useState2 = react.useState(false),
      hovered = _useState2[0],
      setHovered = _useState2[1];

  var _useState3 = react.useState(false),
      clicked = _useState3[0],
      setClicked = _useState3[1];

  var REST_COLOR = react.useMemo(function () {
    return idea ? idea.getHex() : color;
  }, [color, idea]);
  var HOVER_COLOR = react.useMemo(function () {
    var hoverIdea = idea ? idea.clone() : new Idea().setFromHex("#" + new three.Color(REST_COLOR).getHexString());
    var offset = 0.175 * (hoverIdea.utility > 0.5 ? -1 : 1);
    hoverIdea.setUtility(hoverIdea.utility + offset);
    return hoverIdea.getHex();
  }, [REST_COLOR, idea]);

  var _useSpring = three$1.useSpring(_extends__default["default"]({
    animColor: hovered ? HOVER_COLOR : REST_COLOR,
    scale: clicked ? 0.75 : 1
  }, three$1.config.stiff)),
      animColor = _useSpring.animColor,
      scale = _useSpring.scale; // spring animation on click


  react.useEffect(function () {
    if (clicked) setTimeout(function () {
      return setClicked(false);
    }, 150);
  }, [clicked]);

  var onButtonClick = function onButtonClick() {
    if (onClick) onClick();
    setClicked(true);
  }; // keep dimensions up to date


  react.useLayoutEffect(function () {
    textRef.current.addEventListener("synccomplete", function () {
      var _textRef$current;

      var info = (_textRef$current = textRef.current) == null ? void 0 : _textRef$current.textRenderInfo;
      if (!info) return;
      var w = info.blockBounds[2] - info.blockBounds[0];
      var h = info.blockBounds[3] - info.blockBounds[1];
      setDims([w, h]);
    });
    textRef.current.sync();
  }, []);
  var PADDING = fontSize * 0.9;
  var MAX_WIDTH = !maxWidth ? Infinity : width ? Math.max(width, maxWidth) : maxWidth;
  var WIDTH = (width || dims[0]) + PADDING * 2;
  var HEIGHT = dims[1] + PADDING;
  var DEPTH = fontSize * 1.1;
  var OUTLINE_WIDTH = outline ? fontSize * 0.075 : 0;
  return /*#__PURE__*/React.createElement("group", _extends__default["default"]({
    name: "spacesvr-button-" + children
  }, rest), /*#__PURE__*/React.createElement(three$1.animated.group, {
    scale: scale
  }, /*#__PURE__*/React.createElement(drei.Text, {
    ref: textRef,
    color: textColor,
    font: font,
    fontSize: fontSize,
    maxWidth: MAX_WIDTH,
    outlineWidth: OUTLINE_WIDTH,
    outlineColor: outlineColor,
    anchorY: "middle",
    textAlign: "center",
    "position-z": DEPTH / 2 + 0.001,
    renderOrder: 2
  }, children), /*#__PURE__*/React.createElement(HitBox, {
    args: [WIDTH, HEIGHT, DEPTH],
    onClick: onButtonClick,
    onHover: function onHover() {
      return setHovered(true);
    },
    onUnHover: function onUnHover() {
      return setHovered(false);
    },
    raycaster: raycaster
  }), /*#__PURE__*/React.createElement(RoundedBox, {
    args: [WIDTH, HEIGHT, DEPTH]
  }, /*#__PURE__*/React.createElement(three$1.animated.meshStandardMaterial, {
    color: animColor
  }))));
}

function _createForOfIteratorHelperLoose$6(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray$6(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$6(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$6(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$6(o, minLen); }

function _arrayLikeToArray$6(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function VisualDecisions(props) {
  var decisions = props.decisions,
      setCurKey = props.setCurKey,
      width = props.width;
  var FONT_FILE = "https://d27rt3a60hh1lx.cloudfront.net/fonts/Quicksand_Bold.otf";
  var FONT_SIZE = 0.05;
  var OUTLINE_WIDTH = FONT_SIZE * 0.1;
  var PADDING_Y = 0.065;
  var SPACING_Y = 0.015;
  var SPACING_X = 0.08;
  var PADDING_X = 0.025;

  var _useState = react.useState(function () {
    return new Map();
  }),
      dimMap = _useState[0];

  var _useState2 = react.useState(false),
      ready = _useState2[0],
      setReady = _useState2[1]; // for every new set of values, generate a new text object and store width
  // keep ready state in sync with whether all values have been measured


  react.useEffect(function () {
    if (decisions.every(function (d) {
      return dimMap.has(d.name);
    })) return;
    setReady(false);

    var _loop = function _loop() {
      var decision = _step.value;
      if (dimMap.has(decision.name)) return "continue";
      setReady(false);
      var t = new troikaThreeText.Text();
      t.text = decision.name;
      t.font = FONT_FILE;
      t.fontSize = FONT_SIZE;
      t.maxWidth = width;
      t.outlineWidth = OUTLINE_WIDTH;
      t.sync(function () {
        var blockBounds = t.textRenderInfo.blockBounds;
        var w = blockBounds[2] - blockBounds[0];
        var h = blockBounds[3] - blockBounds[1];
        dimMap.set(decision.name, {
          w: w,
          h: h
        });
        if (decisions.every(function (d) {
          return dimMap.has(d.name);
        })) setReady(true);
      });
    };

    for (var _iterator = _createForOfIteratorHelperLoose$6(decisions), _step; !(_step = _iterator()).done;) {
      var _ret = _loop();

      if (_ret === "continue") continue;
    }
  }, [decisions, dimMap, FONT_SIZE, FONT_FILE, width, OUTLINE_WIDTH]);
  var objValues = react.useMemo(function () {
    var lines = [];
    var thisLineWidth = 0;
    var thisLineIndex = 0;
    var y = -FONT_SIZE;
    var lastHei = 0; // calculate lines and y positions

    for (var _iterator2 = _createForOfIteratorHelperLoose$6(decisions), _step2; !(_step2 = _iterator2()).done;) {
      var _dimMap$get2, _dimMap$get3;

      var _decision = _step2.value;

      var _wid = (((_dimMap$get2 = dimMap.get(_decision.name)) == null ? void 0 : _dimMap$get2.w) || 0) + PADDING_X * 2 + SPACING_X;

      var hei = ((_dimMap$get3 = dimMap.get(_decision.name)) == null ? void 0 : _dimMap$get3.h) || 0;

      if (thisLineWidth + _wid <= width) {
        if (!lines[thisLineIndex]) lines.push({
          y: y,
          decisions: []
        });
        lines[thisLineIndex].decisions.push(_decision);
        lastHei = hei;
        thisLineWidth += _wid;
      } else {
        var _dimMap$get4;

        // by default, overflow means new line
        thisLineIndex++;

        var _hei = ((_dimMap$get4 = dimMap.get(_decision.name)) == null ? void 0 : _dimMap$get4.h) || 0;

        y -= lastHei / 2 + SPACING_Y + PADDING_Y + _hei / 2;

        if (_hei > FONT_SIZE + OUTLINE_WIDTH * 2) {
          // if it's taller than one line, force it to be on its own line
          lines.push({
            y: y,
            decisions: [_decision]
          });
          y -= _hei / 2 + PADDING_Y + SPACING_Y;
          thisLineIndex++;
          thisLineWidth = 0;
          lastHei = _hei;
        } else {
          // add to this new line
          lines.push({
            y: y,
            decisions: [_decision]
          });
          thisLineWidth += _wid;
          lastHei = _hei;
        }
      }
    } // from lines, calculate x positions by centering each decision within its line


    var objMap = [];

    for (var _i = 0, _lines = lines; _i < _lines.length; _i++) {
      var line = _lines[_i];
      var lineObjMap = []; // place each decision in the center then shift left

      var x = 0;

      for (var _iterator3 = _createForOfIteratorHelperLoose$6(line.decisions), _step3; !(_step3 = _iterator3()).done;) {
        var _dimMap$get;

        var decision = _step3.value;
        var wid = ((_dimMap$get = dimMap.get(decision.name)) == null ? void 0 : _dimMap$get.w) || 0;
        x -= wid / 2;
        lineObjMap.push({
          decision: decision,
          position: [x, line.y, 0]
        });
        x -= wid / 2 + PADDING_X * 2 + SPACING_X;
      } // shift all decisions in the line to the right


      var lineWid = -x - PADDING_X * 2 - SPACING_X;
      var shift = lineWid / 2;

      for (var _i2 = 0, _lineObjMap = lineObjMap; _i2 < _lineObjMap.length; _i2++) {
        var obj = _lineObjMap[_i2];
        obj.position[0] += shift;
      }

      objMap.push.apply(objMap, lineObjMap);
    }

    return objMap;
  }, [decisions, dimMap, width, ready]);

  var _useState3 = react.useState(Math.random()),
      offset = _useState3[0];

  var ideaMap = react.useMemo(function () {
    var map = new Map();

    for (var _iterator4 = _createForOfIteratorHelperLoose$6(decisions), _step4; !(_step4 = _iterator4()).done;) {
      var decision = _step4.value;
      var m = (offset + decisions.indexOf(decision) / decisions.length) % 1;
      var s = 0.7;
      map.set(decision.name, new Idea(m, s, decision.utility || 0.8));
    }

    return map;
  }, [decisions, offset]);
  if (!ready) return null;
  return /*#__PURE__*/React.createElement(React.Fragment, null, objValues.map(function (_ref, i) {
    var decision = _ref.decision,
        position = _ref.position;
    return /*#__PURE__*/React.createElement("group", {
      key: decision.name + i + position.toString(),
      position: position
    }, /*#__PURE__*/React.createElement(FacePlayer, null, /*#__PURE__*/React.createElement(Button$1, {
      font: FONT_FILE,
      fontSize: FONT_SIZE,
      maxWidth: width,
      idea: ideaMap.get(decision.name),
      onClick: function onClick() {
        if (decision.onClick) decision.onClick();
        if (decision.nextKey) setCurKey(decision.nextKey || "");
      }
    }, decision.name)));
  }));
}

function _createForOfIteratorHelperLoose$5(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray$5(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$5(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$5(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$5(o, minLen); }

function _arrayLikeToArray$5(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var FONT_FILE$1 = "https://d27rt3a60hh1lx.cloudfront.net/fonts/Quicksand_Bold.otf";
function VisualInteraction(props) {
  var interaction = props.interaction,
      enabled = props.enabled,
      width = props.width,
      height = props.height,
      setCurKey = props.setCurKey;
  var effect = interaction.effect,
      text = interaction.text,
      input = interaction.input,
      decisions = interaction.decisions;

  var _useState = react.useState(false),
      prevEnabled = _useState[0],
      setPrevEnabled = _useState[1];

  var _useSpring = three$1.useSpring({
    posZ: enabled ? 0.003 : -0.003,
    scaleY: enabled ? 1 : 0
  }),
      posZ = _useSpring.posZ,
      scaleY = _useSpring.scaleY;

  var onSubmit = react.useMemo(function () {
    if (!decisions) return function () {
      return;
    };

    var _loop = function _loop() {
      var decision = _step.value;

      if (decision.name === "submit") {
        return {
          v: function v() {
            if (decision.onClick) decision.onClick();
            if (decision.nextKey) setCurKey(decision.nextKey || "");
          }
        };
      }
    };

    for (var _iterator = _createForOfIteratorHelperLoose$5(decisions), _step; !(_step = _iterator()).done;) {
      var _ret = _loop();

      if (typeof _ret === "object") return _ret.v;
    }
  }, [decisions, setCurKey]);
  react.useEffect(function () {
    if (prevEnabled !== enabled) {
      setPrevEnabled(enabled);

      if (enabled && effect) {
        effect().then(function (newKey) {
          if (newKey) {
            setCurKey(newKey);
          }
        });
      }
    }
  }, [effect, setCurKey, prevEnabled, enabled]);
  var textStyles = {
    font: FONT_FILE$1,
    maxWidth: 0.8,
    textAlign: "center",
    fontSize: 0.06,
    outlineWidth: 0.0065,
    renderOrder: 10
  };
  if (!enabled) return null;
  return /*#__PURE__*/React.createElement(three$1.animated.group, {
    name: "interaction-" + text,
    "position-z": posZ,
    "scale-y": scaleY
  }, /*#__PURE__*/React.createElement(drei.Text, _extends__default["default"]({}, textStyles, {
    anchorY: input ? "bottom" : "middle"
  }), text), input && (input.persist || enabled) && /*#__PURE__*/React.createElement(TextInput, {
    value: input.value,
    onChange: input.setValue,
    "position-y": -0.065,
    onSubmit: onSubmit,
    fontSize: 0.06,
    width: width * 0.825,
    type: input.type === "email" ? "text" : input.type
  }), /*#__PURE__*/React.createElement("group", {
    "position-y": -height / 2
  }, decisions && /*#__PURE__*/React.createElement(VisualDecisions, {
    decisions: decisions,
    width: width,
    setCurKey: setCurKey
  })));
}

var _excluded$e = ["numStops", "enabled", "side", "offset", "dialogue", "face"];
function Dialogue(props) {
  var _props$numStops = props.numStops,
      numStops = _props$numStops === void 0 ? 5 : _props$numStops,
      _props$enabled = props.enabled,
      enabled = _props$enabled === void 0 ? true : _props$enabled,
      _props$side = props.side,
      side = _props$side === void 0 ? "left" : _props$side,
      _props$offset = props.offset,
      offset = _props$offset === void 0 ? [side === "right" ? 0.4 : -0.4, 0, 0] : _props$offset,
      dialogue = props.dialogue,
      _props$face = props.face,
      face = _props$face === void 0 ? true : _props$face,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$e);

  var _useState = react.useState("init"),
      curKey = _useState[0],
      setCurKey = _useState[1];

  var _useSpring = three$1.useSpring({
    scale: enabled ? 1 : 0,
    delay: enabled ? (numStops + 1) * 60 : 0
  }),
      scale = _useSpring.scale;

  var group = react.useRef(null);
  useLimitedFrame(40, function (_ref) {
    var camera = _ref.camera;
    if (!group.current) return;
    group.current.position.x += side === "right" ? WIDTH : -WIDTH;
    group.current.lookAt(camera.position);
    group.current.position.set(0, 0, 0);
  });
  var WIDTH = 1;
  var HEIGHT = 0.35;
  var DEPTH = 0.125;
  var POS_X = side === "right" ? WIDTH / 2 : -WIDTH / 2;
  return /*#__PURE__*/React.createElement("group", _extends__default["default"]({
    name: "dialogue"
  }, rest), /*#__PURE__*/React.createElement(FacePlayer, {
    enabled: face
  }, /*#__PURE__*/React.createElement(Bubbles, {
    numStops: numStops,
    enabled: enabled,
    offset: offset
  }), /*#__PURE__*/React.createElement("group", {
    name: "main-dialogue",
    position: offset
  }, /*#__PURE__*/React.createElement("group", {
    name: "look-at",
    ref: group
  }, /*#__PURE__*/React.createElement(three$1.animated.group, {
    scale: scale,
    "position-x": POS_X
  }, /*#__PURE__*/React.createElement(RoundedBox, {
    args: [WIDTH, HEIGHT, DEPTH],
    material: cache.mat_standard_cream_double
  }), /*#__PURE__*/React.createElement("group", {
    name: "interactions",
    "position-z": DEPTH / 2 + 0.003
  }, dialogue.map(function (interaction) {
    return /*#__PURE__*/React.createElement(VisualInteraction, {
      key: interaction.key,
      interaction: interaction,
      enabled: interaction.key === curKey,
      setCurKey: setCurKey,
      width: WIDTH,
      height: HEIGHT
    });
  })))))));
}

var _excluded$d = ["dark"];
var IMAGE_SRC = "https://d27rt3a60hh1lx.cloudfront.net/images/whiteArrow.png";
var IMAGE_SRC_DARK = "https://d27rt3a60hh1lx.cloudfront.net/images/blackArrow.png";
function Arrow(props) {
  var dark = props.dark,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$d);

  var texture = useImage(dark ? IMAGE_SRC_DARK : IMAGE_SRC);
  var arrowMat = cache.useResource("spacesvr_arrow_" + (dark ? "dark" : "light"), function () {
    return new three.MeshStandardMaterial({
      map: texture,
      alphaTest: 0.5,
      transparent: true
    });
  });
  return /*#__PURE__*/React.createElement("group", _extends__default["default"]({
    name: "spacesvr-arrow"
  }, rest), /*#__PURE__*/React.createElement("mesh", {
    scale: 0.004,
    material: arrowMat
  }, /*#__PURE__*/React.createElement("planeGeometry", {
    args: [98, 51]
  })));
}

var _excluded$c = ["keyCode", "keyPress", "onPress"];
function Key(props) {
  var keyCode = props.keyCode,
      _props$keyPress = props.keyPress,
      keyPress = _props$keyPress === void 0 ? [keyCode] : _props$keyPress,
      onPress = props.onPress,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$c);

  var _useState = react.useState(false),
      pressed = _useState[0],
      setPressed = _useState[1];

  var _useSpring = three$1.useSpring(_extends__default["default"]({
    color: pressed ? "#aaa" : "#fff",
    scale: pressed ? 0.5 : 1
  }, three$1.config.stiff)),
      color = _useSpring.color,
      scale = _useSpring.scale;

  var DEPTH = 0.25;
  react.useEffect(function () {
    var pressed = function pressed(e) {
      return keyPress.map(function (k) {
        return k.toLowerCase();
      }).includes(e.key.toLowerCase());
    };

    var detectDown = function detectDown(e) {
      if (e.key && pressed(e)) setPressed(true);
    };

    var detectUnPress = function detectUnPress(e) {
      if (e.key && pressed(e)) setPressed(false);
    };

    var detectPress = function detectPress(e) {
      if (e.key && pressed(e)) onPress == null ? void 0 : onPress(e);
    };

    document.addEventListener("keydown", detectDown);
    document.addEventListener("keyup", detectUnPress);
    document.addEventListener("keypress", detectPress);
    return function () {
      document.removeEventListener("keydown", detectDown);
      document.removeEventListener("keyup", detectUnPress);
      document.removeEventListener("keypress", detectPress);
    };
  }, [keyPress, onPress]);
  return /*#__PURE__*/React.createElement("group", _extends__default["default"]({
    name: "spacesvr-key"
  }, rest), /*#__PURE__*/React.createElement("group", {
    "position-z": -DEPTH
  }, /*#__PURE__*/React.createElement(three$1.animated.group, {
    "scale-z": scale
  }, /*#__PURE__*/React.createElement("group", {
    "position-z": DEPTH / 2
  }, /*#__PURE__*/React.createElement(RoundedBox, {
    args: [1, 1, DEPTH],
    "position-z": -DEPTH / 2 - 0.01
  }, /*#__PURE__*/React.createElement(three$1.animated.meshStandardMaterial, {
    color: color
  })), /*#__PURE__*/React.createElement(drei.Text, {
    color: "black",
    fontSize: 0.5,
    renderOrder: 2
  }, keyCode)))));
}

var _excluded$b = ["value", "onChange", "raycaster"];
function Switch(props) {
  var value = props.value,
      onChange = props.onChange,
      passedRaycaster = props.raycaster,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$b);

  var _useState = react.useState(false),
      localValue = _useState[0],
      setLocalValue = _useState[1]; // if no value is passed, use local state


  var val = value != null ? value : localValue;

  var setVal = function setVal(v) {
    if (onChange) onChange(v);
    setLocalValue(v);
  };

  var SIZE = 0.075;
  var BORDER = SIZE * 0.05;
  var WIDTH = 2.5 * SIZE;
  var HEIGHT = SIZE * 0.75;
  var DEPTH = WIDTH * 0.1;
  var OUTER_WIDTH = WIDTH + BORDER * 2;
  var OUTER_HEIGHT = HEIGHT + BORDER;
  var KNOB_SIZE = SIZE * 0.8;

  var _useSpring = three$1.useSpring({
    posX: val ? WIDTH / 2 : -WIDTH / 2,
    knobColor: val ? "#417E25" : "#828282",
    config: {
      mass: 0.1
    }
  }),
      posX = _useSpring.posX,
      knobColor = _useSpring.knobColor;

  var _useState2 = react.useState(new Idea(0, 0, 1)),
      onIdea = _useState2[0];

  var _useState3 = react.useState(new Idea(0, 0, 0.75)),
      offIdea = _useState3[0];

  return /*#__PURE__*/React.createElement("group", _extends__default["default"]({
    name: "spacesvr-switch-input"
  }, rest), /*#__PURE__*/React.createElement(three$1.animated.group, {
    "position-x": posX
  }, /*#__PURE__*/React.createElement(VisualIdea, {
    scale: KNOB_SIZE,
    idea: val ? onIdea : offIdea
  })), /*#__PURE__*/React.createElement(HitBox, {
    args: [KNOB_SIZE, KNOB_SIZE, KNOB_SIZE],
    onClick: function onClick() {
      return setVal(!val);
    },
    "position-x": val ? WIDTH / 2 : -WIDTH / 2,
    raycaster: passedRaycaster
  }), /*#__PURE__*/React.createElement(HitBox, {
    args: [OUTER_WIDTH, OUTER_HEIGHT, DEPTH],
    onClick: function onClick() {
      return setVal(!val);
    },
    raycaster: passedRaycaster
  }), /*#__PURE__*/React.createElement(RoundedBox, {
    args: [WIDTH, HEIGHT, DEPTH]
  }, /*#__PURE__*/React.createElement(three$1.animated.meshBasicMaterial, {
    color: knobColor
  })), /*#__PURE__*/React.createElement(RoundedBox, {
    args: [OUTER_WIDTH, OUTER_HEIGHT, DEPTH],
    material: cache.mat_basic_gray,
    "position-z": -0.001
  }));
}

var NetworkContext = /*#__PURE__*/react.createContext({});
var useNetwork = function useNetwork() {
  return react.useContext(NetworkContext);
};

var useListener = function useListener() {
  var cam = fiber.useThree(function (st) {
    return st.camera;
  });
  return react.useMemo(function () {
    var listen = new three.AudioListener();
    cam.add(listen);
    return listen;
  }, [cam]);
};
var useObj = function useObj() {
  return react.useMemo(function () {
    var o = new three.Object3D();
    o.matrixAutoUpdate = false;
    return o;
  }, []);
};

var useEntities = function useEntities() {
  var _useNetwork = useNetwork(),
      connections = _useNetwork.connections,
      connected = _useNetwork.connected,
      mediaConnections = _useNetwork.mediaConnections;

  var _useEnvironment = useEnvironment(),
      paused = _useEnvironment.paused;

  var listener = useListener();

  var _useState = react.useState(0);
      _useState[0];
      var setCt = _useState[1];

  var rerender = function rerender() {
    return setCt(Math.random());
  };

  var _useState2 = react.useState(true),
      firstPaused = _useState2[0],
      setFirstPaused = _useState2[1];

  react.useEffect(function () {
    return setFirstPaused(paused && firstPaused);
  }, [paused, firstPaused]);
  var entities = react.useMemo(function () {
    return [];
  }, []);

  var needsAudio = function needsAudio(e) {
    return mediaConnections.has(e.id) && !e.posAudio;
  }; // check for a change in player list, re-render if there is a change


  useLimitedFrame(3, function () {
    if (!connected) return; // changed flag to trigger re-render at the end

    var changed = false; // remove old entities

    entities.map(function (e) {
      if (!connections.has(e.id)) {
        if (e.posAudio) {
          e.posAudio.remove();
          e.posAudio = undefined;
        }

        entities.splice(entities.indexOf(e), 1);
        changed = true;
      }
    }); // add in new entities

    var _loop = function _loop() {
      var id = _Array$from[_i];

      if (!entities.some(function (e) {
        return e.id === id;
      })) {
        entities.push({
          id: id,
          posAudio: undefined
        });
        changed = true;
      }
    };

    for (var _i = 0, _Array$from = Array.from(connections.keys()); _i < _Array$from.length; _i++) {
      _loop();
    } // dont run until first time unpaused to make sure audio context is running from first press


    if (!firstPaused) {
      // remove media connections streams that are no longer connected
      entities.map(function (e) {
        if (!mediaConnections.has(e.id)) {
          var _e$posAudio;

          (_e$posAudio = e.posAudio) == null ? void 0 : _e$posAudio.remove();
          e.posAudio = undefined;
          changed = true;
        }
      });
      entities.filter(needsAudio).map(function (e) {
        // add in new media connections if the stream is active
        var mediaConn = mediaConnections.get(e.id);
        if (!mediaConn) return;
        if (!mediaConn.remoteStream) return;
        console.log("adding audio for", e.id);
        var audioElem = document.createElement("audio");
        audioElem.srcObject = mediaConn.remoteStream; // remote is incoming, local is own voice

        audioElem.muted = true;
        audioElem.autoplay = true;
        audioElem.loop = true; //@ts-ignore

        audioElem.playsInline = true;
        var posAudio = new three.PositionalAudio(listener);
        posAudio.userData.peerId = e.id;
        posAudio.setMediaStreamSource(audioElem.srcObject);
        posAudio.setRefDistance(2);
        posAudio.setDirectionalCone(200, 290, 0.35); // posAudio.add(new PositionalAudioHelper(posAudio, 1));

        e.posAudio = posAudio;
        changed = true;
      });
    }

    if (changed) rerender();
  });
  return entities;
};

function _createForOfIteratorHelperLoose$4(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray$4(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$4(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$4(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$4(o, minLen); }

function _arrayLikeToArray$4(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
function NetworkedEntities() {
  var _useNetwork = useNetwork(),
      connected = _useNetwork.connected,
      useChannel = _useNetwork.useChannel;

  var mesh = react.useRef(null);
  var geo = react.useMemo(function () {
    return new three.CylinderGeometry(0.3, 0.3, 1, 32);
  }, []);
  var mat = react.useMemo(function () {
    return new three.MeshNormalMaterial();
  }, []);
  var obj = useObj();
  var entities = useEntities(); // set up channel to send/receive data

  var NETWORK_FPS = 12;
  var SI = react.useMemo(function () {
    return new snapshotInterpolation.SnapshotInterpolation(NETWORK_FPS);
  }, []);
  var entityChannel = useChannel("player", "stream", function (m, s) {
    if (!m.conn) return;
    s[m.conn.peer] = m.data;
    var state = Object.keys(s).map(function (key) {
      return {
        id: key,
        x: s[key].pos[0],
        y: s[key].pos[1],
        z: s[key].pos[2],
        q: {
          x: s[key].rot[0],
          y: s[key].rot[1],
          z: s[key].rot[2],
          w: s[key].rot[3]
        }
      };
    });
    SI.vault.add({
      id: Math.random().toString(),
      time: new Date().getTime(),
      state: state
    });
  }); // send own player data

  useLimitedFrame(NETWORK_FPS, function (_ref) {
    var camera = _ref.camera;
    if (!connected) return;
    entityChannel.send({
      pos: camera.position.toArray(),
      rot: camera.quaternion.toArray()
    });
  }); // receive player data

  useLimitedFrame(55, function () {
    if (!mesh.current) return;
    var snapshot = SI.calcInterpolation("x y z q(quat)");
    if (!snapshot) return;
    var i = 0;

    for (var _iterator = _createForOfIteratorHelperLoose$4(snapshot.state), _step; !(_step = _iterator()).done;) {
      var _entities$i;

      var entityState = _step.value;
      var x = entityState.x,
          y = entityState.y,
          z = entityState.z,
          q = entityState.q;
      obj.position.set(x, y, z);
      obj.position.y -= 0.2; // they were floating before, idk where the constant comes from really

      var quat = q;
      obj.quaternion.set(quat.x, quat.y, quat.z, quat.w);
      obj.updateMatrix();
      mesh.current.setMatrixAt(i, obj.matrix);
      var posAudio = (_entities$i = entities[i]) == null ? void 0 : _entities$i.posAudio;

      if (posAudio) {
        obj.matrix.decompose(posAudio.position, posAudio.quaternion, posAudio.scale);
        posAudio.rotation.y += Math.PI; // for some reason it's flipped

        posAudio.updateMatrix();
      }

      i++;
    }

    mesh.current.instanceMatrix.needsUpdate = true;
  });

  if (!connected) {
    return null;
  }

  return /*#__PURE__*/React.createElement("group", {
    name: "spacesvr-entities"
  }, entities.map(function (entity) {
    return entity.posAudio && /*#__PURE__*/React.createElement("primitive", {
      key: entity.posAudio.uuid,
      object: entity.posAudio,
      matrixAutoUpdate: false
    });
  }), /*#__PURE__*/React.createElement("instancedMesh", {
    ref: mesh,
    args: [geo, mat, entities.length],
    matrixAutoUpdate: false
  }));
}

var isLocalNetwork = function isLocalNetwork(hostname) {
  if (hostname === void 0) {
    hostname = window.location.hostname;
  }

  return ["localhost", "127.0.0.1", "", "::1"].includes(hostname) || hostname.startsWith("192.168.") || hostname.startsWith("10.0.") || hostname.endsWith(".local");
};

var SESSION_ID = "spacesvr-local-signalling";
var TIMEOUT_MIN = 1.25;
var LocalSignaller = /*#__PURE__*/function () {
  function LocalSignaller(peer) {
    console.info("using local signaller");
    if (peer.id) this.peerId = peer.id;
  }

  var _proto = LocalSignaller.prototype;

  _proto.readStore = function readStore() {
    var str = localStorage.getItem(SESSION_ID);
    if (!str) return [];

    try {
      return JSON.parse(str);
    } catch (err) {
      return [];
    }
  };

  _proto.writeStore = function writeStore(peers) {
    localStorage.setItem(SESSION_ID, JSON.stringify(peers));
  };

  _proto.cleanStore = function cleanStore() {
    var peers = this.readStore();
    var time = new Date().getTime();
    var newPeers = peers.filter(function (peer) {
      var keep = time - peer.last_seen <= TIMEOUT_MIN * 60 * 1000;
      if (!keep) console.info("removing local peer with id ", peer.id);
      return keep;
    });
    this.writeStore(newPeers);
  };

  _proto.join = /*#__PURE__*/function () {
    var _join = _asyncToGenerator__default["default"]( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
      var peer, peers;
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              if (this.peerId) {
                _context.next = 3;
                break;
              }

              console.error("peer id not established, aborting signal");
              return _context.abrupt("return");

            case 3:
              this.cleanStore();
              console.info("local network detected, signalling with localStorage");
              peer = {
                id: this.peerId,
                last_seen: new Date().getTime()
              };
              peers = this.readStore();
              peers.push(peer);
              this.writeStore(peers);
              return _context.abrupt("return", peers.map(function (peer) {
                return peer.id;
              }));

            case 10:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function join() {
      return _join.apply(this, arguments);
    }

    return join;
  }();

  _proto.leave = /*#__PURE__*/function () {
    var _leave = _asyncToGenerator__default["default"]( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      var _this = this;

      var peers, index;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (this.peerId) {
                _context2.next = 3;
                break;
              }

              console.error("peer id not established, aborting signal");
              return _context2.abrupt("return");

            case 3:
              console.info("updating local signal list to remove self");
              peers = this.readStore();
              index = peers.findIndex(function (peer) {
                return peer.id === _this.peerId;
              });

              if (index < 0) {
                console.error("peer not in local signal list, aborting ...");
              } else {
                peers.splice(index, 1);
                this.writeStore(peers);
              }

            case 7:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function leave() {
      return _leave.apply(this, arguments);
    }

    return leave;
  }();

  _proto.wave = /*#__PURE__*/function () {
    var _wave = _asyncToGenerator__default["default"]( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
      var _this2 = this;

      var peers, foundAndUpdated;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (this.peerId) {
                _context3.next = 3;
                break;
              }

              console.error("peer id not established, wave failed");
              return _context3.abrupt("return", false);

            case 3:
              peers = this.readStore();
              foundAndUpdated = false;
              peers.map(function (peer) {
                if (peer.id === _this2.peerId) {
                  peer.last_seen = new Date().getTime();
                  foundAndUpdated = true;
                }
              });
              this.writeStore(peers);
              return _context3.abrupt("return", foundAndUpdated);

            case 8:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function wave() {
      return _wave.apply(this, arguments);
    }

    return wave;
  }();

  return LocalSignaller;
}();

var MuseSignaller = /*#__PURE__*/function () {
  function MuseSignaller(peer, config) {
    if (config === void 0) {
      config = {};
    }

    console.info("using muse signaller"); // set up signalling identification

    if (config.sessionId) this.sessionId = config.sessionId;else if (config.worldName) this.worldName = config.worldName;else this.worldName = window.location.pathname; // where to point requests to

    this.host = config.host || "https://muse-web.onrender.com";
    if (config.sessionPassword) this.sessionPassword = config.sessionPassword;
    if (peer.id) this.peerId = peer.id;
  }

  var _proto = MuseSignaller.prototype;

  _proto.callBackend = /*#__PURE__*/function () {
    var _callBackend = _asyncToGenerator__default["default"]( /*#__PURE__*/regeneratorRuntime.mark(function _callee(path, body) {
      return regeneratorRuntime.wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return fetch(this.host + "/sessions/" + path, {
                method: "POST",
                body: JSON.stringify(body),
                headers: {
                  "Content-Type": "application/json"
                }
              });

            case 2:
              return _context.abrupt("return", _context.sent);

            case 3:
            case "end":
              return _context.stop();
          }
        }
      }, _callee, this);
    }));

    function callBackend(_x, _x2) {
      return _callBackend.apply(this, arguments);
    }

    return callBackend;
  }();

  _proto.join = /*#__PURE__*/function () {
    var _join = _asyncToGenerator__default["default"]( /*#__PURE__*/regeneratorRuntime.mark(function _callee2() {
      var body, response, json;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              if (this.peerId) {
                _context2.next = 3;
                break;
              }

              console.error("peer id not established, aborting signal");
              return _context2.abrupt("return");

            case 3:
              body = {
                peer_id: this.peerId
              };
              if (this.sessionId) body.session_id = this.sessionId;else body.world = this.worldName;
              if (this.sessionPassword) body.password = this.sessionPassword;
              _context2.next = 8;
              return this.callBackend("join", body);

            case 8:
              response = _context2.sent;
              _context2.next = 11;
              return response.json();

            case 11:
              json = _context2.sent;

              if (!(response.status !== 200)) {
                _context2.next = 16;
                break;
              }

              json = json;
              console.error("failed to signal: ", json.message);
              return _context2.abrupt("return", undefined);

            case 16:
              json = json;
              this.sessionId = json.session_id;
              return _context2.abrupt("return", json.peer_ids);

            case 19:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2, this);
    }));

    function join() {
      return _join.apply(this, arguments);
    }

    return join;
  }();

  _proto.leave = /*#__PURE__*/function () {
    var _leave = _asyncToGenerator__default["default"]( /*#__PURE__*/regeneratorRuntime.mark(function _callee3() {
      var body, response, json;
      return regeneratorRuntime.wrap(function _callee3$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              if (!(!this.sessionId || !this.peerId)) {
                _context3.next = 3;
                break;
              }

              console.error("no session id / peer id, can't leave");
              return _context3.abrupt("return");

            case 3:
              body = {
                peer_id: this.peerId,
                session_id: this.sessionId
              };
              _context3.next = 6;
              return this.callBackend("leave", body);

            case 6:
              response = _context3.sent;

              if (!(response.status !== 200)) {
                _context3.next = 12;
                break;
              }

              _context3.next = 10;
              return response.json();

            case 10:
              json = _context3.sent;
              console.error("leave failed ... ", json.message);

            case 12:
            case "end":
              return _context3.stop();
          }
        }
      }, _callee3, this);
    }));

    function leave() {
      return _leave.apply(this, arguments);
    }

    return leave;
  }();

  _proto.wave = /*#__PURE__*/function () {
    var _wave = _asyncToGenerator__default["default"]( /*#__PURE__*/regeneratorRuntime.mark(function _callee4() {
      var body, response, json;
      return regeneratorRuntime.wrap(function _callee4$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              if (!(!this.sessionId || !this.peerId)) {
                _context4.next = 3;
                break;
              }

              console.error("no session id / peer id, can't wave");
              return _context4.abrupt("return", false);

            case 3:
              body = {
                peer_id: this.peerId,
                session_id: this.sessionId
              };
              _context4.next = 6;
              return this.callBackend("wave", body);

            case 6:
              response = _context4.sent;

              if (!(response.status !== 200)) {
                _context4.next = 13;
                break;
              }

              _context4.next = 10;
              return response.json();

            case 10:
              json = _context4.sent;
              console.error("wave check failed ... ", json.message);
              return _context4.abrupt("return", false);

            case 13:
              return _context4.abrupt("return", true);

            case 14:
            case "end":
              return _context4.stop();
          }
        }
      }, _callee4, this);
    }));

    function wave() {
      return _wave.apply(this, arguments);
    }

    return wave;
  }();

  return MuseSignaller;
}();

var MAX_TRIES = 4;
var useWaving = function useWaving(minuteFrequency, singaller, disconnect) {
  var numFailed = react.useRef(0);
  var waveLimiter = useLimiter(1 / (minuteFrequency * 60));
  var failLimiter = useLimiter(1 / 10);
  fiber.useFrame(function (_ref) {
    var clock = _ref.clock;
    if (!singaller || numFailed.current > MAX_TRIES) return;
    var FAIL_STATE = numFailed.current > 0;

    if (!(FAIL_STATE ? failLimiter : waveLimiter).isReady(clock)) {
      return;
    }

    singaller.wave().then(function (succeeded) {
      if (!succeeded) {
        numFailed.current += 1;
      } else {
        numFailed.current = 0;
      }

      if (numFailed.current > MAX_TRIES) {
        console.error("too many failed waves, disconnecting ...");
        disconnect();
      }
    });
  });
};

function _createForOfIteratorHelperLoose$3(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray$3(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$3(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$3(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$3(o, minLen); }

function _arrayLikeToArray$3(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * The most basic channel type just sends data to all the peers and receives
 * the same data.
 *
 * The state built locally, where the intention is that it can be recovered
 * on the fly.
 *
 * This is best used for data like streaming player position/rotation, where
 * old values don't matter.
 */
var StreamChannel = /*#__PURE__*/function () {
  function StreamChannel(id, reducer, connections) {
    this.id = id;
    this.reducer = reducer;
    this.connections = connections;
    this.state = {};
  }

  var _proto = StreamChannel.prototype;

  _proto.send = function send(data) {
    for (var _iterator = _createForOfIteratorHelperLoose$3(this.connections.entries()), _step; !(_step = _iterator()).done;) {
      var _step$value = _step.value,
          conn = _step$value[1];

      if (conn.open) {
        conn.send({
          id: this.id,
          data: data
        });
      }
    }
  };

  _proto.receive = function receive(message) {
    this.reducer(message, this.state);
  };

  return StreamChannel;
}();

function _createForOfIteratorHelperLoose$2(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray$2(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$2(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$2(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$2(o, minLen); }

function _arrayLikeToArray$2(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * This Channel is responsible for keeping one state synchronized across
 * all peers. It does this by keeping one local state.
 *
 * Every time a new connection appears, you "greet" them with a new state and a time
 * to represent when the peer was instantiated, letting older peers take precedence.
 *
 */
var SyncChannel = /*#__PURE__*/function () {
  function SyncChannel(id, reducer, connections) {
    this.id = id;
    this.reducer = reducer;
    this.initTime = new Date().getTime();
    this.connections = connections;
    this.state = {};
  }

  var _proto = SyncChannel.prototype;

  _proto.send = function send(data) {
    for (var _iterator = _createForOfIteratorHelperLoose$2(this.connections.entries()), _step; !(_step = _iterator()).done;) {
      var _step$value = _step.value,
          conn = _step$value[1];

      if (conn.open) {
        conn.send({
          id: this.id,
          data: data
        });
      }
    }

    this.reducer({
      id: this.id,
      data: data
    }, this.state);
  };

  _proto.receive = function receive(message) {
    if (message.greet) {
      if (message.time && message.state) {
        if (message.time < this.initTime) {
          this.state = message.state;
          this.initTime = message.time - 50; // add a buffer in case same peer sends it twice
        }
      }
    } else {
      this.reducer(message, this.state);
    }
  };

  _proto.greet = function greet(conn) {
    conn.send({
      id: this.id,
      time: this.initTime,
      state: this.state,
      greet: true
    });
  };

  return SyncChannel;
}();

function _createForOfIteratorHelperLoose$1(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray$1(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray$1(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray$1(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray$1(o, minLen); }

function _arrayLikeToArray$1(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
var useChannels = function useChannels(connections) {
  var channels = react.useMemo(function () {
    return new Map();
  }, []);

  var receive = function receive(message) {
    for (var _iterator = _createForOfIteratorHelperLoose$1(channels.entries()), _step; !(_step = _iterator()).done;) {
      var _step$value = _step.value,
          _id = _step$value[0],
          channel = _step$value[1];

      if (_id == message.id) {
        channel.receive(message);
      }
    }
  };

  var greet = function greet(conn) {
    for (var _iterator2 = _createForOfIteratorHelperLoose$1(channels.entries()), _step2; !(_step2 = _iterator2()).done;) {
      var _step2$value = _step2.value,
          channel = _step2$value[1];

      if (channel instanceof SyncChannel) {
        channel.greet(conn);
      }
    }
  };

  var useChannel = function useChannel(id, type, reducer) {
    var channel = react.useMemo(function () {
      if (type === "stream") return new StreamChannel(id, reducer, connections);
      if (type === "sync") return new SyncChannel(id, reducer, connections);
      return new StreamChannel(id, reducer, connections);
    }, [id, type]); // keep reducer up to date

    react.useEffect(function () {
      channel.reducer = reducer;
    }, [channel, reducer]); // keep channel registered

    react.useEffect(function () {
      if (channels.has(channel.id)) {
        throw new Error("id '" + channel.id + "' has been taken, can't register channel ...");
      } else {
        channels.set(channel.id, channel);
      }

      return function () {
        if (!channels.has(channel.id)) return;
        channels["delete"](channel.id);
      };
    }, [channel]);
    return channel;
  };

  return {
    receive: receive,
    greet: greet,
    useChannel: useChannel
  };
};

/**
 * WHen enabled, will ask user for mic permissions and return the local microphone stream
 * @param enabled
 */

var useMicrophone = function useMicrophone(enabled, inputDeviceId) {
  if (enabled === void 0) {
    enabled = true;
  }

  var _useEnvironment = useEnvironment(),
      paused = _useEnvironment.paused;

  var _useState = react.useState(true),
      firstPaused = _useState[0],
      setFirstPaused = _useState[1];

  react.useEffect(function () {
    return setFirstPaused(paused && firstPaused);
  }, [paused, firstPaused]);

  function iOS() {
    return ["iPad Simulator", "iPhone Simulator", "iPod Simulator", "iPad", "iPhone", "iPod"].includes(navigator.platform) || // iPad on iOS 13 detection
    navigator.userAgent.includes("Mac") && "ontouchend" in document;
  }

  var _useState2 = react.useState(),
      localStream = _useState2[0],
      setLocalStream = _useState2[1]; // attempt to request permission for microphone, only try once


  react.useEffect(function () {
    var _navigator$mediaDevic;

    // https://bugs.webkit.org/show_bug.cgi?id=230902#c47
    if (!enabled || iOS() && firstPaused) return;
    (_navigator$mediaDevic = navigator.mediaDevices) == null ? void 0 : _navigator$mediaDevic.getUserMedia({
      audio: _extends__default["default"]({
        echoCancellation: true,
        noiseSuppression: true,
        autoGainControl: true
      }, inputDeviceId ? {
        deviceId: inputDeviceId
      } : {})
    }).then(function (stream) {
      setLocalStream(stream);
    })["catch"](function (err) {
      console.error(err);
    });
  }, [enabled, firstPaused, inputDeviceId]);
  return localStream;
};

function _createForOfIteratorHelperLoose(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (it) return (it = it.call(o)).next.bind(it); if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; return function () { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }

function _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
/**
 * When enabled, is responsible for requesting mic permissions, calling and answering peers to create media connections,
 * and closing media connections on disable
 *
 * @param enabled
 * @param peer
 * @param connections
 */

var useVoiceConnections = function useVoiceConnections(enabled, peer, connections, inputDeviceId) {
  var mediaConns = react.useMemo(function () {
    return new Map();
  }, []);
  var localStream = useMicrophone(enabled, inputDeviceId); // handle calling and answering peers

  react.useEffect(function () {
    if (!peer || !localStream || !enabled) return; // handle a new media connection (incoming or created

    var handleMediaConn = function handleMediaConn(mediaConn) {
      console.log("media connection opened with peer", mediaConn.peer);
      mediaConn.answer(localStream);
      mediaConns.set(mediaConn.peer, mediaConn);
      mediaConn.on("close", function () {
        console.log("closing voice stream with peer", mediaConn.peer);
        mediaConns["delete"](mediaConn.peer);
      });
      mediaConn.on("error", function (err) {
        console.error("error with voice stream with peer", mediaConn.peer, err);
        mediaConns["delete"](mediaConn.peer);
      });
    };

    var call = function call(conn) {
      console.log("calling peer with id", conn.peer);
      handleMediaConn(peer.call(conn.peer, localStream));
      conn.on("close", function () {
        console.log("closing voice stream with peer", conn.peer);
        mediaConns["delete"](conn.peer);
      });
    };

    var handleDataConn = function handleDataConn(conn) {
      conn.on("open", function () {
        return call(conn);
      });
    }; // set up incoming and outgoing calls for any future connections


    peer.on("call", handleMediaConn);
    peer.on("connection", handleDataConn); // call any already connected peers

    for (var _iterator = _createForOfIteratorHelperLoose(connections), _step; !(_step = _iterator()).done;) {
      var _step$value = _step.value,
          peerId = _step$value[0],
          conn = _step$value[1];
      if (mediaConns.has(peerId)) return;
      call(conn);
    }

    return function () {
      peer.removeListener("call", handleMediaConn);
      peer.removeListener("connection", call);
    };
  }, [connections, peer, localStream, mediaConns, enabled]); // close all media connections with peers on disable

  react.useEffect(function () {
    if (!enabled) {
      mediaConns.forEach(function (conn) {
        conn.close();
        mediaConns["delete"](conn.peer);
      });
    }
  }, [enabled, mediaConns]);
  return {
    mediaConnections: mediaConns,
    localStream: localStream
  };
};

var KEY = "spacesvr-ice-servers"; // 24 hours

var EXPIRE_TIME = 24 * 60 * 60 * 1000;

var storeLocalIceServers = function storeLocalIceServers(servers) {
  var store = {
    iceServers: servers,
    time: new Date().getTime()
  };
  localStorage.setItem(KEY, JSON.stringify(store));
};

var getLocalIceServers = function getLocalIceServers() {
  var str = localStorage.getItem(KEY);
  if (!str) return undefined;

  try {
    var res = JSON.parse(str); // clear if expired

    if (new Date().getTime() - res.time > EXPIRE_TIME) {
      localStorage.removeItem(KEY);
      return undefined;
    }

    return res.iceServers;
  } catch (err) {
    return undefined;
  }
};

var getMuseIceServers = /*#__PURE__*/function () {
  var _ref = _asyncToGenerator__default["default"]( /*#__PURE__*/regeneratorRuntime.mark(function _callee(host) {
    var local, res, json, servers;
    return regeneratorRuntime.wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            if (host === void 0) {
              host = "https://muse-web.onrender.com";
            }

            local = getLocalIceServers();

            if (!local) {
              _context.next = 4;
              break;
            }

            return _context.abrupt("return", local);

          case 4:
            _context.prev = 4;
            _context.next = 7;
            return fetch(host + "/sessions/get_ice");

          case 7:
            res = _context.sent;
            _context.next = 10;
            return res.json();

          case 10:
            json = _context.sent;
            servers = json.iceServers;
            storeLocalIceServers(servers);
            return _context.abrupt("return", servers);

          case 16:
            _context.prev = 16;
            _context.t0 = _context["catch"](4);
            console.error("failed to fetch ice servers", _context.t0);
            return _context.abrupt("return", undefined);

          case 20:
          case "end":
            return _context.stop();
        }
      }
    }, _callee, null, [[4, 16]]);
  }));

  return function getMuseIceServers(_x) {
    return _ref.apply(this, arguments);
  };
}();

var useConnection = function useConnection(externalConfig) {
  var _useState = react.useState(false),
      connected = _useState[0],
      setConnected = _useState[1];

  var _useState2 = react.useState(),
      peer = _useState2[0],
      setPeer = _useState2[1];

  var connections = react.useMemo(function () {
    return new Map();
  }, []);

  var _useState3 = react.useState(),
      signaller = _useState3[0],
      setSignaller = _useState3[1];

  var channels = useChannels(connections); // given any connection, store and set up data channels

  var registerConnection = function registerConnection(conn) {
    conn.on("open", function () {
      console.log("connection opened with peer", conn.peer);
      conn.on("data", function (message) {
        return channels.receive(_extends__default["default"]({
          conn: conn
        }, message));
      });
      conn.on("close", function () {
        console.log("connection closed with peer");
        connections["delete"](conn.peer);
      });
      conn.on("error", function () {
        console.log("connection closed with peer");
        connections["delete"](conn.peer);
      });
      channels.greet(conn);
      connections.set(conn.peer, conn);
    });
  }; // attempt to connect to a p2p network


  var connect = /*#__PURE__*/function () {
    var _ref = _asyncToGenerator__default["default"]( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(config) {
      var finalConfig, servers, peerConfig, p;
      return regeneratorRuntime.wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              console.log("connecting to network");

              if (!peer) {
                _context2.next = 4;
                break;
              }

              console.error("peer already created, aborting");
              return _context2.abrupt("return");

            case 4:
              if (!connected) {
                _context2.next = 7;
                break;
              }

              console.error("already connected, aborting");
              return _context2.abrupt("return");

            case 7:
              finalConfig = _extends__default["default"]({}, externalConfig, config);

              if (finalConfig.iceServers) {
                _context2.next = 13;
                break;
              }

              _context2.next = 11;
              return getMuseIceServers(finalConfig.host);

            case 11:
              servers = _context2.sent;
              if (servers) finalConfig.iceServers = servers;

            case 13:
              peerConfig = {};
              if (finalConfig.iceServers) peerConfig.iceServers = finalConfig.iceServers;
              p = new peerjs.Peer({
                config: peerConfig
              });
              p.on("connection", registerConnection); // incoming

              p.on("close", disconnect);
              p.on("error", function (err) {
                if (err.message.includes("Could not connect to peer")) {
                  var messageWords = err.message.split(" ");
                  var connId = messageWords[messageWords.length - 1];
                  console.error("could not establish connection to peer " + connId);
                } else {
                  console.error(err);
                }
              });
              p.on("open", /*#__PURE__*/_asyncToGenerator__default["default"]( /*#__PURE__*/regeneratorRuntime.mark(function _callee() {
                var s, ids;
                return regeneratorRuntime.wrap(function _callee$(_context) {
                  while (1) {
                    switch (_context.prev = _context.next) {
                      case 0:
                        setConnected(true);
                        s = isLocalNetwork() && !finalConfig.host ? new LocalSignaller(p) : new MuseSignaller(p, finalConfig);
                        _context.next = 4;
                        return s.join();

                      case 4:
                        ids = _context.sent;
                        console.log("found peers:", ids);

                        if (ids) {
                          _context.next = 8;
                          break;
                        }

                        return _context.abrupt("return");

                      case 8:
                        ids.map(function (id) {
                          if (id === p.id) return;
                          var conn = p.connect(id);
                          registerConnection(conn);
                        });
                        setPeer(p);
                        setSignaller(s);

                      case 11:
                      case "end":
                        return _context.stop();
                    }
                  }
                }, _callee);
              })));

            case 20:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));

    return function connect(_x) {
      return _ref.apply(this, arguments);
    };
  }(); // attempt to disconnect from a p2p network


  var disconnect = function disconnect() {
    console.log("disconnecting from network");

    if (!connected) {
      console.error("not connected, no need to disconnect");
      return;
    }

    if (!peer) {
      console.error("peer doesn't exist, no need to disconnect");
      return;
    }

    if (!peer.disconnected) peer.disconnect();
    if (signaller) signaller.leave();
    connections.forEach(function (conn) {
      return conn.close();
    });
    peer.destroy();
    setConnected(false);
    setPeer(undefined);
  };

  useWaving(1, signaller, disconnect);

  var _useState4 = react.useState(!!externalConfig.voice),
      voice = _useState4[0],
      setVoice = _useState4[1];

  var _useState5 = react.useState(),
      inputDeviceId = _useState5[0],
      setInputDevice = _useState5[1];

  react.useEffect(function () {
    return setVoice(!!externalConfig.voice);
  }, [externalConfig.voice]);

  var _useVoiceConnections = useVoiceConnections(voice, peer, connections, inputDeviceId),
      mediaConnections = _useVoiceConnections.mediaConnections,
      localStream = _useVoiceConnections.localStream;

  return {
    connected: connected,
    connect: connect,
    disconnect: disconnect,
    connections: connections,
    useChannel: channels.useChannel,
    voice: voice,
    setVoice: setVoice,
    localStream: localStream,
    mediaConnections: mediaConnections,
    setInputDevice: setInputDevice
  };
};

var _excluded$a = ["time"];
var useModifiedStandardShader = function useModifiedStandardShader(config, vert, frag) {
  var _config$time = config.time,
      time = _config$time === void 0 ? true : _config$time,
      rest = _objectWithoutPropertiesLoose__default["default"](config, _excluded$a);

  var mat = react.useMemo(function () {
    var material = new three.MeshStandardMaterial(_extends__default["default"]({
      side: three.DoubleSide
    }, rest));

    material.onBeforeCompile = function (shader) {
      shader.uniforms.time = new three.Uniform(0);
      var uniforms = "\n        varying vec2 vUv;\n        varying vec3 vNorm;\n        varying vec3 vPos;\n        uniform float time;\n      ";
      var varyingSet = "\n        vUv = uv;\n        vPos = (modelMatrix * vec4(transformed, 1.0)).xyz;\n      ";
      shader.vertexShader = uniforms + shader.vertexShader.replace("#include <worldpos_vertex>", vert + varyingSet + "\n#include <worldpos_vertex>\n");
      shader.vertexShader = shader.vertexShader.replace("#include <begin_vertex>", "#include <begin_vertex>\n" + "vNorm = normal;\n"); // gets inserted right here: https://github.com/mrdoob/three.js/blob/f16386d8bb3db60ce4f6254ccf006c2e0b90bc1c/src/renderers/shaders/ShaderLib/meshphysical.glsl.js#L171

      shader.fragmentShader = uniforms + shader.fragmentShader.replace("#include <emissivemap_fragment>", "#include <emissivemap_fragment>\n" + frag);
      material.userData.shader = shader;
    };

    material.customProgramCacheKey = function () {
      return frag + vert + JSON.stringify(rest);
    };

    return material;
  }, [frag, rest, time, vert]);
  useLimitedFrame(70, function (_ref) {
    var _mat$userData$shader, _mat$userData$shader$;

    var clock = _ref.clock;
    if (!time || !((_mat$userData$shader = mat.userData.shader) != null && (_mat$userData$shader$ = _mat$userData$shader.uniforms) != null && _mat$userData$shader$.time)) return;
    mat.userData.shader.uniforms.time.value = clock.elapsedTime;
  });
  return mat;
};

var vert = "\n";
var GRAY = "vec3(0.6)";
var frag = "\n    diffuseColor.rgb = " + GRAY + ";\n    \n    // apply grip\n    float radius = 0.25;\n    vec2 l = (fract((vUv - vec2(0.21, 0.)) * vec2(9., 0.)) - vec2(0.5, 0.));\n    float blur = 5.;\n    float circle_mask = 1.0 - smoothstep(radius - (radius * blur),radius + (radius * blur),dot(l,l) * 2.0);\n    float side_mask = pow(abs(dot(vNorm, vec3(1.0, 0.0, 0.0))), 0.9);\n    float up_mask = 0.2 * pow(dot(vNorm, vec3(0.0, 1.0, 0.0)), 1.);\n    float grip_mask = min(1., (side_mask + up_mask)) * circle_mask;\n    diffuseColor.rgb *= clamp(1. - (0.8 * grip_mask), 0., 1.);\n    \n    // apply speaker and mic\n    // create mask for facing the camera\n    float facing_mask = pow(clamp(dot(vNorm, vec3(0., 0., 1.0)), 0., 1.), 2000.);\n    // create a mask for the bottom of the phone\n    float bottom_mask = smoothstep(0.0, 0.2, abs(vUv.y + 0.1));\n    float speaker_mask = facing_mask * bottom_mask;\n    // diffuseColor.rgb = mix(diffuseColor.rgb, vec3(0.9), speaker_mask);\n";

function TalkieModel(props) {
  var width = props.width,
      height = props.height,
      depth = props.depth;
  var mat = useModifiedStandardShader({
    color: "#cbcbcb"
  }, vert, frag);
  var ANTENNA_WIDTH = width * 0.22;
  var ANTENNA_HEIGHT = height * 0.45;
  return /*#__PURE__*/React.createElement("group", {
    name: "model"
  }, /*#__PURE__*/React.createElement(RoundedBox, {
    args: [width, height, depth],
    material: mat
  }), /*#__PURE__*/React.createElement(RoundedBox, {
    args: [ANTENNA_WIDTH, ANTENNA_HEIGHT, depth],
    material: mat,
    "position-x": -width / 2 + ANTENNA_WIDTH / 2,
    "position-y": height / 2
  }));
}

var _excluded$9 = ["width", "height", "children"];
function Pane(props) {
  var width = props.width,
      height = props.height,
      children = props.children,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$9);

  var BORDER = 0.0075;
  return /*#__PURE__*/React.createElement("group", _extends__default["default"]({
    name: "pane"
  }, rest), /*#__PURE__*/React.createElement("mesh", {
    material: cache.mat_standard_black
  }, /*#__PURE__*/React.createElement("planeGeometry", {
    args: [width + BORDER * 2, height + BORDER * 2]
  })), /*#__PURE__*/React.createElement("mesh", {
    "position-z": 0.001
  }, /*#__PURE__*/React.createElement("planeGeometry", {
    args: [width, height]
  }), /*#__PURE__*/React.createElement("meshStandardMaterial", {
    color: "#20C20E"
  })), /*#__PURE__*/React.createElement("group", {
    name: "content",
    "position-z": 0.002
  }, children));
}

var _excluded$8 = ["onClick", "width", "children", "index"];
function Option(props) {
  var onClick = props.onClick,
      width = props.width,
      children = props.children,
      index = props.index,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$8);

  var _useState = react.useState(false),
      hovered = _useState[0],
      setHovered = _useState[1];

  var _useSpring = three$1.useSpring({
    color: hovered ? "#b3b3b3" : "#ffffff"
  }),
      color = _useSpring.color;

  var PADDING_X = 0.015;
  var PADDING_Y = 0.0125;
  var FONT_SIZE = 0.02;
  var DEPTH = 0.01;
  var CLIP_WIDTH = index === 0 ? width - PADDING_X * 4 : width - PADDING_X * 2;
  return /*#__PURE__*/React.createElement("group", _extends__default["default"]({
    name: "option"
  }, rest), /*#__PURE__*/React.createElement(RoundedBox, {
    args: [width, FONT_SIZE + PADDING_Y * 2, DEPTH]
  }, /*#__PURE__*/React.createElement(three$1.animated.meshStandardMaterial, {
    color: color
  })), /*#__PURE__*/React.createElement(HitBox, {
    args: [width, FONT_SIZE + PADDING_Y * 2, DEPTH],
    onClick: onClick,
    onHover: function onHover() {
      return setHovered(true);
    },
    onUnHover: function onUnHover() {
      return setHovered(false);
    }
  }), /*#__PURE__*/React.createElement("group", {
    "position-z": DEPTH / 2 + 0.001
  }, /*#__PURE__*/React.createElement(drei.Text, {
    fontSize: FONT_SIZE,
    color: "black",
    anchorX: "left",
    "position-x": -width / 2 + PADDING_X,
    maxWidth: width // @ts-ignore
    ,
    whiteSpace: "nowrap",
    clipRect: [0, -Infinity, CLIP_WIDTH, Infinity]
  }, children)));
}

var _excluded$7 = ["value", "items", "onChange", "width"];
function DropDown(props) {
  var _items$find;

  var value = props.value,
      items = props.items,
      onChange = props.onChange,
      _props$width = props.width,
      width = _props$width === void 0 ? 1 : _props$width,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$7);

  var _useState = react.useState(false),
      reset = _useState[0],
      setReset = _useState[1];

  var _useState2 = react.useState(false),
      open = _useState2[0],
      setOpen = _useState2[1];

  var _useState3 = react.useState(0),
      localIndex = _useState3[0],
      setLocalIndex = _useState3[1];

  var val = (_items$find = items.find(function (it) {
    return it.value == value;
  })) != null ? _items$find : items[localIndex];

  var setVal = function setVal(value) {
    var ind = items.findIndex(function (it) {
      return it.value == value;
    });
    if (ind === -1) return;
    if (onChange) onChange(items[ind]);
    setLocalIndex(ind);
  }; // keep local index up to date with incoming value


  react.useEffect(function () {
    if (!val) return;
    var ind = items.findIndex(function (item) {
      return item.value === (val == null ? void 0 : val.value);
    });
    if (ind === -1 || localIndex === ind) return;
    setLocalIndex(ind);
  }, [items, localIndex, val]);
  var arr = open ? [].concat(items).sort(function (x, y) {
    return x == val ? -1 : y == val ? 1 : 0;
  }) : val ? [val] : [];
  var transition = core.useTransition(arr, {
    keys: function keys(item) {
      return item.value;
    },
    trail: 300 / items.length,
    from: {
      scale: 0,
      y: 0
    },
    enter: function enter(a, i) {
      return {
        scale: 1,
        y: -0.05 * i
      };
    },
    update: function update(a, i) {
      return {
        scale: 1,
        y: -0.05 * i
      };
    },
    leave: {
      scale: 0,
      y: 0
    },
    reset: reset,
    onRest: function onRest() {
      return setReset(false);
    }
  });

  var _useSpring = three$1.useSpring({
    rot: open ? Math.PI : 0,
    posZ: open ? 0.025 : 0
  }),
      rot = _useSpring.rot,
      posZ = _useSpring.posZ;

  var _onClick = function onClick(value) {
    if (open) {
      setVal(value);
      setReset(true);
    }

    setOpen(!open);
  };

  return /*#__PURE__*/React.createElement("group", _extends__default["default"]({
    name: "spacesvr-dropdown"
  }, rest), /*#__PURE__*/React.createElement(three$1.a.group, {
    "position-z": posZ
  }, transition(function (_ref, it, t, index) {
    var scale = _ref.scale,
        y = _ref.y;
    return /*#__PURE__*/React.createElement(three$1.a.group, {
      scale: scale,
      "position-y": y
    }, /*#__PURE__*/React.createElement(Option, {
      onClick: function onClick() {
        return _onClick(it.value);
      },
      width: width,
      index: index
    }, it.text));
  }), items.length > 1 && /*#__PURE__*/React.createElement(three$1.a.group, {
    "rotation-z": rot,
    "position-x": width / 2 - 0.03 / 2 - 0.01,
    "position-z": 0.01 / 2 + 0.001
  }, /*#__PURE__*/React.createElement(Image$1, {
    src: "https://d27rt3a60hh1lx.cloudfront.net/icons/chevron-down.ktx2",
    scale: 0.03
  }))));
}

function VoiceLevels(props) {
  var _useNetwork = useNetwork(),
      localStream = _useNetwork.localStream;

  var _useState = react.useState(),
      analyser = _useState[0],
      setAnalyser = _useState[1];

  var _useState2 = react.useState(document.createElement("canvas")),
      canvas = _useState2[0];

  var _useState3 = react.useState(new Uint8Array(128)),
      dataArray = _useState3[0];

  var canvasTexture = react.useRef(null);
  react.useEffect(function () {
    if (!localStream) return; // @ts-ignore

    var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    var analyser = audioCtx.createAnalyser();
    analyser.fftSize = 128;
    var bufferLength = analyser.frequencyBinCount;
    var dataArray = new Uint8Array(bufferLength);
    analyser.getByteTimeDomainData(dataArray);
    analyser.smoothingTimeConstant = 0.8;
    var source = audioCtx.createMediaStreamSource(localStream);
    source.connect(analyser);
    setAnalyser(analyser);
  }, [localStream]);
  fiber.useFrame(function () {
    var canvasCtx = canvas.getContext("2d");
    if (!analyser || !canvasCtx || !canvasTexture.current) return;
    canvasTexture.current.needsUpdate = true;
    analyser.getByteFrequencyData(dataArray);
    analyser.smoothingTimeConstant = 0.85;
    canvasCtx.clearRect(0, 0, canvas.width, canvas.height); // canvasCtx.fillStyle = "#20C20E";
    // canvasCtx.fillRect(0, 0, canvas.width, canvas.height);

    canvasCtx.fillStyle = "rgb(0, 0, 0)";
    var buckets = 6;
    var spacing = 4;
    var height = 20;
    var sliceWidth = canvas.width / buckets - spacing;
    var x = 0;

    for (var b = 0; b < buckets; b++) {
      var base_perc = 0.2;
      var realY = (dataArray[b] / 256.0 * (1 - base_perc) + base_perc) * canvas.height;
      var y = 0;

      while (y < realY) {
        var nextY = Math.min(y + height, realY);
        canvasCtx.fillRect(x, canvas.height - y, sliceWidth, height);
        y = nextY + spacing;
      }

      x += sliceWidth + spacing;
    }
  });
  if (!localStream) return null;
  return /*#__PURE__*/React.createElement("group", _extends__default["default"]({
    name: "voice-levels"
  }, props), /*#__PURE__*/React.createElement("mesh", null, /*#__PURE__*/React.createElement("planeGeometry", {
    args: [0.095, 0.075]
  }), /*#__PURE__*/React.createElement("meshStandardMaterial", {
    transparent: true
  }, /*#__PURE__*/React.createElement("canvasTexture", {
    // minFilter={LinearFilter}
    ref: canvasTexture,
    args: [canvas],
    attach: "map"
  }))));
}

var _excluded$6 = ["width"];
function Request(props) {
  var width = props.width,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$6);

  var FONT_SIZE = 0.0225;
  var DEPTH = 0.01;
  var PADDING_Y = 0.0125;
  var NOT_AVAILABLE = !navigator.mediaDevices || !navigator.mediaDevices.getUserMedia;
  var message = NOT_AVAILABLE ? "this site cannot access your microphone" : "give this site access to your microphone to talk!";
  return /*#__PURE__*/React.createElement("group", rest, /*#__PURE__*/React.createElement(drei.Text, {
    fontSize: FONT_SIZE,
    color: "black",
    "position-z": DEPTH / 2 + 0.001,
    maxWidth: width,
    textAlign: "center"
  }, message), /*#__PURE__*/React.createElement(RoundedBox, {
    args: [width, FONT_SIZE * 2 + PADDING_Y * 4, DEPTH],
    material: cache.mat_standard_white
  }));
}

var _excluded$5 = ["width"];
function MicAccess(props) {
  var width = props.width,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$5);

  var _useNetwork = useNetwork(),
      localStream = _useNetwork.localStream,
      setInputDevice = _useNetwork.setInputDevice;

  var _useState = react.useState([]),
      inputDevices = _useState[0],
      setInputDevices = _useState[1];

  var _useState2 = react.useState(),
      selectedDevice = _useState2[0],
      setSelectedDevice = _useState2[1];

  var _useState3 = react.useState(false),
      loading = _useState3[0],
      setLoading = _useState3[1];

  var _useState4 = react.useState(false),
      mute = _useState4[0],
      setMute = _useState4[1];

  var permissionGranted = !!localStream;
  var refreshDevices = react.useCallback(function () {
    var _navigator$mediaDevic;

    (_navigator$mediaDevic = navigator.mediaDevices) == null ? void 0 : _navigator$mediaDevic.enumerateDevices().then(function (devices) {
      devices = devices.filter(function (device) {
        return device.kind === "audioinput";
      });
      devices = devices.filter(function (device, index) {
        return devices.findIndex(function (d) {
          return d.groupId === device.groupId;
        }) === index;
      });
      setInputDevices(devices);
    });
  }, []);
  react.useEffect(function () {
    if (localStream) refreshDevices();
  }, [localStream, refreshDevices]);
  react.useEffect(function () {
    if (!navigator.mediaDevices) return;

    navigator.mediaDevices.ondevicechange = function () {
      return refreshDevices();
    };
  }, [refreshDevices]);
  react.useEffect(function () {
    var id = localStream == null ? void 0 : localStream.getTracks()[0].getSettings().deviceId;
    setLoading(!!selectedDevice && selectedDevice !== id);
  }, [localStream, selectedDevice]);
  react.useEffect(function () {
    if (!localStream) return;
    localStream.getAudioTracks()[0].enabled = !mute;
  }, [localStream, mute]);
  return /*#__PURE__*/React.createElement("group", _extends__default["default"]({
    name: "mic-access"
  }, rest), /*#__PURE__*/React.createElement(Pane, {
    width: width,
    height: 0.1
  }, /*#__PURE__*/React.createElement(Image$1, {
    src: mute || !permissionGranted ? "https://d27rt3a60hh1lx.cloudfront.net/icons/microphone-off.ktx2" : "https://d27rt3a60hh1lx.cloudfront.net/icons/microphone.ktx2",
    scale: 0.075,
    "position-x": -width / 2 + 0.075 / 2 + 0.04
  }), /*#__PURE__*/React.createElement("group", {
    "position-x": width / 2 - 0.075 / 2 - 0.04
  }, loading || !permissionGranted && /*#__PURE__*/React.createElement(Spinning, {
    ySpeed: 0,
    zSpeed: 2
  }, /*#__PURE__*/React.createElement(Image$1, {
    src: "https://d27rt3a60hh1lx.cloudfront.net/icons/loader.ktx2",
    scale: 0.075
  })), !loading && /*#__PURE__*/React.createElement(VoiceLevels, {
    "position-x": -0.01
  })), permissionGranted && /*#__PURE__*/React.createElement("group", {
    "position-y": -0.095
  }, /*#__PURE__*/React.createElement(Switch, {
    value: mute,
    onChange: setMute,
    scale: 0.4,
    "position-x": 0.07
  }), /*#__PURE__*/React.createElement(drei.Text, {
    fontSize: 0.035,
    anchorX: "right",
    "position-x": -0.01,
    color: "black"
  }, "mute")), permissionGranted && /*#__PURE__*/React.createElement(DropDown, {
    "position-y": -0.15,
    value: localStream == null ? void 0 : localStream.getTracks()[0].getSettings().deviceId,
    items: inputDevices.map(function (device, i) {
      return {
        text: device.label || "microphone " + i,
        value: device.deviceId
      };
    }),
    width: width,
    "position-z": 0,
    onChange: function onChange(item) {
      setInputDevice(item.value);
      setSelectedDevice(item.value);
    }
  }), !permissionGranted && /*#__PURE__*/React.createElement(Request, {
    "position-y": -0.125,
    "position-z": 0.15,
    width: width
  })));
}

var FONT_URL$3 = "https://d27rt3a60hh1lx.cloudfront.net/fonts/Quicksand_Bold.otf";
function WalkieTalkie() {
  var TOOL_NAME = "Walkie Talkie";
  var toolbelt = useToolbelt();

  var _useEnvironment = useEnvironment(),
      device = _useEnvironment.device;

  var WIDTH = 0.5;
  var HEIGHT = 0.55;
  var DEPTH = 0.1;
  return /*#__PURE__*/React.createElement(Tool, {
    name: TOOL_NAME,
    pos: [0, 0],
    range: device.mobile ? 0 : 0.2,
    pinY: true
  }, /*#__PURE__*/React.createElement("group", {
    "position-y": -0.05,
    scale: 1.25
  }, /*#__PURE__*/React.createElement(TalkieModel, {
    width: WIDTH,
    height: HEIGHT,
    depth: DEPTH
  }), /*#__PURE__*/React.createElement("group", {
    name: "content",
    "position-z": 0.1 / 2 + 0.001
  }, /*#__PURE__*/React.createElement(MicAccess, {
    "position-y": 0.15,
    width: WIDTH * 0.65
  }), /*#__PURE__*/React.createElement(drei.Text, {
    fontSize: 0.022,
    color: "black",
    font: FONT_URL$3,
    maxWidth: WIDTH * 0.5,
    anchorY: "top",
    "position-y": -0.05,
    textAlign: "center",
    scale: 1.1
  }, "proximity voice chat is enabled in this world.\n\nwalk up to someone and say hello!"), /*#__PURE__*/React.createElement(Button$1, {
    onClick: function onClick() {
      return toolbelt.hide();
    },
    fontSize: 0.03,
    "position-y": -0.21,
    "rotation-x": -0.4,
    color: "#f2445e"
  }, "close"))));
}

var _excluded$4 = ["children", "disableEntities", "autoconnect"];
function Network(props) {
  var children = props.children,
      disableEntities = props.disableEntities,
      autoconnect = props.autoconnect,
      connectionConfig = _objectWithoutPropertiesLoose__default["default"](props, _excluded$4);

  var connection = useConnection(connectionConfig);
  var connected = connection.connected,
      connect = connection.connect,
      disconnect = connection.disconnect; // connect on start if autoconnect is enabled

  react.useEffect(function () {
    if (autoconnect) connect();
  }, [autoconnect]); // log status on changes

  var lastVal = react.useRef(false);
  react.useEffect(function () {
    if (lastVal.current !== connected) {
      console.info("network " + (connected ? "connected" : "disconnected"));
      lastVal.current = connected;
    }
  }, [connected]); // disconnect on the way out (i hope it works)

  react.useEffect(function () {
    window.addEventListener("beforeunload", disconnect);
    return function () {
      return window.removeEventListener("beforeunload", disconnect);
    };
  }, [disconnect]);
  return /*#__PURE__*/React.createElement(NetworkContext.Provider, {
    value: connection
  }, !disableEntities && /*#__PURE__*/React.createElement(NetworkedEntities, null), connection.voice && /*#__PURE__*/React.createElement(WalkieTalkie, null), children);
}

var _excluded$3 = ["children"];
var defaultPhysicsProps = {
  size: 50,
  allowSleep: false,
  gravity: [0, -9.8, 0],
  defaultContactMaterial: {
    friction: 0
  }
};
function Physics(props) {
  var children = props.children,
      physicsProps = _objectWithoutPropertiesLoose__default["default"](props, _excluded$3);

  return /*#__PURE__*/React.createElement(cannon.Physics, _extends__default["default"]({}, defaultPhysicsProps, physicsProps), /*#__PURE__*/React.createElement(react.Suspense, {
    fallback: null
  }, children));
}

function StandardReality(props) {
  var children = props.children,
      environmentProps = props.environmentProps,
      physicsProps = props.physicsProps,
      networkProps = props.networkProps,
      playerProps = props.playerProps,
      toolbeltProps = props.toolbeltProps,
      _props$disableGround = props.disableGround,
      disableGround = _props$disableGround === void 0 ? false : _props$disableGround;
  return /*#__PURE__*/React.createElement(Environment, environmentProps, /*#__PURE__*/React.createElement(Physics, physicsProps, /*#__PURE__*/React.createElement(Player, playerProps, /*#__PURE__*/React.createElement(Toolbelt, toolbeltProps, /*#__PURE__*/React.createElement(Network, networkProps, /*#__PURE__*/React.createElement(Visual, null, !disableGround && /*#__PURE__*/React.createElement(InfinitePlane, null), children))))));
}

var usePhotography = function usePhotography(cam) {
  var _useEnvironment = useEnvironment(),
      device = _useEnvironment.device;

  var _useThree = fiber.useThree(),
      scene = _useThree.scene;

  var _useState = react.useState(),
      data = _useState[0],
      setData = _useState[1];

  var resolution = react.useMemo(function () {
    return new three.Vector2(3, 2).normalize().multiplyScalar(2186);
  }, []);
  var aspect = react.useMemo(function () {
    return resolution.clone().normalize();
  }, [resolution]);
  var target = react.useMemo(function () {
    return new three.WebGLRenderTarget(resolution.x, resolution.y, {
      stencilBuffer: true,
      // text boxes look strange without this idk man
      minFilter: three.NearestFilter,
      magFilter: three.NearestFilter,
      format: three.RGBAFormat
    });
  }, [resolution]);
  var renderer = react.useMemo(function () {
    var r = new three.WebGLRenderer({
      preserveDrawingBuffer: true,
      precision: "highp",
      antialias: true
    });
    r.useLegacyLights = false;
    r.toneMapping = three.NoToneMapping;
    r.outputEncoding = three.sRGBEncoding;
    return r;
  }, []);
  react.useEffect(function () {
    renderer.setSize(target.width, target.height);
    renderer.setPixelRatio(device.desktop ? 2 : 1); // could be 3, just really fat
  }, [device.desktop, target.width, target.height, renderer]);
  var takePicture = react.useCallback(function () {
    if (!cam.current) return;
    document.body.append(renderer.domElement);
    cam.current.aspect = aspect.x / aspect.y;
    renderer.render(scene, cam.current);
    var today = new Date();
    var name = document.title + " - www.muse.place" + window.location.pathname + " - " + today.toLocaleDateString("en-US") + " " + today.getHours() + ":" + today.getMinutes();

    if (!device.mobile) {
      var link = document.createElement("a");
      link.download = name + ".jpg";
      link.href = renderer.domElement.toDataURL("image/jpeg");
      link.click();
      link.remove();
    } else {
      setData(renderer.domElement.toDataURL("image/jpeg"));
    }

    document.body.removeChild(renderer.domElement);
  }, [aspect.x, aspect.y, cam, device.mobile, renderer, scene]);
  return {
    resolution: resolution,
    aspect: aspect,
    takePicture: takePicture,
    target: target,
    renderer: renderer,
    data: {
      value: data,
      set: setData
    }
  };
};

var useRendering = function useRendering(enabled, cam, group, mesh, photo) {
  var _useEnvironment = useEnvironment(),
      paused = _useEnvironment.paused;

  var _useThree = fiber.useThree(),
      scene = _useThree.scene;

  var dummy = react.useMemo(function () {
    return new three.Vector3();
  }, []);
  var qummy = react.useMemo(function () {
    return new three.Quaternion();
  }, []); // prep render the camera until first pause to compile materials in advance rather than first time tool is enabled

  var prepRendering = react.useRef(true);
  react.useEffect(function () {
    if (!paused) prepRendering.current = false;
  }, [paused]);
  useLimitedFrame(1 / 4, function (state) {
    if (enabled || !prepRendering.current || !cam.current) return; // don't double render

    state.gl.autoClear = true;
    state.gl.setRenderTarget(photo.target);
    state.gl.render(scene, cam.current);
    state.gl.setRenderTarget(null);
    state.gl.autoClear = false;
  });
  useLimitedFrame(24, function (state) {
    if (!cam.current || !mesh.current || !group.current || !enabled) return; // move mesh to camera's position

    mesh.current.getWorldPosition(dummy);
    mesh.current.getWorldQuaternion(qummy);
    cam.current.position.set(0, 0, 0.3).applyQuaternion(qummy); // move back 0.3m

    cam.current.position.add(dummy);
    cam.current.rotation.setFromQuaternion(qummy);
    cam.current.aspect = photo.aspect.x / photo.aspect.y;
    cam.current.updateProjectionMatrix(); // render to camera viewfinder

    state.gl.autoClear = true;
    state.gl.setRenderTarget(photo.target);
    state.gl.render(scene, cam.current);
    state.gl.setRenderTarget(null);
    state.gl.autoClear = false;
  });
};

var FONT_FILE = "https://d27rt3a60hh1lx.cloudfront.net/fonts/Quicksand_Bold.otf";
function Instruction(props) {
  var open = props.open;
      props.setOpen;

  var _useEnvironment = useEnvironment(),
      device = _useEnvironment.device;

  var CLOSED_SCALE = device.mobile ? 0.5 : 0.5;

  var _useSpring = three$1.useSpring({
    scale: open ? 0 : CLOSED_SCALE
  }),
      scale = _useSpring.scale;

  var FONT_SIZE = 0.055;
  var DESKTOP_TEXT = "Press          to " + (open ? "close" : "open");
  var MOBILE_TEXT = "tap to open";
  return /*#__PURE__*/React.createElement(three$1.a.group, {
    scale: scale,
    "position-x": device.mobile ? -0.05 : -0.45,
    "position-y": device.mobile ? -0.2 : 0.1,
    "position-z": 0.25,
    "rotation-x": 0.1,
    "rotation-y": -0.4
  }, /*#__PURE__*/React.createElement(Floating, {
    height: FONT_SIZE * 0.1,
    speed: device.mobile ? 8 : 0
  }, /*#__PURE__*/React.createElement(drei.Text, {
    color: "white",
    fontSize: FONT_SIZE,
    maxWidth: 100,
    textAlign: "center",
    outlineColor: "black",
    outlineWidth: FONT_SIZE * 0.1,
    font: FONT_FILE,
    "position-y": -0.02
  }, device.mobile ? MOBILE_TEXT : DESKTOP_TEXT)), device.desktop && /*#__PURE__*/React.createElement(Floating, {
    height: FONT_SIZE * 0.1,
    speed: 8
  }, /*#__PURE__*/React.createElement(Key, {
    keyCode: "C",
    keyPress: ["c", "C"],
    scale: 0.1,
    "position-x": -0.035,
    "position-z": 0.1,
    "rotation-x": -0.3
  })));
}

var _excluded$2 = ["cam", "open", "fov"];
var FONT_URL$2 = "https://d27rt3a60hh1lx.cloudfront.net/fonts/Quicksand_Bold.otf";
function DesktopControls(props) {
  var cam = props.cam;
      props.open;
      var fov = props.fov,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$2);

  var LINE_LENGTH = 0.05;
  var LINE_THICKNESS = 0.008;
  var AREA_WIDTH = 0.24;
  var INDICATOR_WIDTH = 0.18;

  var _useSpring = three$1.useSpring({
    posX: fov.normalized * -INDICATOR_WIDTH + INDICATOR_WIDTH / 2
  }),
      posX = _useSpring.posX;

  react.useEffect(function () {
    // increase/decrease fov on scroll
    var onScroll = function onScroll(e) {
      if (!cam.current) return;
      var newVal = cam.current.fov + e.deltaY * 0.05;
      fov.set(newVal);
    };

    window.addEventListener("wheel", onScroll);
    return function () {
      return window.removeEventListener("wheel", onScroll);
    };
  }, [cam, fov]);
  return /*#__PURE__*/React.createElement("group", rest, /*#__PURE__*/React.createElement("mesh", {
    material: cache.mat_standard_white
  }, /*#__PURE__*/React.createElement("planeGeometry", {
    args: [INDICATOR_WIDTH, LINE_THICKNESS]
  })), /*#__PURE__*/React.createElement(three$1.animated.mesh, {
    material: cache.mat_standard_red,
    "position-x": posX,
    "position-y": LINE_LENGTH / 2 - LINE_THICKNESS / 2
  }, /*#__PURE__*/React.createElement("planeGeometry", {
    args: [LINE_THICKNESS, LINE_LENGTH]
  })), /*#__PURE__*/React.createElement(drei.Text, {
    font: FONT_URL$2,
    color: "white",
    fontSize: 0.032,
    anchorY: "top",
    anchorX: "right",
    "position-y": -0.02,
    "position-x": AREA_WIDTH / 2,
    "position-z": 0.01,
    lineHeight: 1.3,
    renderOrder: 10,
    textAlign: "center",
    maxWidth: AREA_WIDTH
  }, "Scroll to zoom\n\n\nClick to shoot\n\n\nPress        to close"), /*#__PURE__*/React.createElement(Key, {
    keyCode: "C",
    scale: 0.05,
    position: [0.025, -0.29, 0.03]
  }));
}

var _excluded$1 = ["open", "pressed", "setPressed", "onPress"];
var FONT_URL$1 = "https://d27rt3a60hh1lx.cloudfront.net/fonts/Quicksand_Bold.otf";
function ShutterButton(props) {
  var open = props.open,
      pressed = props.pressed,
      setPressed = props.setPressed,
      onPress = props.onPress,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded$1);

  var _useEnvironment = useEnvironment(),
      device = _useEnvironment.device;

  var _useState = react.useState(false),
      pressedOnce = _useState[0],
      setPressedOnce = _useState[1];

  react.useEffect(function () {
    if (pressed) {
      setTimeout(function () {
        return setPressed(false);
      }, 750);
      setPressedOnce(true);
    }
  }, [pressed, setPressed]);

  var _useSpring = three$1.useSpring({
    shutterY: !pressed ? 1 : 0.6,
    config: three$1.config.stiff
  }),
      shutterY = _useSpring.shutterY;

  return /*#__PURE__*/React.createElement("group", rest, /*#__PURE__*/React.createElement(three$1.animated.group, {
    "scale-y": shutterY
  }, /*#__PURE__*/React.createElement(RoundedBox, {
    args: [0.4, 0.55, 0.2],
    material: cache.mat_standard_red
  })), device.mobile && /*#__PURE__*/React.createElement(HitBox, {
    args: [0.4, 0.55, 0.2],
    onClick: onPress,
    scale: 1.5,
    "position-y": 0.2
  }, "close"), !pressedOnce && open && device.mobile && /*#__PURE__*/React.createElement(Floating, {
    height: 0.025,
    speed: 15
  }, /*#__PURE__*/React.createElement(drei.Text, {
    font: FONT_URL$1,
    fontSize: 0.15,
    color: "white",
    outlineColor: "black",
    outlineWidth: 0.15 / 10,
    anchorY: "bottom",
    "position-y": 0.325
  }, "Tap to Shoot!")), /*#__PURE__*/React.createElement("mesh", {
    name: "cover-mesh",
    "position-x": 0.05,
    material: cache.mat_standard_black,
    "position-y": -0.17
  }, /*#__PURE__*/React.createElement("boxGeometry", {
    args: [0.5, 0.5, 0.3]
  })));
}

var MIN_FOV = 10;
var MAX_FOV = 85;
var useFov = function useFov(cam) {
  var _useState = react.useState(50),
      fov = _useState[0],
      setFov = _useState[1];

  var change = react.useCallback(function (newVal) {
    if (!cam.current) return;
    var fov = three.MathUtils.clamp(newVal, MIN_FOV, MAX_FOV);
    cam.current.fov = fov;
    cam.current.updateProjectionMatrix();
    setFov(fov);
  }, [cam]);
  return {
    val: fov,
    normalized: (fov - MIN_FOV) / (MAX_FOV - MIN_FOV),
    set: change,
    min: MIN_FOV,
    max: MAX_FOV
  };
};

var _excluded = ["cam", "open", "setOpen", "fov"];
var FONT_URL = "https://d27rt3a60hh1lx.cloudfront.net/fonts/Quicksand_Bold.otf";
function MobileControls(props) {
  var cam = props.cam,
      open = props.open,
      setOpen = props.setOpen,
      fov = props.fov,
      rest = _objectWithoutPropertiesLoose__default["default"](props, _excluded);

  var _useThree = fiber.useThree(),
      gl = _useThree.gl;

  var _usePlayer = usePlayer(),
      raycaster = _usePlayer.raycaster;

  var hitbox = react.useRef(null);
  var touchInside = react.useRef(false);
  var startVal = react.useRef();
  var LINE_LENGTH = 0.05;
  var LINE_THICKNESS = 0.008;
  var AREA_HEIGHT = 0.35;

  var _useSpring = three$1.useSpring({
    posY: fov.normalized * -AREA_HEIGHT + AREA_HEIGHT / 2 - LINE_THICKNESS
  }),
      posY = _useSpring.posY;

  useDrag({
    onStart: function onStart(_ref) {
      var e = _ref.e;
      if (!hitbox.current) return;
      var intersections = raycaster.intersectObject(hitbox.current);
      if (intersections.length === 0) return;
      touchInside.current = true;
      e.stopImmediatePropagation();
    },
    onMove: function onMove(_ref2) {
      var _cam$current;

      var delta = _ref2.delta;
      if (!touchInside.current) return;
      if (!startVal.current) startVal.current = ((_cam$current = cam.current) == null ? void 0 : _cam$current.fov) || 0;
      var newVal = startVal.current + delta.y * 0.5;
      fov.set(newVal);
    },
    onEnd: function onEnd() {
      touchInside.current = false;
      startVal.current = undefined;
    }
  }, gl.domElement, [fov]);
  return /*#__PURE__*/React.createElement("group", rest, /*#__PURE__*/React.createElement("group", {
    "position-y": -0.15
  }, /*#__PURE__*/React.createElement(HitBox, {
    ref: hitbox,
    args: [0.25, AREA_HEIGHT * 1.2, 0.05]
  }), /*#__PURE__*/React.createElement("mesh", {
    material: cache.mat_standard_white
  }, /*#__PURE__*/React.createElement("planeGeometry", {
    args: [LINE_THICKNESS * 2, AREA_HEIGHT]
  })), /*#__PURE__*/React.createElement(three$1.animated.mesh, {
    material: cache.mat_standard_red,
    "position-y": posY
  }, /*#__PURE__*/React.createElement("planeGeometry", {
    args: [LINE_LENGTH * 2, LINE_THICKNESS * 4]
  }))), /*#__PURE__*/React.createElement(drei.Text, {
    font: FONT_URL,
    color: "white",
    fontSize: 0.044,
    anchorY: "top",
    anchorX: "center",
    "position-y": -0.35,
    "position-z": 0.01,
    lineHeight: 1.3,
    renderOrder: 10,
    textAlign: "center"
  }, "FOV Slider"), open && /*#__PURE__*/React.createElement(Button$1, {
    "position-y": 0.48,
    "position-x": -1,
    scale: 1.5,
    "rotation-x": 0.2,
    color: "#ff0000",
    onClick: function onClick() {
      return setOpen(false);
    }
  }, "close"));
}

var _templateObject, _templateObject2, _templateObject3, _templateObject4, _templateObject5;
var Wrapper = styled__default["default"].div(_templateObject || (_templateObject = _taggedTemplateLiteralLoose__default["default"](["\n  position: absolute;\n  display: flex;\n  flex-direction: column;\n  z-index: 10;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n  padding: 25px 25px 30px;\n  box-sizing: border-box;\n  background: black;\n  width: 90vw;\n"])));
var Background = styled__default["default"].div(_templateObject2 || (_templateObject2 = _taggedTemplateLiteralLoose__default["default"](["\n  position: absolute;\n  z-index: 9;\n  width: 100%;\n  height: 100%;\n  top: 0;\n  left: 0;\n  background: black;\n  opacity: 0.6;\n"])));
var Image = styled__default["default"].img(_templateObject3 || (_templateObject3 = _taggedTemplateLiteralLoose__default["default"](["\n  width: 100%;\n  height: auto;\n  object-fit: contain;\n"])));
var Text = styled__default["default"].p(_templateObject4 || (_templateObject4 = _taggedTemplateLiteralLoose__default["default"](["\n  color: white;\n  text-align: center;\n  font-size: 1.15rem;\n"])));
var Button = styled__default["default"].button(_templateObject5 || (_templateObject5 = _taggedTemplateLiteralLoose__default["default"](["\n  background: white;\n  border: none;\n  color: black;\n  padding: 10px 20px;\n  font-size: 1rem;\n  font-family: inherit;\n  border-radius: 10px;\n  font-weight: bold;\n  margin: 0 auto;\n"])));
function PhotoPreview(props) {
  var photo = props.photo;

  var _useEnvironment = useEnvironment(),
      containerRef = _useEnvironment.containerRef,
      device = _useEnvironment.device;

  if (!photo.data.value || !containerRef.current || !device.mobile) return null;
  return /*#__PURE__*/React.createElement(drei.Html, null, /*#__PURE__*/reactDom.createPortal( /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Wrapper, null, /*#__PURE__*/React.createElement(Image, {
    src: photo.data.value
  }), /*#__PURE__*/React.createElement(Text, null, "press and hold the image to save it"), /*#__PURE__*/React.createElement(Button, {
    onClick: function onClick() {
      return photo.data.set(undefined);
    }
  }, "close")), /*#__PURE__*/React.createElement(Background, null)), containerRef.current));
}

var AUDIO_URL = "https://d27rt3a60hh1lx.cloudfront.net/tools/camera/shutter-sound.mp3";
var CAMERA_MODEL_URL = "https://d1htv66kutdwsl.cloudfront.net/0308efc4-0b68-4b2e-b688-92512323178b/aa44f4af-f7c2-4050-9e6c-536ee07bbb1a.glb";
var CAMERA_ICON_URL = "https://d1htv66kutdwsl.cloudfront.net/44e643ef-7fe6-45da-9f99-54a5988ff338/8eb59c54-4aba-479a-b7cd-54a300b36c20.png";
var TIMEOUT = 2; //s

function Camera(props) {
  var _toolbelt$activeTool;

  var onCapture = props.onCapture;

  var _useEnvironment = useEnvironment(),
      device = _useEnvironment.device,
      paused = _useEnvironment.paused;

  var _useThree = fiber.useThree(),
      scene = _useThree.scene,
      clock = _useThree.clock;

  var toolbelt = useToolbelt();
  var cam = react.useRef();
  var group = react.useRef(null);
  var mesh = react.useRef(null);

  var _useState = react.useState(false),
      open = _useState[0],
      setOpen = _useState[1];

  var _useState2 = react.useState(false),
      shutterPressed = _useState2[0],
      setShutterPressed = _useState2[1];

  var fov = useFov(cam);
  var lastShotTime = react.useRef(0);
  var ENABLED = ((_toolbelt$activeTool = toolbelt.activeTool) == null ? void 0 : _toolbelt$activeTool.name) === "Camera";
  var photo = usePhotography(cam);
  var dims = useHudDims();
  var SCALE = Math.min(dims.width * 0.25, device.mobile ? 0.2 : 0.325);

  var _useSpring = three$1.useSpring({
    rotX: open ? 0 : 0.3,
    rotY: open ? 0 : device.mobile ? Math.PI - 0.5 : -0.1,
    scale: open ? SCALE : device.mobile ? 0.1 : 0.25,
    config: three$1.config.stiff
  }),
      rotX = _useSpring.rotX,
      rotY = _useSpring.rotY,
      scale = _useSpring.scale;

  useRendering(ENABLED && open, cam, group, mesh, photo);
  var onClick = react.useCallback(function () {
    if (shutterPressed) return;
    if (lastShotTime.current + TIMEOUT > clock.getElapsedTime()) return;
    lastShotTime.current = clock.getElapsedTime();
    setShutterPressed(true);
    var audio = new Audio(AUDIO_URL);
    audio.play();
    setTimeout(function () {
      // let the shutter sound and anim play
      photo.takePicture();
      if (onCapture) onCapture();
    }, 300);
  }, [clock, onCapture, photo, shutterPressed]);
  react.useEffect(function () {
    if (!ENABLED || paused || device.mobile || !open) return;
    document.addEventListener("click", onClick);
    return function () {
      return document.removeEventListener("click", onClick);
    };
  }, [ENABLED, device.mobile, onClick, open, paused]);
  useKeypress(["c", "C"], function () {
    if (isTyping() || !ENABLED) return;
    setOpen(!open);
  }, [ENABLED, open]);
  var POS = open ? [0, 0] : device.mobile ? [0.9, 0.9] : [0.8, -0.8];
  return /*#__PURE__*/React.createElement("group", {
    name: "camera-tool-resources",
    ref: group
  }, /*#__PURE__*/React.createElement(Tool, {
    name: "Camera",
    pos: POS,
    pinY: true,
    icon: CAMERA_ICON_URL,
    face: false,
    disableDraggable: open,
    onSwitch: function onSwitch(e) {
      return !e && setOpen(false);
    }
  }, /*#__PURE__*/React.createElement(Instruction, {
    open: open,
    setOpen: setOpen
  }), /*#__PURE__*/React.createElement(three$1.animated.group, {
    scale: scale,
    "rotation-x": rotX,
    "rotation-y": rotY
  }, /*#__PURE__*/React.createElement(Model, {
    src: CAMERA_MODEL_URL,
    center: true,
    normalize: true,
    "rotation-y": Math.PI,
    scale: 3
  }), device.mobile && !open && /*#__PURE__*/React.createElement(HitBox, {
    args: [3, 1.8, 1.6],
    "position-z": 0.3,
    onClick: function onClick() {
      return setOpen(true);
    }
  }), /*#__PURE__*/React.createElement("group", {
    name: "top-row",
    position: [1, 0.7, 0.75]
  }, /*#__PURE__*/React.createElement(ShutterButton, {
    open: open,
    pressed: shutterPressed,
    setPressed: setShutterPressed,
    onPress: onClick
  })), /*#__PURE__*/React.createElement("group", {
    name: "content",
    position: [0, -0.18, 1.101],
    scale: 2
  }, /*#__PURE__*/React.createElement("mesh", {
    ref: mesh,
    name: "viewfinder",
    position: [-0.15, 0.03, 0],
    "scale-x": 1.1,
    "scale-y": 1.1
  }, /*#__PURE__*/React.createElement("planeGeometry", {
    args: [photo.aspect.x, photo.aspect.y]
  }), /*#__PURE__*/React.createElement("meshStandardMaterial", {
    map: photo.target.texture,
    metalness: 0.68,
    roughness: 0.7
  })), device.desktop ? /*#__PURE__*/React.createElement(DesktopControls, {
    cam: cam,
    open: open,
    fov: fov,
    position: [0.485, 0.12, 0.005]
  }) : /*#__PURE__*/React.createElement(MobileControls, {
    cam: cam,
    open: open,
    setOpen: setOpen,
    fov: fov,
    position: [0.5, 0.12, 0.004]
  })))), fiber.createPortal( /*#__PURE__*/React.createElement(drei.PerspectiveCamera, {
    ref: cam,
    near: 0.01,
    far: 300
  }), scene), /*#__PURE__*/React.createElement(PhotoPreview, {
    photo: photo
  }));
}

function LostWorld() {
  return /*#__PURE__*/React.createElement("group", {
    name: "lost-world"
  }, /*#__PURE__*/React.createElement(Fog, {
    color: "white",
    near: 0.1,
    far: 15
  }), /*#__PURE__*/React.createElement("directionalLight", {
    "position-y": 1,
    intensity: 1.8
  }), /*#__PURE__*/React.createElement("ambientLight", {
    intensity: 1
  }), /*#__PURE__*/React.createElement(Background$1, {
    color: "white"
  }), /*#__PURE__*/React.createElement(LostFloor, null));
}

exports.Anchor = Anchor;
exports.Arrow = Arrow;
exports.Audio = Audio$1;
exports.Background = Background$1;
exports.Button = Button$1;
exports.Camera = Camera;
exports.Collidable = Collidable;
exports.Dialogue = Dialogue;
exports.Environment = Environment;
exports.EnvironmentContext = EnvironmentContext;
exports.FacePlayer = FacePlayer;
exports.Floating = Floating;
exports.Fog = Fog;
exports.Frame = Frame;
exports.HDRI = HDRI;
exports.HitBox = HitBox;
exports.Idea = Idea;
exports.Image = Image$1;
exports.InfinitePlane = InfinitePlane;
exports.Interactable = Interactable;
exports.Key = Key;
exports.LookAtPlayer = LookAtPlayer;
exports.LostFloor = LostFloor;
exports.LostWorld = LostWorld;
exports.Model = Model;
exports.Network = Network;
exports.NetworkContext = NetworkContext;
exports.Physics = Physics;
exports.Player = Player;
exports.PlayerContext = PlayerContext;
exports.RoundedBox = RoundedBox;
exports.Site = Site;
exports.Spinning = Spinning;
exports.StandardReality = StandardReality;
exports.Switch = Switch;
exports.TextInput = TextInput;
exports.Tool = Tool;
exports.Toolbelt = Toolbelt;
exports.ToolbeltContext = ToolbeltContext;
exports.Video = Video;
exports.Visual = Visual;
exports.VisualContext = VisualContext;
exports.VisualEffect = VisualEffect;
exports.VisualIdea = VisualIdea;
exports.VisualWorld = VisualWorld;
exports.WalkieTalkie = WalkieTalkie;
exports.World = World;
exports.cache = cache;
exports.enableBVHRaycast = enableBVHRaycast;
exports.getHudDims = getHudDims;
exports.getHudPos = getHudPos;
exports.isTyping = isTyping;
exports.useDrag = useDrag;
exports.useEnvironment = useEnvironment;
exports.useEnvironmentState = useEnvironmentState;
exports.useHTMLInput = useHTMLInput;
exports.useHudDims = useHudDims;
exports.useImage = useImage;
exports.useKeyboardLayout = useKeyboardLayout;
exports.useKeypress = useKeypress;
exports.useLimitedFrame = useLimitedFrame;
exports.useLimiter = useLimiter;
exports.useMetaHold = useMetaHold;
exports.useModel = useModel;
exports.useNetwork = useNetwork;
exports.usePlayer = usePlayer;
exports.useRerender = useRerender;
exports.useShiftHold = useShiftHold;
exports.useTextInput = useTextInput;
exports.useToolbelt = useToolbelt;
exports.useToolbeltState = useToolbeltState;
exports.useTrimeshCollision = useTrimeshCollision$1;
exports.useVisible = useVisible;
exports.useVisual = useVisual;
